/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/mint",{

/***/ "./pages/mint.js":
/*!***********************!*\
  !*** ./pages/mint.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MintPage; }\n/* harmony export */ });\n/* harmony import */ var C_Users_Blaine_Crypto_Solidity_lgg_nft2_nextjs_blog_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\");\n/* harmony import */ var C_Users_Blaine_Crypto_Solidity_lgg_nft2_nextjs_blog_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_Blaine_Crypto_Solidity_lgg_nft2_nextjs_blog_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n// import MetaMaskOnboarding, { forwarderOrigin } from '@metamask/onboarding'\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nvar _s = $RefreshSig$();\nvar createAlchemyWeb3 = (__webpack_require__(/*! @alch/alchemy-web3 */ \"../../node_modules/@alch/alchemy-web3/dist/esm/index.js\").createAlchemyWeb3);\nvar web3 = createAlchemyWeb3('https://eth-ropsten.alchemyapi.io/v2/rFjml79EMZI44Pr5auHaUxIapBl-xs4f');\nfunction MintPage() {\n    _s();\n    function onClickConnect() {\n        return _onClickConnect.apply(this, arguments);\n    }\n    function _onClickConnect() {\n        _onClickConnect = _asyncToGenerator(C_Users_Blaine_Crypto_Solidity_lgg_nft2_nextjs_blog_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n            var connectButton, message_code;\n            return C_Users_Blaine_Crypto_Solidity_lgg_nft2_nextjs_blog_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                while(1)switch(_ctx.prev = _ctx.next){\n                    case 0:\n                        connectButton = document.getElementById('connectMetamask');\n                        if (!(typeof web3 !== 'undefined')) {\n                            _ctx.next = 16;\n                            break;\n                        }\n                        connectButton.innerText = 'Connecting....';\n                        _ctx.prev = 3;\n                        _ctx.next = 6;\n                        return ethereum.request({\n                            method: 'eth_requestAccounts'\n                        });\n                    case 6:\n                        connectButton.innerText = 'Connected';\n                        connectButton.disabled = true;\n                        _ctx.next = 14;\n                        break;\n                    case 10:\n                        _ctx.prev = 10;\n                        _ctx.t0 = _ctx[\"catch\"](3);\n                        message_code = _ctx.t0['code'];\n                        if (message_code == 4001) {\n                            connectButton.innerText = 'Connect Metamask';\n                        }\n                    case 14:\n                        _ctx.next = 17;\n                        break;\n                    case 16:\n                        {\n                            connectButton.innerText = 'Click here to install Metamask First and then refresh this page.';\n                            console.log('MetaMask is not installed');\n                            document.getElementById('connectMetamask').setAttribute('onClick', 'window.open(\"https://metamask.io/\")');\n                        }\n                    case 17:\n                        ;\n                    case 18:\n                    case \"end\":\n                        return _ctx.stop();\n                }\n            }, _callee, null, [\n                [\n                    3,\n                    10\n                ]\n            ]);\n        }));\n        return _onClickConnect.apply(this, arguments);\n    }\n    var testClick = function(e) {\n        console.log('Test console print');\n    };\n    var runOnLoad = function(e) {\n        var connectButton = document.getElementById('connectMetamask');\n        if (typeof web3 == 'undefined') {\n            connectButton.innerText = 'Click here to install Metamask First and then refresh this page.';\n            document.getElementById('connectMetamask').setAttribute('onClick', 'window.open(\"https://metamask.io/\")');\n        } else {\n            web3.eth.getAccounts(function(err, accounts) {\n                if (err != null) console.error(\"An error occurred: \" + err);\n                else if (accounts.length == 0) console.log(\"User is not logged in to MetaMask\");\n                else connectButton.innerText = 'Connected';\n                ;\n            });\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function() {\n        runOnLoad();\n    }, []);\n    return(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"body\", {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n                    children: [\n                        \"Mint Page\",\n                        \" \",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"button\", {\n                            id: \"connectMetamask\",\n                            type: \"button\",\n                            onClick: function(e) {\n                                return onClickConnect();\n                            },\n                            children: \"Connect Metamask\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Blaine\\\\Crypto\\\\Solidity\\\\lgg-nft2\\\\nextjs-blog\\\\pages\\\\mint.js\",\n                            lineNumber: 56,\n                            columnNumber: 7\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Blaine\\\\Crypto\\\\Solidity\\\\lgg-nft2\\\\nextjs-blog\\\\pages\\\\mint.js\",\n                    lineNumber: 54,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"h5\", {\n                    className: \"title\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                        href: \"/\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"a\", {\n                            children: \"Back to main page.\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Blaine\\\\Crypto\\\\Solidity\\\\lgg-nft2\\\\nextjs-blog\\\\pages\\\\mint.js\",\n                            lineNumber: 59,\n                            columnNumber: 26\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Blaine\\\\Crypto\\\\Solidity\\\\lgg-nft2\\\\nextjs-blog\\\\pages\\\\mint.js\",\n                        lineNumber: 59,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Blaine\\\\Crypto\\\\Solidity\\\\lgg-nft2\\\\nextjs-blog\\\\pages\\\\mint.js\",\n                    lineNumber: 58,\n                    columnNumber: 7\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\Blaine\\\\Crypto\\\\Solidity\\\\lgg-nft2\\\\nextjs-blog\\\\pages\\\\mint.js\",\n            lineNumber: 53,\n            columnNumber: 5\n        }, this)\n    }, void 0, false));\n};\n_s(MintPage, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = MintPage;\nvar _c;\n$RefreshReg$(_c, \"MintPage\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9taW50LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUN4QyxFQUE2RTtBQUNqRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUM1QixHQUFLLENBQUdHLGlCQUFpQixHQUFLQyw0SEFBTDtBQUN6QixHQUFLLENBQUNDLElBQUksR0FBR0YsaUJBQWlCLENBQUMsQ0FBdUU7QUFFdkYsUUFBUSxDQUFDRyxRQUFRLEdBQUcsQ0FBQzs7YUFFbkJDLGNBQWM7ZUFBZEEsZUFBYzs7YUFBZEEsZUFBYztRQUFkQSxlQUFjLG9MQUE3QixRQUFRLFdBQXdCLENBQUM7Z0JBQ3pCQyxhQUFhLEVBUVhDLFlBQVk7Ozs7d0JBUmRELGFBQWEsR0FBR0UsUUFBUSxDQUFDQyxjQUFjLENBQUMsQ0FBaUI7OEJBQzNELE1BQU0sQ0FBQ04sSUFBSSxLQUFLLENBQVc7Ozs7d0JBQy9CRyxhQUFhLENBQUNJLFNBQVMsR0FBRyxDQUFnQjs7OytCQUVsQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsQ0FBQzs0QkFBQ0MsTUFBTSxFQUFFLENBQXFCO3dCQUFDLENBQUM7O3dCQUN4RFAsYUFBYSxDQUFDSSxTQUFTLEdBQUcsQ0FBVzt3QkFDckNKLGFBQWEsQ0FBQ1EsUUFBUSxHQUFHLElBQUk7Ozs7Ozt3QkFFdkJQLFlBQVksV0FBUyxDQUFNO3dCQUNqQyxFQUFFLEVBQUVBLFlBQVksSUFBSSxJQUFJLEVBQUUsQ0FBQzs0QkFDekJELGFBQWEsQ0FBQ0ksU0FBUyxHQUFHLENBQWtCO3dCQUM5QyxDQUFDOzs7Ozt3QkFFRSxDQUFDOzRCQUNOSixhQUFhLENBQUNJLFNBQVMsR0FBRyxDQUFrRTs0QkFDM0ZLLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLENBQTJCOzRCQUN2Q1IsUUFBUSxDQUFDQyxjQUFjLENBQUMsQ0FBaUIsa0JBQUVRLFlBQVksQ0FBQyxDQUFTLFVBQUMsQ0FBcUM7d0JBQzFHLENBQUM7Ozs7Ozs7Ozs7Ozs7UUFDSCxDQUFDO2VBbkJnQlosZUFBYzs7SUFxQjdCLEdBQUssQ0FBQ2EsU0FBUyxHQUFHLFFBQVEsQ0FBUEMsQ0FBQyxFQUFLLENBQUM7UUFDeEJKLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLENBQW9CO0lBQ2xDLENBQUM7SUFFRCxHQUFLLENBQUNJLFNBQVMsR0FBRyxRQUFRLENBQVBELENBQUMsRUFBSyxDQUFDO1FBQ3hCLEdBQUssQ0FBQ2IsYUFBYSxHQUFHRSxRQUFRLENBQUNDLGNBQWMsQ0FBQyxDQUFpQjtRQUMvRCxFQUFFLEVBQUUsTUFBTSxDQUFDTixJQUFJLElBQUksQ0FBVyxZQUFDLENBQUM7WUFDOUJHLGFBQWEsQ0FBQ0ksU0FBUyxHQUFHLENBQWtFO1lBQzVGRixRQUFRLENBQUNDLGNBQWMsQ0FBQyxDQUFpQixrQkFBRVEsWUFBWSxDQUFDLENBQVMsVUFBQyxDQUFxQztRQUN6RyxDQUFDLE1BQU0sQ0FBQztZQUNOZCxJQUFJLENBQUNrQixHQUFHLENBQUNDLFdBQVcsQ0FBQyxRQUFRLENBQUNDLEdBQUcsRUFBRUMsUUFBUSxFQUFDLENBQUM7Z0JBQzNDLEVBQUUsRUFBRUQsR0FBRyxJQUFJLElBQUksRUFBRVIsT0FBTyxDQUFDVSxLQUFLLENBQUMsQ0FBcUIsdUJBQUNGLEdBQUc7cUJBQ25ELEVBQUUsRUFBRUMsUUFBUSxDQUFDRSxNQUFNLElBQUksQ0FBQyxFQUFFWCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxDQUFtQztxQkFDekVWLGFBQWEsQ0FBQ0ksU0FBUyxHQUFHLENBQVc7O1lBQzlDLENBQUM7UUFDRCxDQUFDO0lBQ0UsQ0FBQztJQUVOWCxnREFBUyxDQUFDLFFBQVEsR0FBRixDQUFDO1FBQ2ZxQixTQUFTO0lBQ1gsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNMLE1BQU07OEZBRUhPLENBQUk7OzRGQUNKQyxDQUFHOzt3QkFBQyxDQUNNO3dCQUFDLENBQUc7b0dBQ1pDLENBQU07NEJBQUNDLEVBQUUsRUFBQyxDQUFpQjs0QkFBQ0MsSUFBSSxFQUFDLENBQVE7NEJBQUNDLE9BQU8sRUFBRSxRQUFRLENBQVBiLENBQUM7Z0NBQUtkLE1BQU0sQ0FBTkEsY0FBYzs7c0NBQUksQ0FBZ0I7Ozs7Ozs7Ozs7Ozs0RkFFNUY0QixDQUFFO29CQUFDQyxTQUFTLEVBQUMsQ0FBTzswR0FDaEJsQyxrREFBSTt3QkFBQ21DLElBQUksRUFBQyxDQUFHOzhHQUFFQyxDQUFDO3NDQUFDLENBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUs5QyxDQUFDO0dBekR1QmhDLFFBQVE7S0FBUkEsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9taW50LmpzP2VmYmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuLy8gaW1wb3J0IE1ldGFNYXNrT25ib2FyZGluZywgeyBmb3J3YXJkZXJPcmlnaW4gfSBmcm9tICdAbWV0YW1hc2svb25ib2FyZGluZydcclxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xyXG5jb25zdCB7IGNyZWF0ZUFsY2hlbXlXZWIzIH0gPSByZXF1aXJlKFwiQGFsY2gvYWxjaGVteS13ZWIzXCIpXHJcbmNvbnN0IHdlYjMgPSBjcmVhdGVBbGNoZW15V2ViMygnaHR0cHM6Ly9ldGgtcm9wc3Rlbi5hbGNoZW15YXBpLmlvL3YyL3JGam1sNzlFTVpJNDRQcjVhdUhhVXhJYXBCbC14czRmJylcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1pbnRQYWdlKCkge1xyXG5cclxuICBhc3luYyBmdW5jdGlvbiBvbkNsaWNrQ29ubmVjdCgpIHtcclxuICAgIGNvbnN0IGNvbm5lY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29ubmVjdE1ldGFtYXNrJyk7XHJcbiAgICBpZiAodHlwZW9mIHdlYjMgIT09ICd1bmRlZmluZWQnKXtcclxuICAgIGNvbm5lY3RCdXR0b24uaW5uZXJUZXh0ID0gJ0Nvbm5lY3RpbmcuLi4uJztcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJyB9KTtcclxuICAgICAgY29ubmVjdEJ1dHRvbi5pbm5lclRleHQgPSAnQ29ubmVjdGVkJztcclxuICAgICAgY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBtZXNzYWdlX2NvZGUgPSBlcnJvclsnY29kZSddXHJcbiAgICAgIGlmIChtZXNzYWdlX2NvZGUgPT0gNDAwMSkge1xyXG4gICAgICAgIGNvbm5lY3RCdXR0b24uaW5uZXJUZXh0ID0gJ0Nvbm5lY3QgTWV0YW1hc2snO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbm5lY3RCdXR0b24uaW5uZXJUZXh0ID0gJ0NsaWNrIGhlcmUgdG8gaW5zdGFsbCBNZXRhbWFzayBGaXJzdCBhbmQgdGhlbiByZWZyZXNoIHRoaXMgcGFnZS4nO1xyXG4gICAgIGNvbnNvbGUubG9nKCdNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkJylcclxuICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29ubmVjdE1ldGFtYXNrJykuc2V0QXR0cmlidXRlKCdvbkNsaWNrJywnd2luZG93Lm9wZW4oXCJodHRwczovL21ldGFtYXNrLmlvL1wiKScpXHJcbiAgfTtcclxufVxyXG5cclxuICBjb25zdCB0ZXN0Q2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ1Rlc3QgY29uc29sZSBwcmludCcpXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcnVuT25Mb2FkID0gKGUpID0+IHtcclxuICAgIGNvbnN0IGNvbm5lY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29ubmVjdE1ldGFtYXNrJyk7XHJcbiAgICBpZiAodHlwZW9mIHdlYjMgPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICBjb25uZWN0QnV0dG9uLmlubmVyVGV4dCA9ICdDbGljayBoZXJlIHRvIGluc3RhbGwgTWV0YW1hc2sgRmlyc3QgYW5kIHRoZW4gcmVmcmVzaCB0aGlzIHBhZ2UuJztcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nvbm5lY3RNZXRhbWFzaycpLnNldEF0dHJpYnV0ZSgnb25DbGljaycsJ3dpbmRvdy5vcGVuKFwiaHR0cHM6Ly9tZXRhbWFzay5pby9cIiknKVxyXG4gICAgfSBlbHNlIHsgXHJcbiAgICAgIHdlYjMuZXRoLmdldEFjY291bnRzKGZ1bmN0aW9uKGVyciwgYWNjb3VudHMpe1xyXG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkgY29uc29sZS5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkOiBcIitlcnIpO1xyXG4gICAgICAgIGVsc2UgaWYgKGFjY291bnRzLmxlbmd0aCA9PSAwKSBjb25zb2xlLmxvZyhcIlVzZXIgaXMgbm90IGxvZ2dlZCBpbiB0byBNZXRhTWFza1wiKTtcclxuICAgICAgICBlbHNlIGNvbm5lY3RCdXR0b24uaW5uZXJUZXh0ID0gJ0Nvbm5lY3RlZCc7O1xyXG4gICAgfSk7XHJcbiAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBydW5PbkxvYWQoKTtcclxuICB9LCBbXSlcclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgIDxib2R5PiAgXHJcbiAgICA8ZGl2PlxyXG4gICAgICBNaW50IFBhZ2V7XCIgXCJ9XHJcbiAgICAgIDxidXR0b24gaWQ9J2Nvbm5lY3RNZXRhbWFzaycgdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eyhlKSA9PiBvbkNsaWNrQ29ubmVjdCgpfT5Db25uZWN0IE1ldGFtYXNrPC9idXR0b24+XHJcbiAgICA8L2Rpdj4gICAgXHJcbiAgICAgIDxoNSBjbGFzc05hbWU9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgPExpbmsgaHJlZj1cIi9cIj48YT5CYWNrIHRvIG1haW4gcGFnZS48L2E+PC9MaW5rPlxyXG4gICAgICA8L2g1PlxyXG4gICAgPC9ib2R5PlxyXG4gICAgPC8+XHJcbiAgKTtcclxufSJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsIkxpbmsiLCJjcmVhdGVBbGNoZW15V2ViMyIsInJlcXVpcmUiLCJ3ZWIzIiwiTWludFBhZ2UiLCJvbkNsaWNrQ29ubmVjdCIsImNvbm5lY3RCdXR0b24iLCJtZXNzYWdlX2NvZGUiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiaW5uZXJUZXh0IiwiZXRoZXJldW0iLCJyZXF1ZXN0IiwibWV0aG9kIiwiZGlzYWJsZWQiLCJjb25zb2xlIiwibG9nIiwic2V0QXR0cmlidXRlIiwidGVzdENsaWNrIiwiZSIsInJ1bk9uTG9hZCIsImV0aCIsImdldEFjY291bnRzIiwiZXJyIiwiYWNjb3VudHMiLCJlcnJvciIsImxlbmd0aCIsImJvZHkiLCJkaXYiLCJidXR0b24iLCJpZCIsInR5cGUiLCJvbkNsaWNrIiwiaDUiLCJjbGFzc05hbWUiLCJocmVmIiwiYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/mint.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AssetTransfersCategory\": function() { return /* binding */ AssetTransfersCategory; },\n/* harmony export */   \"AssetTransfersOrder\": function() { return /* binding */ AssetTransfersOrder; },\n/* harmony export */   \"createAlchemyWeb3\": function() { return /* binding */ createAlchemyWeb3; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var web3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web3 */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3/lib/index.js\");\n/* harmony import */ var web3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var web3_core_subscriptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! web3-core-subscriptions */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js\");\n/* harmony import */ var web3_core_subscriptions__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(web3_core_subscriptions__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var web3_eth_abi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web3-eth-abi */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-abi/lib/index.js\");\n/* harmony import */ var web3_eth_abi__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(web3_eth_abi__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\n/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _util_hex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/hex */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/hex.js\");\n/* harmony import */ var _util_promises__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util/promises */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js\");\n/* harmony import */ var _web3_adapter_alchemyContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./web3-adapter/alchemyContext */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemyContext.js\");\n/* harmony import */ var _web3_adapter_customRPC__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./web3-adapter/customRPC */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/customRPC.js\");\n/* harmony import */ var _web3_adapter_eth_feeHistory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./web3-adapter/eth_feeHistory */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_feeHistory.js\");\n/* harmony import */ var _web3_adapter_eth_maxPriorityFeePerGas__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./web3-adapter/eth_maxPriorityFeePerGas */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_maxPriorityFeePerGas.js\");\n\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_MAX_RETRIES = 3;\nvar DEFAULT_RETRY_INTERVAL = 1000;\nvar DEFAULT_RETRY_JITTER = 250;\nvar AssetTransfersCategory;\n(function (AssetTransfersCategory) {\n    AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n    AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n    AssetTransfersCategory[\"TOKEN\"] = \"token\";\n    AssetTransfersCategory[\"ERC20\"] = \"erc20\";\n    AssetTransfersCategory[\"ERC721\"] = \"erc721\";\n    AssetTransfersCategory[\"ERC1155\"] = \"erc1155\";\n})(AssetTransfersCategory || (AssetTransfersCategory = {}));\nvar AssetTransfersOrder;\n(function (AssetTransfersOrder) {\n    AssetTransfersOrder[\"ASCENDING\"] = \"asc\";\n    AssetTransfersOrder[\"DESCENDING\"] = \"desc\";\n})(AssetTransfersOrder || (AssetTransfersOrder = {}));\nfunction createAlchemyWeb3(alchemyUrl, config) {\n    var fullConfig = fillInConfigDefaults(config);\n    var _a = (0,_web3_adapter_alchemyContext__WEBPACK_IMPORTED_MODULE_4__.makeAlchemyContext)(alchemyUrl, fullConfig), provider = _a.provider, senders = _a.senders, setWriteProvider = _a.setWriteProvider;\n    var alchemyWeb3 = new (web3__WEBPACK_IMPORTED_MODULE_0___default())(provider);\n    alchemyWeb3.setProvider = function () {\n        throw new Error(\"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\");\n    };\n    alchemyWeb3.setWriteProvider = setWriteProvider;\n    alchemyWeb3.alchemy = {\n        getTokenAllowance: function (params, callback) {\n            return callAlchemyMethod({\n                senders: senders,\n                callback: callback,\n                method: \"alchemy_getTokenAllowance\",\n                params: [params],\n            });\n        },\n        getTokenBalances: function (address, contractAddresses, callback) {\n            return callAlchemyMethod({\n                senders: senders,\n                callback: callback,\n                method: \"alchemy_getTokenBalances\",\n                params: [address, contractAddresses],\n                processResponse: processTokenBalanceResponse,\n            });\n        },\n        getTokenMetadata: function (address, callback) {\n            return callAlchemyMethod({\n                senders: senders,\n                callback: callback,\n                params: [address],\n                method: \"alchemy_getTokenMetadata\",\n            });\n        },\n        getAssetTransfers: function (params, callback) {\n            return callAlchemyMethod({\n                senders: senders,\n                callback: callback,\n                params: [\n                    (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({}, params), { fromBlock: params.fromBlock != null\n                            ? (0,_util_hex__WEBPACK_IMPORTED_MODULE_6__.formatBlock)(params.fromBlock)\n                            : undefined, toBlock: params.toBlock != null ? (0,_util_hex__WEBPACK_IMPORTED_MODULE_6__.formatBlock)(params.toBlock) : undefined, maxCount: params.maxCount != null ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_3__.toHex)(params.maxCount) : undefined }),\n                ],\n                method: \"alchemy_getAssetTransfers\",\n            });\n        },\n        getNftMetadata: function (params, callback) {\n            return callAlchemyMethod({\n                senders: senders,\n                callback: callback,\n                params: [(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({}, params)],\n                method: \"alchemy_getNftMetadata\",\n            });\n        },\n    };\n    patchSubscriptions(alchemyWeb3);\n    (0,_web3_adapter_customRPC__WEBPACK_IMPORTED_MODULE_7__.patchEnableCustomRPC)(alchemyWeb3);\n    (0,_web3_adapter_eth_feeHistory__WEBPACK_IMPORTED_MODULE_8__.patchEthFeeHistoryMethod)(alchemyWeb3);\n    (0,_web3_adapter_eth_maxPriorityFeePerGas__WEBPACK_IMPORTED_MODULE_9__.patchEthMaxPriorityFeePerGasMethod)(alchemyWeb3);\n    return alchemyWeb3;\n}\nfunction fillInConfigDefaults(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.writeProvider, writeProvider = _c === void 0 ? getWindowProvider() : _c, _d = _b.maxRetries, maxRetries = _d === void 0 ? DEFAULT_MAX_RETRIES : _d, _e = _b.retryInterval, retryInterval = _e === void 0 ? DEFAULT_RETRY_INTERVAL : _e, _f = _b.retryJitter, retryJitter = _f === void 0 ? DEFAULT_RETRY_JITTER : _f;\n    return { writeProvider: writeProvider, maxRetries: maxRetries, retryInterval: retryInterval, retryJitter: retryJitter };\n}\nfunction getWindowProvider() {\n    return typeof window !== \"undefined\" ? window.ethereum : null;\n}\nfunction callAlchemyMethod(_a) {\n    var _this = this;\n    var senders = _a.senders, method = _a.method, params = _a.params, _b = _a.callback, callback = _b === void 0 ? noop : _b, _c = _a.processResponse, processResponse = _c === void 0 ? identity : _c;\n    var promise = (function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__awaiter)(_this, void 0, void 0, function () {\n        var result;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__generator)(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, senders.send(method, params)];\n                case 1:\n                    result = _a.sent();\n                    return [2 /*return*/, processResponse(result)];\n            }\n        });\n    }); })();\n    (0,_util_promises__WEBPACK_IMPORTED_MODULE_10__.callWhenDone)(promise, callback);\n    return promise;\n}\nfunction processTokenBalanceResponse(rawResponse) {\n    // Convert token balance fields from hex-string to decimal-string.\n    var fixedTokenBalances = rawResponse.tokenBalances.map(function (balance) {\n        return balance.tokenBalance != null\n            ? (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({}, balance), { tokenBalance: (0,web3_eth_abi__WEBPACK_IMPORTED_MODULE_2__.decodeParameter)(\"uint256\", balance.tokenBalance) }) : balance;\n    });\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({}, rawResponse), { tokenBalances: fixedTokenBalances });\n}\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions.\n */\nfunction patchSubscriptions(web3) {\n    var eth = web3.eth;\n    var oldSubscribe = eth.subscribe.bind(eth);\n    eth.subscribe = (function (type) {\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        if (type === \"alchemy_fullPendingTransactions\" ||\n            type === \"alchemy_newFullPendingTransactions\") {\n            return suppressNoSubscriptionExistsWarning(function () {\n                return oldSubscribe.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__spreadArray)([\"alchemy_newFullPendingTransactions\"], (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__read)(rest)));\n            });\n        }\n        if (type === \"alchemy_filteredNewFullPendingTransactions\" ||\n            type === \"alchemy_filteredPendingTransactions\" ||\n            type === \"alchemy_filteredFullPendingTransactions\") {\n            return suppressNoSubscriptionExistsWarning(function () {\n                return oldSubscribe.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__spreadArray)([\"alchemy_filteredNewFullPendingTransactions\"], (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__read)(rest)));\n            });\n        }\n        return oldSubscribe.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__spreadArray)([type], (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__read)(rest)));\n    });\n}\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\nfunction suppressNoSubscriptionExistsWarning(f) {\n    var oldConsoleWarn = console.warn;\n    console.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (typeof args[0] === \"string\" &&\n            args[0].includes(\" doesn't exist. Subscribing anyway.\")) {\n            return;\n        }\n        return oldConsoleWarn.apply(console, args);\n    };\n    try {\n        return f();\n    }\n    finally {\n        console.warn = oldConsoleWarn;\n    }\n}\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\nvar subscription = (web3_core_subscriptions__WEBPACK_IMPORTED_MODULE_1___default().subscription);\nvar oldSubscriptionPrototypeValidateArgs = subscription.prototype._validateArgs;\nsubscription.prototype._validateArgs = function (args) {\n    if ([\n        \"alchemy_filteredNewFullPendingTransactions\",\n        \"alchemy_filteredPendingTransactions\",\n        \"alchemy_filteredFullPendingTransactions\",\n    ].includes(this.subscriptionMethod)) {\n        // This particular subscription type is allowed to have additional parameters\n    }\n    else {\n        if ([\n            \"alchemy_fullPendingTransactions\",\n            \"alchemy_newFullPendingTransactions\",\n        ].includes(this.subscriptionMethod)) {\n            if (this.options.subscription) {\n                this.options.subscription.subscriptionName = this.subscriptionMethod;\n            }\n        }\n        var validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n        validator(args);\n    }\n};\nfunction noop() {\n    // Nothing.\n}\nfunction identity(x) {\n    return x;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Y7QUFDeEQ7QUFDb0M7QUFDYjtBQUNaO0FBQ007QUFDTTtBQUNvQjtBQUNIO0FBQ1M7QUFDb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0RBQXdEO0FBQ2xEO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDNUM7QUFDUDtBQUNBLGFBQWEsZ0ZBQWtCO0FBQy9CLDBCQUEwQiw2Q0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxhQUFhO0FBQ3JELDhCQUE4QixzREFBVztBQUN6QywyRUFBMkUsc0RBQVcsa0VBQWtFLGlEQUFLLCtCQUErQjtBQUM1TDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQ0FBUSxHQUFHO0FBQ3BDO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSSw2RUFBb0I7QUFDeEIsSUFBSSxzRkFBd0I7QUFDNUIsSUFBSSwwR0FBa0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLGdEQUFTO0FBQ2pEO0FBQ0EsZUFBZSxrREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSyxJQUFJO0FBQ1QsSUFBSSw2REFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxjQUFjLGNBQWMsNkRBQWUsbUNBQW1DO0FBQ2hILEtBQUs7QUFDTCxXQUFXLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxrQkFBa0IsbUNBQW1DO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9EQUFhLHlDQUF5Qyw2Q0FBTTtBQUM5RyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvREFBYSxpREFBaUQsNkNBQU07QUFDdEgsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLG9EQUFhLFNBQVMsNkNBQU07QUFDdEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkVBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvZGlzdC9lc20vaW5kZXguanM/NjI5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19hd2FpdGVyLCBfX2dlbmVyYXRvciwgX19yZWFkLCBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgV2ViMyBmcm9tIFwid2ViM1wiO1xuaW1wb3J0IHdlYjNDb3JlU3Vic2NyaXB0aW9ucyBmcm9tIFwid2ViMy1jb3JlLXN1YnNjcmlwdGlvbnNcIjtcbmltcG9ydCB7IGRlY29kZVBhcmFtZXRlciB9IGZyb20gXCJ3ZWIzLWV0aC1hYmlcIjtcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSBcIndlYjMtdXRpbHNcIjtcbmltcG9ydCB7IGZvcm1hdEJsb2NrIH0gZnJvbSBcIi4vdXRpbC9oZXhcIjtcbmltcG9ydCB7IGNhbGxXaGVuRG9uZSB9IGZyb20gXCIuL3V0aWwvcHJvbWlzZXNcIjtcbmltcG9ydCB7IG1ha2VBbGNoZW15Q29udGV4dCB9IGZyb20gXCIuL3dlYjMtYWRhcHRlci9hbGNoZW15Q29udGV4dFwiO1xuaW1wb3J0IHsgcGF0Y2hFbmFibGVDdXN0b21SUEMgfSBmcm9tIFwiLi93ZWIzLWFkYXB0ZXIvY3VzdG9tUlBDXCI7XG5pbXBvcnQgeyBwYXRjaEV0aEZlZUhpc3RvcnlNZXRob2QgfSBmcm9tIFwiLi93ZWIzLWFkYXB0ZXIvZXRoX2ZlZUhpc3RvcnlcIjtcbmltcG9ydCB7IHBhdGNoRXRoTWF4UHJpb3JpdHlGZWVQZXJHYXNNZXRob2QgfSBmcm9tIFwiLi93ZWIzLWFkYXB0ZXIvZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCI7XG52YXIgREVGQVVMVF9NQVhfUkVUUklFUyA9IDM7XG52YXIgREVGQVVMVF9SRVRSWV9JTlRFUlZBTCA9IDEwMDA7XG52YXIgREVGQVVMVF9SRVRSWV9KSVRURVIgPSAyNTA7XG5leHBvcnQgdmFyIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkpIHtcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiRVhURVJOQUxcIl0gPSBcImV4dGVybmFsXCI7XG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIklOVEVSTkFMXCJdID0gXCJpbnRlcm5hbFwiO1xuICAgIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnlbXCJUT0tFTlwiXSA9IFwidG9rZW5cIjtcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiRVJDMjBcIl0gPSBcImVyYzIwXCI7XG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIkVSQzcyMVwiXSA9IFwiZXJjNzIxXCI7XG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIkVSQzExNTVcIl0gPSBcImVyYzExNTVcIjtcbn0pKEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkgfHwgKEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkgPSB7fSkpO1xuZXhwb3J0IHZhciBBc3NldFRyYW5zZmVyc09yZGVyO1xuKGZ1bmN0aW9uIChBc3NldFRyYW5zZmVyc09yZGVyKSB7XG4gICAgQXNzZXRUcmFuc2ZlcnNPcmRlcltcIkFTQ0VORElOR1wiXSA9IFwiYXNjXCI7XG4gICAgQXNzZXRUcmFuc2ZlcnNPcmRlcltcIkRFU0NFTkRJTkdcIl0gPSBcImRlc2NcIjtcbn0pKEFzc2V0VHJhbnNmZXJzT3JkZXIgfHwgKEFzc2V0VHJhbnNmZXJzT3JkZXIgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFsY2hlbXlXZWIzKGFsY2hlbXlVcmwsIGNvbmZpZykge1xuICAgIHZhciBmdWxsQ29uZmlnID0gZmlsbEluQ29uZmlnRGVmYXVsdHMoY29uZmlnKTtcbiAgICB2YXIgX2EgPSBtYWtlQWxjaGVteUNvbnRleHQoYWxjaGVteVVybCwgZnVsbENvbmZpZyksIHByb3ZpZGVyID0gX2EucHJvdmlkZXIsIHNlbmRlcnMgPSBfYS5zZW5kZXJzLCBzZXRXcml0ZVByb3ZpZGVyID0gX2Euc2V0V3JpdGVQcm92aWRlcjtcbiAgICB2YXIgYWxjaGVteVdlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XG4gICAgYWxjaGVteVdlYjMuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gQWxjaGVteSBXZWIzLiBUbyBjaGFuZ2UgdGhlIHByb3ZpZGVyIHVzZWQgZm9yIHdyaXRlcywgdXNlIHNldFdyaXRlUHJvdmlkZXIoKSBpbnN0ZWFkLlwiKTtcbiAgICB9O1xuICAgIGFsY2hlbXlXZWIzLnNldFdyaXRlUHJvdmlkZXIgPSBzZXRXcml0ZVByb3ZpZGVyO1xuICAgIGFsY2hlbXlXZWIzLmFsY2hlbXkgPSB7XG4gICAgICAgIGdldFRva2VuQWxsb3dhbmNlOiBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxBbGNoZW15TWV0aG9kKHtcbiAgICAgICAgICAgICAgICBzZW5kZXJzOiBzZW5kZXJzLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiYWxjaGVteV9nZXRUb2tlbkFsbG93YW5jZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3BhcmFtc10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VG9rZW5CYWxhbmNlczogZnVuY3Rpb24gKGFkZHJlc3MsIGNvbnRyYWN0QWRkcmVzc2VzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxBbGNoZW15TWV0aG9kKHtcbiAgICAgICAgICAgICAgICBzZW5kZXJzOiBzZW5kZXJzLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiYWxjaGVteV9nZXRUb2tlbkJhbGFuY2VzXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbYWRkcmVzcywgY29udHJhY3RBZGRyZXNzZXNdLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NSZXNwb25zZTogcHJvY2Vzc1Rva2VuQmFsYW5jZVJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRva2VuTWV0YWRhdGE6IGZ1bmN0aW9uIChhZGRyZXNzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxBbGNoZW15TWV0aG9kKHtcbiAgICAgICAgICAgICAgICBzZW5kZXJzOiBzZW5kZXJzLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFthZGRyZXNzXSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiYWxjaGVteV9nZXRUb2tlbk1ldGFkYXRhXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QXNzZXRUcmFuc2ZlcnM6IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbEFsY2hlbXlNZXRob2Qoe1xuICAgICAgICAgICAgICAgIHNlbmRlcnM6IHNlbmRlcnMsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwgeyBmcm9tQmxvY2s6IHBhcmFtcy5mcm9tQmxvY2sgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZm9ybWF0QmxvY2socGFyYW1zLmZyb21CbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgdG9CbG9jazogcGFyYW1zLnRvQmxvY2sgIT0gbnVsbCA/IGZvcm1hdEJsb2NrKHBhcmFtcy50b0Jsb2NrKSA6IHVuZGVmaW5lZCwgbWF4Q291bnQ6IHBhcmFtcy5tYXhDb3VudCAhPSBudWxsID8gdG9IZXgocGFyYW1zLm1heENvdW50KSA6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJhbGNoZW15X2dldEFzc2V0VHJhbnNmZXJzXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TmZ0TWV0YWRhdGE6IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbEFsY2hlbXlNZXRob2Qoe1xuICAgICAgICAgICAgICAgIHNlbmRlcnM6IHNlbmRlcnMsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW19fYXNzaWduKHt9LCBwYXJhbXMpXSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiYWxjaGVteV9nZXROZnRNZXRhZGF0YVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBwYXRjaFN1YnNjcmlwdGlvbnMoYWxjaGVteVdlYjMpO1xuICAgIHBhdGNoRW5hYmxlQ3VzdG9tUlBDKGFsY2hlbXlXZWIzKTtcbiAgICBwYXRjaEV0aEZlZUhpc3RvcnlNZXRob2QoYWxjaGVteVdlYjMpO1xuICAgIHBhdGNoRXRoTWF4UHJpb3JpdHlGZWVQZXJHYXNNZXRob2QoYWxjaGVteVdlYjMpO1xuICAgIHJldHVybiBhbGNoZW15V2ViMztcbn1cbmZ1bmN0aW9uIGZpbGxJbkNvbmZpZ0RlZmF1bHRzKF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2Iud3JpdGVQcm92aWRlciwgd3JpdGVQcm92aWRlciA9IF9jID09PSB2b2lkIDAgPyBnZXRXaW5kb3dQcm92aWRlcigpIDogX2MsIF9kID0gX2IubWF4UmV0cmllcywgbWF4UmV0cmllcyA9IF9kID09PSB2b2lkIDAgPyBERUZBVUxUX01BWF9SRVRSSUVTIDogX2QsIF9lID0gX2IucmV0cnlJbnRlcnZhbCwgcmV0cnlJbnRlcnZhbCA9IF9lID09PSB2b2lkIDAgPyBERUZBVUxUX1JFVFJZX0lOVEVSVkFMIDogX2UsIF9mID0gX2IucmV0cnlKaXR0ZXIsIHJldHJ5Sml0dGVyID0gX2YgPT09IHZvaWQgMCA/IERFRkFVTFRfUkVUUllfSklUVEVSIDogX2Y7XG4gICAgcmV0dXJuIHsgd3JpdGVQcm92aWRlcjogd3JpdGVQcm92aWRlciwgbWF4UmV0cmllczogbWF4UmV0cmllcywgcmV0cnlJbnRlcnZhbDogcmV0cnlJbnRlcnZhbCwgcmV0cnlKaXR0ZXI6IHJldHJ5Sml0dGVyIH07XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dQcm92aWRlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5ldGhlcmV1bSA6IG51bGw7XG59XG5mdW5jdGlvbiBjYWxsQWxjaGVteU1ldGhvZChfYSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHNlbmRlcnMgPSBfYS5zZW5kZXJzLCBtZXRob2QgPSBfYS5tZXRob2QsIHBhcmFtcyA9IF9hLnBhcmFtcywgX2IgPSBfYS5jYWxsYmFjaywgY2FsbGJhY2sgPSBfYiA9PT0gdm9pZCAwID8gbm9vcCA6IF9iLCBfYyA9IF9hLnByb2Nlc3NSZXNwb25zZSwgcHJvY2Vzc1Jlc3BvbnNlID0gX2MgPT09IHZvaWQgMCA/IGlkZW50aXR5IDogX2M7XG4gICAgdmFyIHByb21pc2UgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBzZW5kZXJzLnNlbmQobWV0aG9kLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb2Nlc3NSZXNwb25zZShyZXN1bHQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH0pKCk7XG4gICAgY2FsbFdoZW5Eb25lKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NUb2tlbkJhbGFuY2VSZXNwb25zZShyYXdSZXNwb25zZSkge1xuICAgIC8vIENvbnZlcnQgdG9rZW4gYmFsYW5jZSBmaWVsZHMgZnJvbSBoZXgtc3RyaW5nIHRvIGRlY2ltYWwtc3RyaW5nLlxuICAgIHZhciBmaXhlZFRva2VuQmFsYW5jZXMgPSByYXdSZXNwb25zZS50b2tlbkJhbGFuY2VzLm1hcChmdW5jdGlvbiAoYmFsYW5jZSkge1xuICAgICAgICByZXR1cm4gYmFsYW5jZS50b2tlbkJhbGFuY2UgIT0gbnVsbFxuICAgICAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYmFsYW5jZSksIHsgdG9rZW5CYWxhbmNlOiBkZWNvZGVQYXJhbWV0ZXIoXCJ1aW50MjU2XCIsIGJhbGFuY2UudG9rZW5CYWxhbmNlKSB9KSA6IGJhbGFuY2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCByYXdSZXNwb25zZSksIHsgdG9rZW5CYWxhbmNlczogZml4ZWRUb2tlbkJhbGFuY2VzIH0pO1xufVxuLyoqXG4gKiBVcGRhdGVzIFdlYjMncyBpbnRlcm5hbCBzdWJzY3JpcHRpb24gYXJjaGl0ZWN0dXJlIHRvIGFsc28gaGFuZGxlIEFsY2hlbXlcbiAqIHNwZWNpZmljIHN1YnNjcmlwdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHBhdGNoU3Vic2NyaXB0aW9ucyh3ZWIzKSB7XG4gICAgdmFyIGV0aCA9IHdlYjMuZXRoO1xuICAgIHZhciBvbGRTdWJzY3JpYmUgPSBldGguc3Vic2NyaWJlLmJpbmQoZXRoKTtcbiAgICBldGguc3Vic2NyaWJlID0gKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciByZXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICByZXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcImFsY2hlbXlfZnVsbFBlbmRpbmdUcmFuc2FjdGlvbnNcIiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gXCJhbGNoZW15X25ld0Z1bGxQZW5kaW5nVHJhbnNhY3Rpb25zXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBwcmVzc05vU3Vic2NyaXB0aW9uRXhpc3RzV2FybmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFN1YnNjcmliZS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW1wiYWxjaGVteV9uZXdGdWxsUGVuZGluZ1RyYW5zYWN0aW9uc1wiXSwgX19yZWFkKHJlc3QpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJhbGNoZW15X2ZpbHRlcmVkTmV3RnVsbFBlbmRpbmdUcmFuc2FjdGlvbnNcIiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gXCJhbGNoZW15X2ZpbHRlcmVkUGVuZGluZ1RyYW5zYWN0aW9uc1wiIHx8XG4gICAgICAgICAgICB0eXBlID09PSBcImFsY2hlbXlfZmlsdGVyZWRGdWxsUGVuZGluZ1RyYW5zYWN0aW9uc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwcHJlc3NOb1N1YnNjcmlwdGlvbkV4aXN0c1dhcm5pbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRTdWJzY3JpYmUuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtcImFsY2hlbXlfZmlsdGVyZWROZXdGdWxsUGVuZGluZ1RyYW5zYWN0aW9uc1wiXSwgX19yZWFkKHJlc3QpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkU3Vic2NyaWJlLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbdHlwZV0sIF9fcmVhZChyZXN0KSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBWRVJZIGhhY2t5IHdyYXBwZXIgdG8gc3VwcHJlc3MgYSBzcHVyaW91cyB3YXJuaW5nIHdoZW4gc3Vic2NyaWJpbmcgdG8gYW5cbiAqIEFsY2hlbXkgc3Vic2NyaXB0aW9uIHRoYXQgaXNuJ3QgYnVpbHQgaW50byBXZWIzLlxuICovXG5mdW5jdGlvbiBzdXBwcmVzc05vU3Vic2NyaXB0aW9uRXhpc3RzV2FybmluZyhmKSB7XG4gICAgdmFyIG9sZENvbnNvbGVXYXJuID0gY29uc29sZS53YXJuO1xuICAgIGNvbnNvbGUud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIGFyZ3NbMF0uaW5jbHVkZXMoXCIgZG9lc24ndCBleGlzdC4gU3Vic2NyaWJpbmcgYW55d2F5LlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGRDb25zb2xlV2Fybi5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjb25zb2xlLndhcm4gPSBvbGRDb25zb2xlV2FybjtcbiAgICB9XG59XG4vKipcbiAqIEFub3RoZXIgVkVSWSBoYWNreSBtb25rZXlwYXRjaCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBjYW4gdGFrZSBleHRyYSBwYXJhbWV0ZXJzIHRvIGNlcnRhaW4gYWxjaGVteSBzdWJzY3JpcHRpb25zXG4gKiBJIGhhdGUgZG9pbmcgdGhpcywgYnV0IHRoZSBvdGhlciBvcHRpb24gaXMgdG8gZm9yayB3ZWIzLWNvcmUgYW5kIEkgdGhpbmsgZm9yIG5vdyB0aGlzIGlzIGJldHRlclxuICovXG52YXIgc3Vic2NyaXB0aW9uID0gd2ViM0NvcmVTdWJzY3JpcHRpb25zLnN1YnNjcmlwdGlvbjtcbnZhciBvbGRTdWJzY3JpcHRpb25Qcm90b3R5cGVWYWxpZGF0ZUFyZ3MgPSBzdWJzY3JpcHRpb24ucHJvdG90eXBlLl92YWxpZGF0ZUFyZ3M7XG5zdWJzY3JpcHRpb24ucHJvdG90eXBlLl92YWxpZGF0ZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChbXG4gICAgICAgIFwiYWxjaGVteV9maWx0ZXJlZE5ld0Z1bGxQZW5kaW5nVHJhbnNhY3Rpb25zXCIsXG4gICAgICAgIFwiYWxjaGVteV9maWx0ZXJlZFBlbmRpbmdUcmFuc2FjdGlvbnNcIixcbiAgICAgICAgXCJhbGNoZW15X2ZpbHRlcmVkRnVsbFBlbmRpbmdUcmFuc2FjdGlvbnNcIixcbiAgICBdLmluY2x1ZGVzKHRoaXMuc3Vic2NyaXB0aW9uTWV0aG9kKSkge1xuICAgICAgICAvLyBUaGlzIHBhcnRpY3VsYXIgc3Vic2NyaXB0aW9uIHR5cGUgaXMgYWxsb3dlZCB0byBoYXZlIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKFtcbiAgICAgICAgICAgIFwiYWxjaGVteV9mdWxsUGVuZGluZ1RyYW5zYWN0aW9uc1wiLFxuICAgICAgICAgICAgXCJhbGNoZW15X25ld0Z1bGxQZW5kaW5nVHJhbnNhY3Rpb25zXCIsXG4gICAgICAgIF0uaW5jbHVkZXModGhpcy5zdWJzY3JpcHRpb25NZXRob2QpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uTmFtZSA9IHRoaXMuc3Vic2NyaXB0aW9uTWV0aG9kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSBvbGRTdWJzY3JpcHRpb25Qcm90b3R5cGVWYWxpZGF0ZUFyZ3MuYmluZCh0aGlzKTtcbiAgICAgICAgdmFsaWRhdG9yKGFyZ3MpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIE5vdGhpbmcuXG59XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/subscriptions/subscriptionBackfill.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/subscriptions/subscriptionBackfill.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeBackfiller\": function() { return /* binding */ makeBackfiller; },\n/* harmony export */   \"dedupeNewHeads\": function() { return /* binding */ dedupeNewHeads; },\n/* harmony export */   \"dedupeLogs\": function() { return /* binding */ dedupeLogs; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _util_hex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/hex */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/hex.js\");\n/* harmony import */ var _util_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/promises */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js\");\n\n\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\nvar MAX_BACKFILL_BLOCKS = 120;\nfunction makeBackfiller(senders) {\n    return { getNewHeadsBackfill: getNewHeadsBackfill, getLogsBackfill: getLogsBackfill };\n    function getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var toBlockNumber, lastSeenBlockNumber, minBlockNumber, reorgHeads, intermediateHeads;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        return [4 /*yield*/, getBlockNumber()];\n                    case 1:\n                        toBlockNumber = _a.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        if (previousHeads.length === 0) {\n                            return [2 /*return*/, getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n                        }\n                        lastSeenBlockNumber = (0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.fromHex)(previousHeads[previousHeads.length - 1].number);\n                        minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n                        if (lastSeenBlockNumber < minBlockNumber) {\n                            return [2 /*return*/, getHeadEventsInRange(minBlockNumber, toBlockNumber + 1)];\n                        }\n                        return [4 /*yield*/, getReorgHeads(isCancelled, previousHeads)];\n                    case 2:\n                        reorgHeads = _a.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        return [4 /*yield*/, getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1)];\n                    case 3:\n                        intermediateHeads = _a.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        return [2 /*return*/, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(reorgHeads)), (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(intermediateHeads))];\n                }\n            });\n        });\n    }\n    function getReorgHeads(isCancelled, previousHeads) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var result, i, oldEvent, blockHead;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        result = [];\n                        i = previousHeads.length - 1;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i >= 0)) return [3 /*break*/, 4];\n                        oldEvent = previousHeads[i];\n                        return [4 /*yield*/, getBlockByNumber((0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.fromHex)(oldEvent.number))];\n                    case 2:\n                        blockHead = _a.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        if (oldEvent.hash === blockHead.hash) {\n                            return [3 /*break*/, 4];\n                        }\n                        result.push(toNewHeadsEvent(blockHead));\n                        _a.label = 3;\n                    case 3:\n                        i--;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/, result.reverse()];\n                }\n            });\n        });\n    }\n    function getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var batchParts, i, heads;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (fromBlockInclusive >= toBlockExclusive) {\n                            return [2 /*return*/, []];\n                        }\n                        batchParts = [];\n                        for (i = fromBlockInclusive; i < toBlockExclusive; i++) {\n                            batchParts.push({\n                                method: \"eth_getBlockByNumber\",\n                                params: [(0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.toHex)(i), false],\n                            });\n                        }\n                        return [4 /*yield*/, senders.sendBatch(batchParts)];\n                    case 1:\n                        heads = _a.sent();\n                        return [2 /*return*/, heads.map(toNewHeadsEvent)];\n                }\n            });\n        });\n    }\n    function getBlockByNumber(blockNumber) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                return [2 /*return*/, senders.send(\"eth_getBlockByNumber\", [(0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.toHex)(blockNumber), false])];\n            });\n        });\n    }\n    function getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var toBlockNumber, lastSeenBlockNumber, minBlockNumber, commonAncestorNumber, removedLogs, addedLogs;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        return [4 /*yield*/, getBlockNumber()];\n                    case 1:\n                        toBlockNumber = _a.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        if (previousLogs.length === 0) {\n                            return [2 /*return*/, getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n                        }\n                        lastSeenBlockNumber = (0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.fromHex)(previousLogs[previousLogs.length - 1].blockNumber);\n                        minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n                        if (lastSeenBlockNumber < minBlockNumber) {\n                            return [2 /*return*/, getLogsInRange(filter, minBlockNumber, toBlockNumber + 1)];\n                        }\n                        return [4 /*yield*/, getCommonAncestorNumber(isCancelled, previousLogs)];\n                    case 2:\n                        commonAncestorNumber = _a.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        removedLogs = previousLogs\n                            .filter(function (log) { return (0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.fromHex)(log.blockNumber) > commonAncestorNumber; })\n                            .map(function (log) { return ((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, log), { removed: true })); });\n                        return [4 /*yield*/, getLogsInRange(filter, commonAncestorNumber + 1, toBlockNumber + 1)];\n                    case 3:\n                        addedLogs = _a.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        return [2 /*return*/, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(removedLogs)), (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(addedLogs))];\n                }\n            });\n        });\n    }\n    function getCommonAncestorNumber(isCancelled, previousLogs) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var i, _a, blockHash, blockNumber, hash;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        i = previousLogs.length - 1;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i >= 0)) return [3 /*break*/, 4];\n                        _a = previousLogs[i], blockHash = _a.blockHash, blockNumber = _a.blockNumber;\n                        return [4 /*yield*/, getBlockByNumber((0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.fromHex)(blockNumber))];\n                    case 2:\n                        hash = (_b.sent()).hash;\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.throwIfCancelled)(isCancelled);\n                        if (blockHash === hash) {\n                            return [2 /*return*/, (0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.fromHex)(blockNumber)];\n                        }\n                        _b.label = 3;\n                    case 3:\n                        i--;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/, Number.NEGATIVE_INFINITY];\n                }\n            });\n        });\n    }\n    function getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var rangeFilter;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                if (fromBlockInclusive >= toBlockExclusive) {\n                    return [2 /*return*/, []];\n                }\n                rangeFilter = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, filter), { fromBlock: (0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.toHex)(fromBlockInclusive), toBlock: (0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.toHex)(toBlockExclusive - 1) });\n                return [2 /*return*/, senders.send(\"eth_getLogs\", [rangeFilter])];\n            });\n        });\n    }\n    function getBlockNumber() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var blockNumberHex;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, senders.send(\"eth_blockNumber\")];\n                    case 1:\n                        blockNumberHex = _a.sent();\n                        return [2 /*return*/, (0,_util_hex__WEBPACK_IMPORTED_MODULE_2__.fromHex)(blockNumberHex)];\n                }\n            });\n        });\n    }\n}\nfunction toNewHeadsEvent(head) {\n    var result = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, head);\n    delete result.totalDifficulty;\n    delete result.transactions;\n    delete result.uncles;\n    return result;\n}\nfunction dedupeNewHeads(events) {\n    return dedupe(events, function (event) { return event.hash; });\n}\nfunction dedupeLogs(events) {\n    return dedupe(events, function (event) { return event.blockHash + \"/\" + event.logIndex; });\n}\nfunction dedupe(items, getKey) {\n    var keysSeen = new Set();\n    var result = [];\n    items.forEach(function (item) {\n        var key = getKey(item);\n        if (!keysSeen.has(key)) {\n            keysSeen.add(key);\n            result.push(item);\n        }\n    });\n    return result;\n}\n//# sourceMappingURL=subscriptionBackfill.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS9zdWJzY3JpcHRpb25zL3N1YnNjcmlwdGlvbkJhY2tmaWxsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFnRjtBQUNuQztBQUNPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxhQUFhO0FBQ2I7QUFDQSxlQUFlLGdEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtEQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWdCO0FBQ3hDLDhDQUE4QyxvREFBYSxDQUFDLG9EQUFhLEtBQUssNkNBQU0sZUFBZSw2Q0FBTTtBQUN6RztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsZ0RBQVM7QUFDeEI7QUFDQSxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxrREFBTztBQUNyRTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsZ0RBQVM7QUFDeEI7QUFDQSxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0EseUNBQXlDLGdEQUFLO0FBQzlDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLGdEQUFTO0FBQ3hCLG1CQUFtQixrREFBVztBQUM5Qiw0RUFBNEUsZ0RBQUs7QUFDakYsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxnREFBUztBQUN4QjtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrREFBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBZ0I7QUFDeEM7QUFDQSxxREFBcUQsT0FBTyxrREFBTywyQ0FBMkM7QUFDOUcsa0RBQWtELFFBQVEsK0NBQVEsQ0FBQywrQ0FBUSxHQUFHLFVBQVUsZUFBZSxLQUFLO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBZ0I7QUFDeEMsOENBQThDLG9EQUFhLENBQUMsb0RBQWEsS0FBSyw2Q0FBTSxnQkFBZ0IsNkNBQU07QUFDMUc7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLGdEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGtEQUFPO0FBQ3JFO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWdCO0FBQ3hDO0FBQ0Esa0RBQWtELGtEQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxnREFBUztBQUN4QjtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQVEsQ0FBQywrQ0FBUSxHQUFHLGFBQWEsV0FBVyxnREFBSywrQkFBK0IsZ0RBQUssd0JBQXdCO0FBQzNJO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxnREFBUztBQUN4QjtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrREFBTztBQUNyRDtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFRLEdBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDLG9CQUFvQjtBQUNqRTtBQUNPO0FBQ1AsNkNBQTZDLGdEQUFnRDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvZGlzdC9lc20vc3Vic2NyaXB0aW9ucy9zdWJzY3JpcHRpb25CYWNrZmlsbC5qcz8yMmFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yLCBfX3JlYWQsIF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGZyb21IZXgsIHRvSGV4IH0gZnJvbSBcIi4uL3V0aWwvaGV4XCI7XG5pbXBvcnQgeyB0aHJvd0lmQ2FuY2VsbGVkIH0gZnJvbSBcIi4uL3V0aWwvcHJvbWlzZXNcIjtcbi8qKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJsb2NrcyB0byBiYWNrZmlsbC4gSWYgbW9yZSB0aGFuIHRoaXMgbWFueSBibG9ja3MgaGF2ZVxuICogYmVlbiBtaXNzZWQsIHRoZW4gd2UnbGwgc2FkbHkgbWlzcyBkYXRhLCBidXQgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgZG9uJ3RcbiAqIGVuZCB1cCByZXF1ZXN0aW5nIHRob3VzYW5kcyBvZiBibG9ja3MgaWYgc29tZWJvZHkgbGVmdCB0aGVpciBsYXB0b3AgY2xvc2VkXG4gKiBmb3IgYSB3ZWVrLlxuICovXG52YXIgTUFYX0JBQ0tGSUxMX0JMT0NLUyA9IDEyMDtcbmV4cG9ydCBmdW5jdGlvbiBtYWtlQmFja2ZpbGxlcihzZW5kZXJzKSB7XG4gICAgcmV0dXJuIHsgZ2V0TmV3SGVhZHNCYWNrZmlsbDogZ2V0TmV3SGVhZHNCYWNrZmlsbCwgZ2V0TG9nc0JhY2tmaWxsOiBnZXRMb2dzQmFja2ZpbGwgfTtcbiAgICBmdW5jdGlvbiBnZXROZXdIZWFkc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzLCBmcm9tQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvQmxvY2tOdW1iZXIsIGxhc3RTZWVuQmxvY2tOdW1iZXIsIG1pbkJsb2NrTnVtYmVyLCByZW9yZ0hlYWRzLCBpbnRlcm1lZGlhdGVIZWFkcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0QmxvY2tOdW1iZXIoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0hlYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXRIZWFkRXZlbnRzSW5SYW5nZShNYXRoLm1heChmcm9tQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgLSBNQVhfQkFDS0ZJTExfQkxPQ0tTKSArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VlbkJsb2NrTnVtYmVyID0gZnJvbUhleChwcmV2aW91c0hlYWRzW3ByZXZpb3VzSGVhZHMubGVuZ3RoIC0gMV0ubnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkJsb2NrTnVtYmVyID0gTWF0aC5tYXgoMCwgbGFzdFNlZW5CbG9ja051bWJlciAtIE1BWF9CQUNLRklMTF9CTE9DS1MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTZWVuQmxvY2tOdW1iZXIgPCBtaW5CbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXRIZWFkRXZlbnRzSW5SYW5nZShtaW5CbG9ja051bWJlciwgdG9CbG9ja051bWJlciArIDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVvcmdIZWFkcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0SGVhZEV2ZW50c0luUmFuZ2UobGFzdFNlZW5CbG9ja051bWJlciArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUhlYWRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocmVvcmdIZWFkcykpLCBfX3JlYWQoaW50ZXJtZWRpYXRlSGVhZHMpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZW9yZ0hlYWRzKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIG9sZEV2ZW50LCBibG9ja0hlYWQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwcmV2aW91c0hlYWRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPj0gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQgPSBwcmV2aW91c0hlYWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0QmxvY2tCeU51bWJlcihmcm9tSGV4KG9sZEV2ZW50Lm51bWJlcikpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tIZWFkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkRXZlbnQuaGFzaCA9PT0gYmxvY2tIZWFkLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvTmV3SGVhZHNFdmVudChibG9ja0hlYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5yZXZlcnNlKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SGVhZEV2ZW50c0luUmFuZ2UoZnJvbUJsb2NrSW5jbHVzaXZlLCB0b0Jsb2NrRXhjbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXRjaFBhcnRzLCBpLCBoZWFkcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBmcm9tQmxvY2tJbmNsdXNpdmU7IGkgPCB0b0Jsb2NrRXhjbHVzaXZlOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbdG9IZXgoaSksIGZhbHNlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbmRlcnMuc2VuZEJhdGNoKGJhdGNoUGFydHMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaGVhZHMubWFwKHRvTmV3SGVhZHNFdmVudCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlbmRlcnMuc2VuZChcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsIFt0b0hleChibG9ja051bWJlciksIGZhbHNlXSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMb2dzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIGZpbHRlciwgcHJldmlvdXNMb2dzLCBmcm9tQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvQmxvY2tOdW1iZXIsIGxhc3RTZWVuQmxvY2tOdW1iZXIsIG1pbkJsb2NrTnVtYmVyLCBjb21tb25BbmNlc3Rvck51bWJlciwgcmVtb3ZlZExvZ3MsIGFkZGVkTG9ncztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0QmxvY2tOdW1iZXIoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0xvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldExvZ3NJblJhbmdlKGZpbHRlciwgTWF0aC5tYXgoZnJvbUJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyIC0gTUFYX0JBQ0tGSUxMX0JMT0NLUykgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZW5CbG9ja051bWJlciA9IGZyb21IZXgocHJldmlvdXNMb2dzW3ByZXZpb3VzTG9ncy5sZW5ndGggLSAxXS5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5CbG9ja051bWJlciA9IE1hdGgubWF4KDAsIGxhc3RTZWVuQmxvY2tOdW1iZXIgLSBNQVhfQkFDS0ZJTExfQkxPQ0tTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U2VlbkJsb2NrTnVtYmVyIDwgbWluQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBtaW5CbG9ja051bWJlciwgdG9CbG9ja051bWJlciArIDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldENvbW1vbkFuY2VzdG9yTnVtYmVyKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0xvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uQW5jZXN0b3JOdW1iZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRMb2dzID0gcHJldmlvdXNMb2dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobG9nKSB7IHJldHVybiBmcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvck51bWJlcjsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsb2cpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbG9nKSwgeyByZW1vdmVkOiB0cnVlIH0pKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRMb2dzSW5SYW5nZShmaWx0ZXIsIGNvbW1vbkFuY2VzdG9yTnVtYmVyICsgMSwgdG9CbG9ja051bWJlciArIDEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRMb2dzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocmVtb3ZlZExvZ3MpKSwgX19yZWFkKGFkZGVkTG9ncykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbW1vbkFuY2VzdG9yTnVtYmVyKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0xvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIF9hLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBoYXNoO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHByZXZpb3VzTG9ncy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpID49IDApKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gcHJldmlvdXNMb2dzW2ldLCBibG9ja0hhc2ggPSBfYS5ibG9ja0hhc2gsIGJsb2NrTnVtYmVyID0gX2EuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRCbG9ja0J5TnVtYmVyKGZyb21IZXgoYmxvY2tOdW1iZXIpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSAoX2Iuc2VudCgpKS5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tIYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21IZXgoYmxvY2tOdW1iZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMb2dzSW5SYW5nZShmaWx0ZXIsIGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VGaWx0ZXI7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CbG9ja0luY2x1c2l2ZSA+PSB0b0Jsb2NrRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlRmlsdGVyID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGZpbHRlciksIHsgZnJvbUJsb2NrOiB0b0hleChmcm9tQmxvY2tJbmNsdXNpdmUpLCB0b0Jsb2NrOiB0b0hleCh0b0Jsb2NrRXhjbHVzaXZlIC0gMSkgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlbmRlcnMuc2VuZChcImV0aF9nZXRMb2dzXCIsIFtyYW5nZUZpbHRlcl0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBibG9ja051bWJlckhleDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgc2VuZGVycy5zZW5kKFwiZXRoX2Jsb2NrTnVtYmVyXCIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJIZXggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUhleChibG9ja051bWJlckhleCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b05ld0hlYWRzRXZlbnQoaGVhZCkge1xuICAgIHZhciByZXN1bHQgPSBfX2Fzc2lnbih7fSwgaGVhZCk7XG4gICAgZGVsZXRlIHJlc3VsdC50b3RhbERpZmZpY3VsdHk7XG4gICAgZGVsZXRlIHJlc3VsdC50cmFuc2FjdGlvbnM7XG4gICAgZGVsZXRlIHJlc3VsdC51bmNsZXM7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWR1cGVOZXdIZWFkcyhldmVudHMpIHtcbiAgICByZXR1cm4gZGVkdXBlKGV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5oYXNoOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWR1cGVMb2dzKGV2ZW50cykge1xuICAgIHJldHVybiBkZWR1cGUoZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmJsb2NrSGFzaCArIFwiL1wiICsgZXZlbnQubG9nSW5kZXg7IH0pO1xufVxuZnVuY3Rpb24gZGVkdXBlKGl0ZW1zLCBnZXRLZXkpIHtcbiAgICB2YXIga2V5c1NlZW4gPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGtleSA9IGdldEtleShpdGVtKTtcbiAgICAgICAgaWYgKCFrZXlzU2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgICAga2V5c1NlZW4uYWRkKGtleSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpcHRpb25CYWNrZmlsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/subscriptions/subscriptionBackfill.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/types.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/types.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isResponse\": function() { return /* binding */ isResponse; },\n/* harmony export */   \"isSubscriptionEvent\": function() { return /* binding */ isSubscriptionEvent; }\n/* harmony export */ });\n// The JSON-RPC types in Web3 definitions aren't quite right. Use these instead.\nfunction isResponse(message) {\n    return (Array.isArray(message) ||\n        (message.jsonrpc === \"2.0\" && message.id !== undefined));\n}\nfunction isSubscriptionEvent(message) {\n    return !isResponse(message);\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS90eXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS90eXBlcy5qcz8xZGU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZSBKU09OLVJQQyB0eXBlcyBpbiBXZWIzIGRlZmluaXRpb25zIGFyZW4ndCBxdWl0ZSByaWdodC4gVXNlIHRoZXNlIGluc3RlYWQuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpIHx8XG4gICAgICAgIChtZXNzYWdlLmpzb25ycGMgPT09IFwiMi4wXCIgJiYgbWVzc2FnZS5pZCAhPT0gdW5kZWZpbmVkKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdWJzY3JpcHRpb25FdmVudChtZXNzYWdlKSB7XG4gICAgcmV0dXJuICFpc1Jlc3BvbnNlKG1lc3NhZ2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/types.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/util/hex.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/util/hex.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toHex\": function() { return /* binding */ toHex; },\n/* harmony export */   \"fromHex\": function() { return /* binding */ fromHex; },\n/* harmony export */   \"formatBlock\": function() { return /* binding */ formatBlock; }\n/* harmony export */ });\nfunction toHex(n) {\n    return \"0x\" + n.toString(16);\n}\nfunction fromHex(hexString) {\n    return Number.parseInt(hexString, 16);\n}\nfunction formatBlock(block) {\n    if (typeof block === \"string\") {\n        return block;\n    }\n    else if (typeof block === \"number\" && Number.isInteger(block)) {\n        return toHex(block);\n    }\n    return block.toString();\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS91dGlsL2hleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS91dGlsL2hleC5qcz80YjNiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiB0b0hleChuKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIG4udG9TdHJpbmcoMTYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoaGV4U3RyaW5nKSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChoZXhTdHJpbmcsIDE2KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCbG9jayhibG9jaykge1xuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYmxvY2sgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzSW50ZWdlcihibG9jaykpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KGJsb2NrKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrLnRvU3RyaW5nKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/util/hex.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/util/jsonRpc.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/util/jsonRpc.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makePayloadFactory\": function() { return /* binding */ makePayloadFactory; },\n/* harmony export */   \"makeSenders\": function() { return /* binding */ makeSenders; },\n/* harmony export */   \"makeResponse\": function() { return /* binding */ makeResponse; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n\nfunction makePayloadFactory() {\n    var nextId = 0;\n    return function (method, params) { return ({\n        method: method,\n        params: params,\n        jsonrpc: \"2.0\",\n        id: \"alc-web3:\" + nextId++,\n    }); };\n}\nfunction makeSenders(sendPayload, makePayload) {\n    var _this = this;\n    var send = function (method, params) { return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(_this, void 0, void 0, function () {\n        var response;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, sendPayload(makePayload(method, params))];\n                case 1:\n                    response = _a.sent();\n                    if (response.error) {\n                        throw new Error(response.error.message);\n                    }\n                    return [2 /*return*/, response.result];\n            }\n        });\n    }); };\n    function sendBatch(parts) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n            var payload, response, message, errorResponse;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = parts.map(function (_a) {\n                            var method = _a.method, params = _a.params;\n                            return makePayload(method, params);\n                        });\n                        return [4 /*yield*/, sendPayload(payload)];\n                    case 1:\n                        response = _a.sent();\n                        if (!Array.isArray(response)) {\n                            message = response.error\n                                ? response.error.message\n                                : \"Batch request failed\";\n                            throw new Error(message);\n                        }\n                        errorResponse = response.find(function (r) { return !!r.error; });\n                        if (errorResponse) {\n                            throw new Error(errorResponse.error.message);\n                        }\n                        // The ids are ascending numbers because that's what Payload Factories do.\n                        return [2 /*return*/, response\n                                .sort(function (r1, r2) { return r1.id - r2.id; })\n                                .map(function (r) { return r.result; })];\n                }\n            });\n        });\n    }\n    return { send: send, sendBatch: sendBatch };\n}\nfunction makeResponse(id, result) {\n    return { jsonrpc: \"2.0\", id: id, result: result };\n}\n//# sourceMappingURL=jsonRpc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS91dGlsL2pzb25ScGMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQztBQUN4QztBQUNQO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBLDJDQUEyQyxPQUFPLGdEQUFTO0FBQzNEO0FBQ0EsZUFBZSxrREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsZUFBZSxnREFBUztBQUN4QjtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxtQkFBbUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx1QkFBdUI7QUFDakYsb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL2Rpc3QvZXNtL3V0aWwvanNvblJwYy5qcz85OWE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGF5bG9hZEZhY3RvcnkoKSB7XG4gICAgdmFyIG5leHRJZCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykgeyByZXR1cm4gKHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBpZDogXCJhbGMtd2ViMzpcIiArIG5leHRJZCsrLFxuICAgIH0pOyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTZW5kZXJzKHNlbmRQYXlsb2FkLCBtYWtlUGF5bG9hZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBzZW5kUGF5bG9hZChtYWtlUGF5bG9hZChtZXRob2QsIHBhcmFtcykpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2UucmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH07XG4gICAgZnVuY3Rpb24gc2VuZEJhdGNoKHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkLCByZXNwb25zZSwgbWVzc2FnZSwgZXJyb3JSZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IF9hLm1ldGhvZCwgcGFyYW1zID0gX2EucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUGF5bG9hZChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbmRQYXlsb2FkKHBheWxvYWQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHJlc3BvbnNlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiQmF0Y2ggcmVxdWVzdCBmYWlsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlID0gcmVzcG9uc2UuZmluZChmdW5jdGlvbiAocikgeyByZXR1cm4gISFyLmVycm9yOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvclJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaWRzIGFyZSBhc2NlbmRpbmcgbnVtYmVycyBiZWNhdXNlIHRoYXQncyB3aGF0IFBheWxvYWQgRmFjdG9yaWVzIGRvLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChyMSwgcjIpIHsgcmV0dXJuIHIxLmlkIC0gcjIuaWQ7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIucmVzdWx0OyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBzZW5kOiBzZW5kLCBzZW5kQmF0Y2g6IHNlbmRCYXRjaCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZXNwb25zZShpZCwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIHsganNvbnJwYzogXCIyLjBcIiwgaWQ6IGlkLCByZXN1bHQ6IHJlc3VsdCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvblJwYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/util/jsonRpc.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"promisify\": function() { return /* binding */ promisify; },\n/* harmony export */   \"callWhenDone\": function() { return /* binding */ callWhenDone; },\n/* harmony export */   \"delay\": function() { return /* binding */ delay; },\n/* harmony export */   \"withTimeout\": function() { return /* binding */ withTimeout; },\n/* harmony export */   \"withBackoffRetries\": function() { return /* binding */ withBackoffRetries; },\n/* harmony export */   \"makeCancelToken\": function() { return /* binding */ makeCancelToken; },\n/* harmony export */   \"throwIfCancelled\": function() { return /* binding */ throwIfCancelled; },\n/* harmony export */   \"CANCELLED\": function() { return /* binding */ CANCELLED; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n\n/**\n * Helper for converting functions which take a callback as their final argument\n * to functions which return a promise.\n */\nfunction promisify(f) {\n    return new Promise(function (resolve, reject) {\n        return f(function (error, result) {\n            if (error != null) {\n                reject(error);\n            }\n            else {\n                resolve(result);\n            }\n        });\n    });\n}\n/**\n * Helper for converting functions which return a promise to functions which\n * take a callback as their final argument.\n */\nfunction callWhenDone(promise, callback) {\n    promise.then(function (result) {\n        callback(null, result);\n    }, function (error) {\n        callback(error);\n    });\n}\nfunction delay(ms) {\n    return new Promise(function (resolve) { return setTimeout(resolve, ms); });\n}\nfunction withTimeout(promise, ms) {\n    return Promise.race([\n        promise,\n        new Promise(function (_, reject) {\n            return setTimeout(function () { return reject(new Error(\"Timeout\")); }, ms);\n        }),\n    ]);\n}\nvar MIN_RETRY_DELAY = 1000;\nvar RETRY_BACKOFF_FACTOR = 2;\nvar MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount, shouldRetry) {\n    if (shouldRetry === void 0) { shouldRetry = function () { return true; }; }\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\n        var nextWaitTime, i, error_1;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    nextWaitTime = 0;\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    if (false) {}\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, , 6]);\n                    return [4 /*yield*/, f()];\n                case 3: return [2 /*return*/, _a.sent()];\n                case 4:\n                    error_1 = _a.sent();\n                    i++;\n                    if (i >= retryCount || !shouldRetry(error_1)) {\n                        throw error_1;\n                    }\n                    return [4 /*yield*/, delay(nextWaitTime)];\n                case 5:\n                    _a.sent();\n                    if (!shouldRetry(error_1)) {\n                        throw error_1;\n                    }\n                    nextWaitTime =\n                        nextWaitTime === 0\n                            ? MIN_RETRY_DELAY\n                            : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n                    return [3 /*break*/, 6];\n                case 6: return [3 /*break*/, 1];\n                case 7: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction makeCancelToken() {\n    var cancelled = false;\n    return { cancel: function () { return (cancelled = true); }, isCancelled: function () { return cancelled; } };\n}\nfunction throwIfCancelled(isCancelled) {\n    if (isCancelled()) {\n        throw CANCELLED;\n    }\n}\nvar CANCELLED = new Error(\"Cancelled\");\n//# sourceMappingURL=promises.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS91dGlsL3Byb21pc2VzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1AsNENBQTRDLGlDQUFpQztBQUM3RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNDQUFzQztBQUNsRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0NBQWtDLDRCQUE0QjtBQUM5RCxXQUFXLGdEQUFTO0FBQ3BCO0FBQ0EsZUFBZSxrREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSyxFQUFFLEVBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQSxhQUFhLHNCQUFzQiw0QkFBNEIsNkJBQTZCO0FBQzVGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvZGlzdC9lc20vdXRpbC9wcm9taXNlcy5qcz8xOTVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcbi8qKlxuICogSGVscGVyIGZvciBjb252ZXJ0aW5nIGZ1bmN0aW9ucyB3aGljaCB0YWtlIGEgY2FsbGJhY2sgYXMgdGhlaXIgZmluYWwgYXJndW1lbnRcbiAqIHRvIGZ1bmN0aW9ucyB3aGljaCByZXR1cm4gYSBwcm9taXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzaWZ5KGYpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gZihmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBjb252ZXJ0aW5nIGZ1bmN0aW9ucyB3aGljaCByZXR1cm4gYSBwcm9taXNlIHRvIGZ1bmN0aW9ucyB3aGljaFxuICogdGFrZSBhIGNhbGxiYWNrIGFzIHRoZWlyIGZpbmFsIGFyZ3VtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbFdoZW5Eb25lKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aFRpbWVvdXQocHJvbWlzZSwgbXMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXRcIikpOyB9LCBtcyk7XG4gICAgICAgIH0pLFxuICAgIF0pO1xufVxudmFyIE1JTl9SRVRSWV9ERUxBWSA9IDEwMDA7XG52YXIgUkVUUllfQkFDS09GRl9GQUNUT1IgPSAyO1xudmFyIE1BWF9SRVRSWV9ERUxBWSA9IDMwMDAwO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhCYWNrb2ZmUmV0cmllcyhmLCByZXRyeUNvdW50LCBzaG91bGRSZXRyeSkge1xuICAgIGlmIChzaG91bGRSZXRyeSA9PT0gdm9pZCAwKSB7IHNob3VsZFJldHJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRXYWl0VGltZSwgaSwgZXJyb3JfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgbmV4dFdhaXRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgNCwgLCA2XSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGYoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gcmV0cnlDb3VudCB8fCAhc2hvdWxkUmV0cnkoZXJyb3JfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGVsYXkobmV4dFdhaXRUaW1lKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyb3JfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dFdhaXRUaW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRXYWl0VGltZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTUlOX1JFVFJZX0RFTEFZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihNQVhfUkVUUllfREVMQVksIFJFVFJZX0JBQ0tPRkZfRkFDVE9SICogbmV4dFdhaXRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUNhbmNlbFRva2VuKCkge1xuICAgIHZhciBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4geyBjYW5jZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChjYW5jZWxsZWQgPSB0cnVlKTsgfSwgaXNDYW5jZWxsZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxlZDsgfSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpIHtcbiAgICBpZiAoaXNDYW5jZWxsZWQoKSkge1xuICAgICAgICB0aHJvdyBDQU5DRUxMRUQ7XG4gICAgfVxufVxuZXhwb3J0IHZhciBDQU5DRUxMRUQgPSBuZXcgRXJyb3IoXCJDYW5jZWxsZWRcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/version.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/version.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VERSION\": function() { return /* binding */ VERSION; }\n/* harmony export */ });\n// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nvar VERSION = \"1.1.8\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS92ZXJzaW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS92ZXJzaW9uLmpzP2U3YzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGlzIGF1dG9nZW5lcmF0ZWQgYnkgaW5qZWN0VmVyc2lvbi5qcy4gQW55IGNoYW5nZXMgd2lsbCBiZVxuLy8gb3ZlcndyaXR0ZW4gb24gY29tbWl0IVxuZXhwb3J0IHZhciBWRVJTSU9OID0gXCIxLjEuOFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/version.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemyContext.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemyContext.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeAlchemyContext\": function() { return /* binding */ makeAlchemyContext; }\n/* harmony export */ });\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"../../node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var websocket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! websocket */ \"../../node_modules/websocket/lib/browser.js\");\n/* harmony import */ var websocket__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(websocket__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_jsonRpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/jsonRpc */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/jsonRpc.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../version */ \"../../node_modules/@alch/alchemy-web3/dist/esm/version.js\");\n/* harmony import */ var _alchemySendHttp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alchemySendHttp */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendHttp.js\");\n/* harmony import */ var _alchemySendWebSocket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./alchemySendWebSocket */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendWebSocket.js\");\n/* harmony import */ var _httpProvider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./httpProvider */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/httpProvider.js\");\n/* harmony import */ var _sendPayload__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sendPayload */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/sendPayload.js\");\n/* harmony import */ var _webSocketProvider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./webSocketProvider */ \"../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/webSocketProvider.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\nvar NODE_MAX_WS_FRAME_SIZE = 100 * 1024 * 1024; // 100 MB\nfunction makeAlchemyContext(url, config) {\n    var makePayload = (0,_util_jsonRpc__WEBPACK_IMPORTED_MODULE_2__.makePayloadFactory)();\n    if (/^https?:\\/\\//.test(url)) {\n        var alchemySend = (0,_alchemySendHttp__WEBPACK_IMPORTED_MODULE_3__.makeHttpSender)(url);\n        var _a = (0,_sendPayload__WEBPACK_IMPORTED_MODULE_4__.makePayloadSender)(alchemySend, config), sendPayload = _a.sendPayload, setWriteProvider = _a.setWriteProvider;\n        var senders = (0,_util_jsonRpc__WEBPACK_IMPORTED_MODULE_2__.makeSenders)(sendPayload, makePayload);\n        var provider = (0,_httpProvider__WEBPACK_IMPORTED_MODULE_5__.makeAlchemyHttpProvider)(sendPayload);\n        return { provider: provider, senders: senders, setWriteProvider: setWriteProvider };\n    }\n    else if (/^wss?:\\/\\//.test(url)) {\n        var protocol = isAlchemyUrl(url) ? \"alchemy-web3-\" + _version__WEBPACK_IMPORTED_MODULE_6__.VERSION : undefined;\n        var ws = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__[\"default\"](url, protocol, {\n            wsConstructor: getWebSocketConstructor(),\n        });\n        var alchemySend = (0,_alchemySendWebSocket__WEBPACK_IMPORTED_MODULE_7__.makeWebSocketSender)(ws);\n        var _b = (0,_sendPayload__WEBPACK_IMPORTED_MODULE_4__.makePayloadSender)(alchemySend, config), sendPayload = _b.sendPayload, setWriteProvider = _b.setWriteProvider;\n        var senders = (0,_util_jsonRpc__WEBPACK_IMPORTED_MODULE_2__.makeSenders)(sendPayload, makePayload);\n        var provider = new _webSocketProvider__WEBPACK_IMPORTED_MODULE_8__.AlchemyWebSocketProvider(ws, sendPayload, senders);\n        return { provider: provider, senders: senders, setWriteProvider: setWriteProvider };\n    }\n    else {\n        throw new Error(\"Alchemy URL protocol must be one of http, https, ws, or wss. Recieved: \" + url);\n    }\n}\nfunction getWebSocketConstructor() {\n    return isNodeEnvironment()\n        ? function (url, protocols) {\n            return new websocket__WEBPACK_IMPORTED_MODULE_1__.w3cwebsocket(url, protocols, undefined, undefined, undefined, {\n                maxReceivedMessageSize: NODE_MAX_WS_FRAME_SIZE,\n                maxReceivedFrameSize: NODE_MAX_WS_FRAME_SIZE,\n            });\n        }\n        : WebSocket;\n}\nfunction isNodeEnvironment() {\n    return (typeof process !== \"undefined\" &&\n        process != null &&\n        process.versions != null &&\n        process.versions.node != null);\n}\nfunction isAlchemyUrl(url) {\n    return url.indexOf(\"alchemyapi.io\") >= 0;\n}\n//# sourceMappingURL=alchemyContext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvYWxjaGVteUNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQStDO0FBQ047QUFDMEI7QUFDOUI7QUFDYztBQUNVO0FBQ0o7QUFDUDtBQUNhO0FBQy9ELGdEQUFnRDtBQUN6QztBQUNQLHNCQUFzQixpRUFBa0I7QUFDeEM7QUFDQSwwQkFBMEIsZ0VBQWM7QUFDeEMsaUJBQWlCLCtEQUFpQjtBQUNsQyxzQkFBc0IsMERBQVc7QUFDakMsdUJBQXVCLHNFQUF1QjtBQUM5QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZEQUE2RCw2Q0FBTztBQUNwRSxxQkFBcUIsd0RBQWU7QUFDcEM7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLDBFQUFtQjtBQUM3QyxpQkFBaUIsK0RBQWlCO0FBQ2xDLHNCQUFzQiwwREFBVztBQUNqQywyQkFBMkIsd0VBQXdCO0FBQ25ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFZO0FBQ25DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixRQUFRLE9BQU87QUFDZixRQUFRLE9BQU87QUFDZixRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL2Rpc3QvZXNtL3dlYjMtYWRhcHRlci9hbGNoZW15Q29udGV4dC5qcz83ZTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdHVyZHlXZWJTb2NrZXQgZnJvbSBcInN0dXJkeS13ZWJzb2NrZXRcIjtcbmltcG9ydCB7IHczY3dlYnNvY2tldCB9IGZyb20gXCJ3ZWJzb2NrZXRcIjtcbmltcG9ydCB7IG1ha2VQYXlsb2FkRmFjdG9yeSwgbWFrZVNlbmRlcnMsIH0gZnJvbSBcIi4uL3V0aWwvanNvblJwY1wiO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuLi92ZXJzaW9uXCI7XG5pbXBvcnQgeyBtYWtlSHR0cFNlbmRlciB9IGZyb20gXCIuL2FsY2hlbXlTZW5kSHR0cFwiO1xuaW1wb3J0IHsgbWFrZVdlYlNvY2tldFNlbmRlciB9IGZyb20gXCIuL2FsY2hlbXlTZW5kV2ViU29ja2V0XCI7XG5pbXBvcnQgeyBtYWtlQWxjaGVteUh0dHBQcm92aWRlciB9IGZyb20gXCIuL2h0dHBQcm92aWRlclwiO1xuaW1wb3J0IHsgbWFrZVBheWxvYWRTZW5kZXIgfSBmcm9tIFwiLi9zZW5kUGF5bG9hZFwiO1xuaW1wb3J0IHsgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vd2ViU29ja2V0UHJvdmlkZXJcIjtcbnZhciBOT0RFX01BWF9XU19GUkFNRV9TSVpFID0gMTAwICogMTAyNCAqIDEwMjQ7IC8vIDEwMCBNQlxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBbGNoZW15Q29udGV4dCh1cmwsIGNvbmZpZykge1xuICAgIHZhciBtYWtlUGF5bG9hZCA9IG1ha2VQYXlsb2FkRmFjdG9yeSgpO1xuICAgIGlmICgvXmh0dHBzPzpcXC9cXC8vLnRlc3QodXJsKSkge1xuICAgICAgICB2YXIgYWxjaGVteVNlbmQgPSBtYWtlSHR0cFNlbmRlcih1cmwpO1xuICAgICAgICB2YXIgX2EgPSBtYWtlUGF5bG9hZFNlbmRlcihhbGNoZW15U2VuZCwgY29uZmlnKSwgc2VuZFBheWxvYWQgPSBfYS5zZW5kUGF5bG9hZCwgc2V0V3JpdGVQcm92aWRlciA9IF9hLnNldFdyaXRlUHJvdmlkZXI7XG4gICAgICAgIHZhciBzZW5kZXJzID0gbWFrZVNlbmRlcnMoc2VuZFBheWxvYWQsIG1ha2VQYXlsb2FkKTtcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gbWFrZUFsY2hlbXlIdHRwUHJvdmlkZXIoc2VuZFBheWxvYWQpO1xuICAgICAgICByZXR1cm4geyBwcm92aWRlcjogcHJvdmlkZXIsIHNlbmRlcnM6IHNlbmRlcnMsIHNldFdyaXRlUHJvdmlkZXI6IHNldFdyaXRlUHJvdmlkZXIgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL153c3M/OlxcL1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IGlzQWxjaGVteVVybCh1cmwpID8gXCJhbGNoZW15LXdlYjMtXCIgKyBWRVJTSU9OIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgd3MgPSBuZXcgU3R1cmR5V2ViU29ja2V0KHVybCwgcHJvdG9jb2wsIHtcbiAgICAgICAgICAgIHdzQ29uc3RydWN0b3I6IGdldFdlYlNvY2tldENvbnN0cnVjdG9yKCksXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYWxjaGVteVNlbmQgPSBtYWtlV2ViU29ja2V0U2VuZGVyKHdzKTtcbiAgICAgICAgdmFyIF9iID0gbWFrZVBheWxvYWRTZW5kZXIoYWxjaGVteVNlbmQsIGNvbmZpZyksIHNlbmRQYXlsb2FkID0gX2Iuc2VuZFBheWxvYWQsIHNldFdyaXRlUHJvdmlkZXIgPSBfYi5zZXRXcml0ZVByb3ZpZGVyO1xuICAgICAgICB2YXIgc2VuZGVycyA9IG1ha2VTZW5kZXJzKHNlbmRQYXlsb2FkLCBtYWtlUGF5bG9hZCk7XG4gICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIod3MsIHNlbmRQYXlsb2FkLCBzZW5kZXJzKTtcbiAgICAgICAgcmV0dXJuIHsgcHJvdmlkZXI6IHByb3ZpZGVyLCBzZW5kZXJzOiBzZW5kZXJzLCBzZXRXcml0ZVByb3ZpZGVyOiBzZXRXcml0ZVByb3ZpZGVyIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbGNoZW15IFVSTCBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBodHRwLCBodHRwcywgd3MsIG9yIHdzcy4gUmVjaWV2ZWQ6IFwiICsgdXJsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm4gaXNOb2RlRW52aXJvbm1lbnQoKVxuICAgICAgICA/IGZ1bmN0aW9uICh1cmwsIHByb3RvY29scykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3M2N3ZWJzb2NrZXQodXJsLCBwcm90b2NvbHMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBtYXhSZWNlaXZlZE1lc3NhZ2VTaXplOiBOT0RFX01BWF9XU19GUkFNRV9TSVpFLFxuICAgICAgICAgICAgICAgIG1heFJlY2VpdmVkRnJhbWVTaXplOiBOT0RFX01BWF9XU19GUkFNRV9TSVpFLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiBXZWJTb2NrZXQ7XG59XG5mdW5jdGlvbiBpc05vZGVFbnZpcm9ubWVudCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHByb2Nlc3MgIT0gbnVsbCAmJlxuICAgICAgICBwcm9jZXNzLnZlcnNpb25zICE9IG51bGwgJiZcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9IG51bGwpO1xufVxuZnVuY3Rpb24gaXNBbGNoZW15VXJsKHVybCkge1xuICAgIHJldHVybiB1cmwuaW5kZXhPZihcImFsY2hlbXlhcGkuaW9cIikgPj0gMDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsY2hlbXlDb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemyContext.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendHttp.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendHttp.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeHttpSender\": function() { return /* binding */ makeHttpSender; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var fetch_ponyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fetch-ponyfill */ \"../../node_modules/fetch-ponyfill/build/fetch-browser.js\");\n/* harmony import */ var fetch_ponyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fetch_ponyfill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../version */ \"../../node_modules/@alch/alchemy-web3/dist/esm/version.js\");\n\n\n\nvar _a = fetch_ponyfill__WEBPACK_IMPORTED_MODULE_0___default()(), fetch = _a.fetch, Headers = _a.Headers;\nvar ALCHEMY_HEADERS = new Headers({\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n    \"Alchemy-Web3-Version\": _version__WEBPACK_IMPORTED_MODULE_1__.VERSION,\n});\nvar RATE_LIMIT_STATUS = 429;\nfunction makeHttpSender(url) {\n    var _this = this;\n    return function (request) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function () {\n        var response, status, _a;\n        var _b, _c;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_d) {\n            switch (_d.label) {\n                case 0: return [4 /*yield*/, fetch(url, {\n                        method: \"POST\",\n                        headers: ALCHEMY_HEADERS,\n                        body: JSON.stringify(request),\n                    })];\n                case 1:\n                    response = _d.sent();\n                    status = response.status;\n                    _a = status;\n                    switch (_a) {\n                        case 200: return [3 /*break*/, 2];\n                        case RATE_LIMIT_STATUS: return [3 /*break*/, 4];\n                        case 0: return [3 /*break*/, 5];\n                    }\n                    return [3 /*break*/, 6];\n                case 2:\n                    _b = { type: \"jsonrpc\" };\n                    return [4 /*yield*/, response.json()];\n                case 3: return [2 /*return*/, (_b.response = _d.sent(), _b)];\n                case 4: return [2 /*return*/, { type: \"rateLimit\" }];\n                case 5: return [2 /*return*/, {\n                        type: \"networkError\",\n                        status: 0,\n                        message: \"Connection failed.\",\n                    }];\n                case 6:\n                    _c = {\n                        status: status,\n                        type: \"networkError\"\n                    };\n                    return [4 /*yield*/, response.json()];\n                case 7: return [2 /*return*/, (_c.message = (_d.sent()).message,\n                        _c)];\n            }\n        });\n    }); };\n}\n//# sourceMappingURL=alchemySendHttp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvYWxjaGVteVNlbmRIdHRwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ0o7QUFDTjtBQUNyQyxTQUFTLHFEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBTztBQUNuQyxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0EsZ0NBQWdDLE9BQU8sZ0RBQVM7QUFDaEQ7QUFDQTtBQUNBLGVBQWUsa0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvYWxjaGVteVNlbmRIdHRwLmpzPzkzYTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGZldGNoUG9ueWZpbGwgZnJvbSBcImZldGNoLXBvbnlmaWxsXCI7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4uL3ZlcnNpb25cIjtcbnZhciBfYSA9IGZldGNoUG9ueWZpbGwoKSwgZmV0Y2ggPSBfYS5mZXRjaCwgSGVhZGVycyA9IF9hLkhlYWRlcnM7XG52YXIgQUxDSEVNWV9IRUFERVJTID0gbmV3IEhlYWRlcnMoe1xuICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgXCJBbGNoZW15LVdlYjMtVmVyc2lvblwiOiBWRVJTSU9OLFxufSk7XG52YXIgUkFURV9MSU1JVF9TVEFUVVMgPSA0Mjk7XG5leHBvcnQgZnVuY3Rpb24gbWFrZUh0dHBTZW5kZXIodXJsKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlcXVlc3QpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlLCBzdGF0dXMsIF9hO1xuICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBBTENIRU1ZX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjAwOiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUkFURV9MSU1JVF9TVEFUVVM6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9iID0geyB0eXBlOiBcImpzb25ycGNcIiB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYi5yZXNwb25zZSA9IF9kLnNlbnQoKSwgX2IpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB7IHR5cGU6IFwicmF0ZUxpbWl0XCIgfV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJuZXR3b3JrRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBmYWlsZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgX2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibmV0d29ya0Vycm9yXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UuanNvbigpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2MubWVzc2FnZSA9IChfZC5zZW50KCkpLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTsgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsY2hlbXlTZW5kSHR0cC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendHttp.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendWebSocket.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendWebSocket.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeWebSocketSender\": function() { return /* binding */ makeWebSocketSender; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"../../node_modules/@alch/alchemy-web3/dist/esm/types.js\");\n\n\nfunction makeWebSocketSender(ws) {\n    var contextsById = new Map();\n    ws.addEventListener(\"message\", function (message) {\n        var response = JSON.parse(message.data);\n        if (!(0,_types__WEBPACK_IMPORTED_MODULE_0__.isResponse)(response)) {\n            return;\n        }\n        var id = getIdFromResponse(response);\n        if (id === undefined) {\n            return;\n        }\n        var context = contextsById.get(id);\n        if (!context) {\n            return;\n        }\n        var resolve = context.resolve;\n        contextsById.delete(id);\n        if (!Array.isArray(response) &&\n            response.error &&\n            response.error.code === 429) {\n            resolve({ type: \"rateLimit\" });\n        }\n        else {\n            resolve({ response: response, type: \"jsonrpc\" });\n        }\n    });\n    ws.addEventListener(\"down\", function () {\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(contextsById)).forEach(function (_a) {\n            var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(_a, 2), id = _b[0], _c = _b[1], request = _c.request, resolve = _c.resolve;\n            if (isWrite(request)) {\n                // Writes cannot be resent because they will fail for a duplicate nonce.\n                contextsById.delete(id);\n                resolve({\n                    type: \"networkError\",\n                    status: 0,\n                    message: \"WebSocket closed before receiving a response for write request with id: \" + id + \".\",\n                });\n            }\n        });\n    });\n    ws.addEventListener(\"reopen\", function () {\n        var e_1, _a;\n        try {\n            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(contextsById.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var request = _c.value.request;\n                ws.send(JSON.stringify(request));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    });\n    return function (request) {\n        return new Promise(function (resolve) {\n            var id = getIdFromRequest(request);\n            if (id !== undefined) {\n                var existingContext = contextsById.get(id);\n                if (existingContext) {\n                    var message = \"Another WebSocket request was made with the same id (\" + id + \") before a response was received.\";\n                    console.error(message);\n                    existingContext.resolve({\n                        message: message,\n                        type: \"networkError\",\n                        status: 0,\n                    });\n                }\n                contextsById.set(id, { request: request, resolve: resolve });\n            }\n            ws.send(JSON.stringify(request));\n        });\n    };\n}\nfunction getIdFromRequest(request) {\n    if (!Array.isArray(request)) {\n        return request.id;\n    }\n    return getCanonicalIdFromList(request.map(function (p) { return p.id; }));\n}\nfunction getIdFromResponse(response) {\n    if (!Array.isArray(response)) {\n        return response.id;\n    }\n    return getCanonicalIdFromList(response.map(function (p) { return p.id; }));\n}\n/**\n * Since the JSON-RPC spec allows responses to be returned in a different order\n * than sent, we need a mechanism for choosing a canonical id from a list that\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\n * ordering: the smallest string if possible, otherwise the smallest number,\n * otherwise null.\n */\nfunction getCanonicalIdFromList(ids) {\n    var stringIds = ids.filter(function (id) { return typeof id === \"string\"; });\n    if (stringIds.length > 0) {\n        return stringIds.reduce(function (bestId, id) { return (bestId < id ? bestId : id); });\n    }\n    var numberIds = ids.filter(function (id) { return typeof id === \"number\"; });\n    if (numberIds.length > 0) {\n        return Math.min.apply(Math, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(numberIds)));\n    }\n    return ids.indexOf(null) >= 0 ? null : undefined;\n}\nfunction isWrite(request) {\n    return Array.isArray(request)\n        ? request.every(isSingleWrite)\n        : isSingleWrite(request);\n}\nvar WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\nfunction isSingleWrite(request) {\n    return WRITE_METHODS.includes(request.method);\n}\n//# sourceMappingURL=alchemySendWebSocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvYWxjaGVteVNlbmRXZWJTb2NrZXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdEO0FBQ2pCO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrREFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSxvREFBYSxLQUFLLDZDQUFNO0FBQ2hDLHFCQUFxQiw2Q0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFRLHlDQUF5QyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUNBQXVDLG9DQUFvQztBQUMzRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0NBQWdDO0FBQy9FO0FBQ0Esd0RBQXdELHFDQUFxQztBQUM3RjtBQUNBLCtDQUErQyxnQ0FBZ0M7QUFDL0U7QUFDQSxvQ0FBb0Msb0RBQWEsS0FBSyw2Q0FBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvYWxjaGVteVNlbmRXZWJTb2NrZXQuanM/N2FkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3JlYWQsIF9fc3ByZWFkQXJyYXksIF9fdmFsdWVzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpc1Jlc3BvbnNlLCB9IGZyb20gXCIuLi90eXBlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VXZWJTb2NrZXRTZW5kZXIod3MpIHtcbiAgICB2YXIgY29udGV4dHNCeUlkID0gbmV3IE1hcCgpO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgaWYgKCFpc1Jlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IGdldElkRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzQnlJZC5nZXQoaWQpO1xuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb2x2ZSA9IGNvbnRleHQucmVzb2x2ZTtcbiAgICAgICAgY29udGV4dHNCeUlkLmRlbGV0ZShpZCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwb25zZSkgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yICYmXG4gICAgICAgICAgICByZXNwb25zZS5lcnJvci5jb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyB0eXBlOiBcInJhdGVMaW1pdFwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHJlc3BvbnNlOiByZXNwb25zZSwgdHlwZTogXCJqc29ucnBjXCIgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChjb250ZXh0c0J5SWQpKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgaWQgPSBfYlswXSwgX2MgPSBfYlsxXSwgcmVxdWVzdCA9IF9jLnJlcXVlc3QsIHJlc29sdmUgPSBfYy5yZXNvbHZlO1xuICAgICAgICAgICAgaWYgKGlzV3JpdGUocmVxdWVzdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZXMgY2Fubm90IGJlIHJlc2VudCBiZWNhdXNlIHRoZXkgd2lsbCBmYWlsIGZvciBhIGR1cGxpY2F0ZSBub25jZS5cbiAgICAgICAgICAgICAgICBjb250ZXh0c0J5SWQuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJuZXR3b3JrRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIldlYlNvY2tldCBjbG9zZWQgYmVmb3JlIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZvciB3cml0ZSByZXF1ZXN0IHdpdGggaWQ6IFwiICsgaWQgKyBcIi5cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcInJlb3BlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhjb250ZXh0c0J5SWQudmFsdWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBfYy52YWx1ZS5yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBnZXRJZEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdDb250ZXh0ID0gY29udGV4dHNCeUlkLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiQW5vdGhlciBXZWJTb2NrZXQgcmVxdWVzdCB3YXMgbWFkZSB3aXRoIHRoZSBzYW1lIGlkIChcIiArIGlkICsgXCIpIGJlZm9yZSBhIHJlc3BvbnNlIHdhcyByZWNlaXZlZC5cIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDb250ZXh0LnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibmV0d29ya0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0c0J5SWQuc2V0KGlkLCB7IHJlcXVlc3Q6IHJlcXVlc3QsIHJlc29sdmU6IHJlc29sdmUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldElkRnJvbVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXF1ZXN0KSkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdC5pZDtcbiAgICB9XG4gICAgcmV0dXJuIGdldENhbm9uaWNhbElkRnJvbUxpc3QocmVxdWVzdC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuaWQ7IH0pKTtcbn1cbmZ1bmN0aW9uIGdldElkRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaWQ7XG4gICAgfVxuICAgIHJldHVybiBnZXRDYW5vbmljYWxJZEZyb21MaXN0KHJlc3BvbnNlLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5pZDsgfSkpO1xufVxuLyoqXG4gKiBTaW5jZSB0aGUgSlNPTi1SUEMgc3BlYyBhbGxvd3MgcmVzcG9uc2VzIHRvIGJlIHJldHVybmVkIGluIGEgZGlmZmVyZW50IG9yZGVyXG4gKiB0aGFuIHNlbnQsIHdlIG5lZWQgYSBtZWNoYW5pc20gZm9yIGNob29zaW5nIGEgY2Fub25pY2FsIGlkIGZyb20gYSBsaXN0IHRoYXRcbiAqIGRvZXNuJ3QgZGVwZW5kIG9uIHRoZSBvcmRlci4gVGhpcyBjaG9vc2VzIHRoZSBcIm1pbmltdW1cIiBpZCBieSBhbiBhcmJpdHJhcnlcbiAqIG9yZGVyaW5nOiB0aGUgc21hbGxlc3Qgc3RyaW5nIGlmIHBvc3NpYmxlLCBvdGhlcndpc2UgdGhlIHNtYWxsZXN0IG51bWJlcixcbiAqIG90aGVyd2lzZSBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRDYW5vbmljYWxJZEZyb21MaXN0KGlkcykge1xuICAgIHZhciBzdHJpbmdJZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdHlwZW9mIGlkID09PSBcInN0cmluZ1wiOyB9KTtcbiAgICBpZiAoc3RyaW5nSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ0lkcy5yZWR1Y2UoZnVuY3Rpb24gKGJlc3RJZCwgaWQpIHsgcmV0dXJuIChiZXN0SWQgPCBpZCA/IGJlc3RJZCA6IGlkKTsgfSk7XG4gICAgfVxuICAgIHZhciBudW1iZXJJZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdHlwZW9mIGlkID09PSBcIm51bWJlclwiOyB9KTtcbiAgICBpZiAobnVtYmVySWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChudW1iZXJJZHMpKSk7XG4gICAgfVxuICAgIHJldHVybiBpZHMuaW5kZXhPZihudWxsKSA+PSAwID8gbnVsbCA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzV3JpdGUocmVxdWVzdCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVlc3QpXG4gICAgICAgID8gcmVxdWVzdC5ldmVyeShpc1NpbmdsZVdyaXRlKVxuICAgICAgICA6IGlzU2luZ2xlV3JpdGUocmVxdWVzdCk7XG59XG52YXIgV1JJVEVfTUVUSE9EUyA9IFtcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCJdO1xuZnVuY3Rpb24gaXNTaW5nbGVXcml0ZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIFdSSVRFX01FVEhPRFMuaW5jbHVkZXMocmVxdWVzdC5tZXRob2QpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteVNlbmRXZWJTb2NrZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/alchemySendWebSocket.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/customRPC.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/customRPC.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"patchEnableCustomRPC\": function() { return /* binding */ patchEnableCustomRPC; }\n/* harmony export */ });\n/* harmony import */ var web3_core_method__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\n/* harmony import */ var web3_core_method__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_core_method__WEBPACK_IMPORTED_MODULE_0__);\n\nvar MethodFn = (web3_core_method__WEBPACK_IMPORTED_MODULE_0___default());\nfunction patchEnableCustomRPC(web3) {\n    web3.eth.customRPC = function (opts) {\n        var newMethod = new MethodFn({\n            name: opts.name,\n            call: opts.call,\n            params: opts.params || 0,\n            inputFormatter: opts.inputFormatter || null,\n            outputFormatter: opts.outputFormatter || null,\n        });\n        newMethod.attachToObject(this);\n        newMethod.setRequestManager(this._requestManager, this.accounts);\n    };\n}\n//# sourceMappingURL=customRPC.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvY3VzdG9tUlBDLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzQztBQUN0QyxlQUFlLHlEQUFNO0FBQ2Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL2Rpc3QvZXNtL3dlYjMtYWRhcHRlci9jdXN0b21SUEMuanM/ODFhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWV0aG9kIGZyb20gXCJ3ZWIzLWNvcmUtbWV0aG9kXCI7XG52YXIgTWV0aG9kRm4gPSBNZXRob2Q7XG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hFbmFibGVDdXN0b21SUEMod2ViMykge1xuICAgIHdlYjMuZXRoLmN1c3RvbVJQQyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHZhciBuZXdNZXRob2QgPSBuZXcgTWV0aG9kRm4oe1xuICAgICAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICAgICAgY2FsbDogb3B0cy5jYWxsLFxuICAgICAgICAgICAgcGFyYW1zOiBvcHRzLnBhcmFtcyB8fCAwLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IG9wdHMuaW5wdXRGb3JtYXR0ZXIgfHwgbnVsbCxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogb3B0cy5vdXRwdXRGb3JtYXR0ZXIgfHwgbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld01ldGhvZC5hdHRhY2hUb09iamVjdCh0aGlzKTtcbiAgICAgICAgbmV3TWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB0aGlzLmFjY291bnRzKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tUlBDLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/customRPC.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_feeHistory.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_feeHistory.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"patchEthFeeHistoryMethod\": function() { return /* binding */ patchEthFeeHistoryMethod; }\n/* harmony export */ });\n/* harmony import */ var web3_core_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\");\n/* harmony import */ var web3_core_helpers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_core_helpers__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\n/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction patchEthFeeHistoryMethod(web3) {\n    web3.eth.customRPC({\n        name: \"getFeeHistory\",\n        call: \"eth_feeHistory\",\n        params: 3,\n        inputFormatter: [\n            web3_utils__WEBPACK_IMPORTED_MODULE_1__.toNumber,\n            web3_core_helpers__WEBPACK_IMPORTED_MODULE_0__.formatters.inputBlockNumberFormatter,\n            function (value) { return value; },\n        ],\n    });\n}\n//# sourceMappingURL=eth_feeHistory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvZXRoX2ZlZUhpc3RvcnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDVDtBQUMvQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFRO0FBQ3BCLFlBQVksbUZBQW9DO0FBQ2hELCtCQUErQixlQUFlO0FBQzlDO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvZGlzdC9lc20vd2ViMy1hZGFwdGVyL2V0aF9mZWVIaXN0b3J5LmpzP2MyNmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0dGVycyB9IGZyb20gXCJ3ZWIzLWNvcmUtaGVscGVyc1wiO1xuaW1wb3J0IHsgdG9OdW1iZXIgfSBmcm9tIFwid2ViMy11dGlsc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoRXRoRmVlSGlzdG9yeU1ldGhvZCh3ZWIzKSB7XG4gICAgd2ViMy5ldGguY3VzdG9tUlBDKHtcbiAgICAgICAgbmFtZTogXCJnZXRGZWVIaXN0b3J5XCIsXG4gICAgICAgIGNhbGw6IFwiZXRoX2ZlZUhpc3RvcnlcIixcbiAgICAgICAgcGFyYW1zOiAzLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW1xuICAgICAgICAgICAgdG9OdW1iZXIsXG4gICAgICAgICAgICBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9LFxuICAgICAgICBdLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoX2ZlZUhpc3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_feeHistory.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_maxPriorityFeePerGas.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_maxPriorityFeePerGas.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"patchEthMaxPriorityFeePerGasMethod\": function() { return /* binding */ patchEthMaxPriorityFeePerGasMethod; }\n/* harmony export */ });\nfunction patchEthMaxPriorityFeePerGasMethod(web3) {\n    web3.eth.customRPC({\n        name: \"getMaxPriorityFeePerGas\",\n        call: \"eth_maxPriorityFeePerGas\",\n        params: 0,\n    });\n}\n//# sourceMappingURL=eth_maxPriorityFeePerGas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvZXRoX21heFByaW9yaXR5RmVlUGVyR2FzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvZGlzdC9lc20vd2ViMy1hZGFwdGVyL2V0aF9tYXhQcmlvcml0eUZlZVBlckdhcy5qcz9iY2U0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwYXRjaEV0aE1heFByaW9yaXR5RmVlUGVyR2FzTWV0aG9kKHdlYjMpIHtcbiAgICB3ZWIzLmV0aC5jdXN0b21SUEMoe1xuICAgICAgICBuYW1lOiBcImdldE1heFByaW9yaXR5RmVlUGVyR2FzXCIsXG4gICAgICAgIGNhbGw6IFwiZXRoX21heFByaW9yaXR5RmVlUGVyR2FzXCIsXG4gICAgICAgIHBhcmFtczogMCxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aF9tYXhQcmlvcml0eUZlZVBlckdhcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/eth_maxPriorityFeePerGas.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/httpProvider.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/httpProvider.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeAlchemyHttpProvider\": function() { return /* binding */ makeAlchemyHttpProvider; }\n/* harmony export */ });\n/* harmony import */ var _util_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/promises */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js\");\n\n/**\n * Returns a \"provider\" which can be passed to the Web3 constructor.\n */\nfunction makeAlchemyHttpProvider(sendPayload) {\n    function send(payload, callback) {\n        (0,_util_promises__WEBPACK_IMPORTED_MODULE_0__.callWhenDone)(sendPayload(payload), callback);\n    }\n    return { send: send };\n}\n//# sourceMappingURL=httpProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvaHR0cFByb3ZpZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLDREQUFZO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvZGlzdC9lc20vd2ViMy1hZGFwdGVyL2h0dHBQcm92aWRlci5qcz8xZTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNhbGxXaGVuRG9uZSB9IGZyb20gXCIuLi91dGlsL3Byb21pc2VzXCI7XG4vKipcbiAqIFJldHVybnMgYSBcInByb3ZpZGVyXCIgd2hpY2ggY2FuIGJlIHBhc3NlZCB0byB0aGUgV2ViMyBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBbGNoZW15SHR0cFByb3ZpZGVyKHNlbmRQYXlsb2FkKSB7XG4gICAgZnVuY3Rpb24gc2VuZChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsV2hlbkRvbmUoc2VuZFBheWxvYWQocGF5bG9hZCksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VuZDogc2VuZCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cFByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/httpProvider.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/sendPayload.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/sendPayload.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makePayloadSender\": function() { return /* binding */ makePayloadSender; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var assert_never__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert-never */ \"../../node_modules/assert-never/index.js\");\n/* harmony import */ var _util_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/promises */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js\");\n\n\n\nvar ALCHEMY_DISALLOWED_METHODS = [\n    \"eth_accounts\",\n    \"eth_sendTransaction\",\n    \"eth_sign\",\n    \"eth_signTypedData_v3\",\n    \"eth_signTypedData\",\n    \"personal_sign\",\n];\nfunction makePayloadSender(alchemySend, config) {\n    var currentWriteProvider = config.writeProvider;\n    var sendPayload = function (payload) {\n        var disallowedMethod = getDisallowedMethod(payload);\n        if (!disallowedMethod) {\n            try {\n                return sendWithRetries(payload, alchemySend, config);\n            }\n            catch (alchemyError) {\n                // Fallback to write provider, but if both fail throw the error from\n                // Alchemy.\n                if (!currentWriteProvider) {\n                    throw alchemyError;\n                }\n                try {\n                    return sendWithProvider(currentWriteProvider, payload);\n                }\n                catch (_a) {\n                    throw alchemyError;\n                }\n            }\n        }\n        else {\n            if (!currentWriteProvider) {\n                throw new Error(\"No provider available for method \\\"\" + disallowedMethod + \"\\\"\");\n            }\n            return sendWithProvider(currentWriteProvider, payload);\n        }\n    };\n    function setWriteProvider(writeProvider) {\n        currentWriteProvider = writeProvider !== null && writeProvider !== void 0 ? writeProvider : null;\n    }\n    return { sendPayload: sendPayload, setWriteProvider: setWriteProvider };\n}\nfunction sendWithProvider(provider, payload) {\n    var anyProvider = provider;\n    var sendMethod = (anyProvider.sendAsync\n        ? anyProvider.sendAsync\n        : anyProvider.send).bind(anyProvider);\n    return (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.promisify)(function (callback) { return sendMethod(payload, callback); });\n}\nfunction getDisallowedMethod(payload) {\n    var payloads = Array.isArray(payload) ? payload : [payload];\n    var disallowedRequest = payloads.find(function (p) { return ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0; }) ||\n        undefined;\n    return disallowedRequest && disallowedRequest.method;\n}\nfunction sendWithRetries(payload, alchemySend, _a) {\n    var maxRetries = _a.maxRetries, retryInterval = _a.retryInterval, retryJitter = _a.retryJitter;\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {\n        var i, result, status_1, message, statusString;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    i = 0;\n                    _b.label = 1;\n                case 1:\n                    if (!(i < maxRetries + 1)) return [3 /*break*/, 5];\n                    return [4 /*yield*/, alchemySend(payload)];\n                case 2:\n                    result = _b.sent();\n                    switch (result.type) {\n                        case \"jsonrpc\":\n                            return [2 /*return*/, result.response];\n                        case \"rateLimit\":\n                            break;\n                        case \"networkError\": {\n                            status_1 = result.status, message = result.message;\n                            statusString = status_1 !== 0 ? \"(\" + status_1 + \") \" : \"\";\n                            throw new Error(statusString + \" \" + message);\n                        }\n                        default:\n                            return [2 /*return*/, (0,assert_never__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(result)];\n                    }\n                    return [4 /*yield*/, (0,_util_promises__WEBPACK_IMPORTED_MODULE_1__.delay)(retryInterval + ((retryJitter * Math.random()) | 0))];\n                case 3:\n                    _b.sent();\n                    _b.label = 4;\n                case 4:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 5: throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n            }\n        });\n    });\n}\n//# sourceMappingURL=sendPayload.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvc2VuZFBheWxvYWQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQztBQUNSO0FBQ2E7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5REFBUyx1QkFBdUIsdUNBQXVDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyREFBMkQ7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQVM7QUFDcEI7QUFDQSxlQUFlLGtEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0RBQVc7QUFDN0Q7QUFDQSx5Q0FBeUMscURBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvc2VuZFBheWxvYWQuanM/MTZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgYXNzZXJ0TmV2ZXIgZnJvbSBcImFzc2VydC1uZXZlclwiO1xuaW1wb3J0IHsgZGVsYXksIHByb21pc2lmeSB9IGZyb20gXCIuLi91dGlsL3Byb21pc2VzXCI7XG52YXIgQUxDSEVNWV9ESVNBTExPV0VEX01FVEhPRFMgPSBbXG4gICAgXCJldGhfYWNjb3VudHNcIixcbiAgICBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIixcbiAgICBcImV0aF9zaWduXCIsXG4gICAgXCJldGhfc2lnblR5cGVkRGF0YV92M1wiLFxuICAgIFwiZXRoX3NpZ25UeXBlZERhdGFcIixcbiAgICBcInBlcnNvbmFsX3NpZ25cIixcbl07XG5leHBvcnQgZnVuY3Rpb24gbWFrZVBheWxvYWRTZW5kZXIoYWxjaGVteVNlbmQsIGNvbmZpZykge1xuICAgIHZhciBjdXJyZW50V3JpdGVQcm92aWRlciA9IGNvbmZpZy53cml0ZVByb3ZpZGVyO1xuICAgIHZhciBzZW5kUGF5bG9hZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBkaXNhbGxvd2VkTWV0aG9kID0gZ2V0RGlzYWxsb3dlZE1ldGhvZChwYXlsb2FkKTtcbiAgICAgICAgaWYgKCFkaXNhbGxvd2VkTWV0aG9kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kV2l0aFJldHJpZXMocGF5bG9hZCwgYWxjaGVteVNlbmQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoYWxjaGVteUVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gd3JpdGUgcHJvdmlkZXIsIGJ1dCBpZiBib3RoIGZhaWwgdGhyb3cgdGhlIGVycm9yIGZyb21cbiAgICAgICAgICAgICAgICAvLyBBbGNoZW15LlxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFdyaXRlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYWxjaGVteUVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFdpdGhQcm92aWRlcihjdXJyZW50V3JpdGVQcm92aWRlciwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBhbGNoZW15RXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50V3JpdGVQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb3ZpZGVyIGF2YWlsYWJsZSBmb3IgbWV0aG9kIFxcXCJcIiArIGRpc2FsbG93ZWRNZXRob2QgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VuZFdpdGhQcm92aWRlcihjdXJyZW50V3JpdGVQcm92aWRlciwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNldFdyaXRlUHJvdmlkZXIod3JpdGVQcm92aWRlcikge1xuICAgICAgICBjdXJyZW50V3JpdGVQcm92aWRlciA9IHdyaXRlUHJvdmlkZXIgIT09IG51bGwgJiYgd3JpdGVQcm92aWRlciAhPT0gdm9pZCAwID8gd3JpdGVQcm92aWRlciA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHNlbmRQYXlsb2FkOiBzZW5kUGF5bG9hZCwgc2V0V3JpdGVQcm92aWRlcjogc2V0V3JpdGVQcm92aWRlciB9O1xufVxuZnVuY3Rpb24gc2VuZFdpdGhQcm92aWRlcihwcm92aWRlciwgcGF5bG9hZCkge1xuICAgIHZhciBhbnlQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHZhciBzZW5kTWV0aG9kID0gKGFueVByb3ZpZGVyLnNlbmRBc3luY1xuICAgICAgICA/IGFueVByb3ZpZGVyLnNlbmRBc3luY1xuICAgICAgICA6IGFueVByb3ZpZGVyLnNlbmQpLmJpbmQoYW55UHJvdmlkZXIpO1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBzZW5kTWV0aG9kKHBheWxvYWQsIGNhbGxiYWNrKTsgfSk7XG59XG5mdW5jdGlvbiBnZXREaXNhbGxvd2VkTWV0aG9kKHBheWxvYWQpIHtcbiAgICB2YXIgcGF5bG9hZHMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICB2YXIgZGlzYWxsb3dlZFJlcXVlc3QgPSBwYXlsb2Fkcy5maW5kKGZ1bmN0aW9uIChwKSB7IHJldHVybiBBTENIRU1ZX0RJU0FMTE9XRURfTUVUSE9EUy5pbmRleE9mKHAubWV0aG9kKSA+PSAwOyB9KSB8fFxuICAgICAgICB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRpc2FsbG93ZWRSZXF1ZXN0ICYmIGRpc2FsbG93ZWRSZXF1ZXN0Lm1ldGhvZDtcbn1cbmZ1bmN0aW9uIHNlbmRXaXRoUmV0cmllcyhwYXlsb2FkLCBhbGNoZW15U2VuZCwgX2EpIHtcbiAgICB2YXIgbWF4UmV0cmllcyA9IF9hLm1heFJldHJpZXMsIHJldHJ5SW50ZXJ2YWwgPSBfYS5yZXRyeUludGVydmFsLCByZXRyeUppdHRlciA9IF9hLnJldHJ5Sml0dGVyO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIHJlc3VsdCwgc3RhdHVzXzEsIG1lc3NhZ2UsIHN0YXR1c1N0cmluZztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBtYXhSZXRyaWVzICsgMSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhbGNoZW15U2VuZChwYXlsb2FkKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJqc29ucnBjXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5yZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmF0ZUxpbWl0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmV0d29ya0Vycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9IHJlc3VsdC5zdGF0dXMsIG1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNTdHJpbmcgPSBzdGF0dXNfMSAhPT0gMCA/IFwiKFwiICsgc3RhdHVzXzEgKyBcIikgXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdGF0dXNTdHJpbmcgKyBcIiBcIiArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYXNzZXJ0TmV2ZXIocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGVsYXkocmV0cnlJbnRlcnZhbCArICgocmV0cnlKaXR0ZXIgKiBNYXRoLnJhbmRvbSgpKSB8IDApKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiB0aHJvdyBuZXcgRXJyb3IoXCJSYXRlIGxpbWl0ZWQgZm9yIFwiICsgKG1heFJldHJpZXMgKyAxKSArIFwiIGNvbnNlY3V0aXZlIGF0dGVtcHRzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW5kUGF5bG9hZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/sendPayload.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/webSocketProvider.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/webSocketProvider.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AlchemyWebSocketProvider\": function() { return /* binding */ AlchemyWebSocketProvider; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"../../node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _subscriptions_subscriptionBackfill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../subscriptions/subscriptionBackfill */ \"../../node_modules/@alch/alchemy-web3/dist/esm/subscriptions/subscriptionBackfill.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ \"../../node_modules/@alch/alchemy-web3/dist/esm/types.js\");\n/* harmony import */ var _util_hex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/hex */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/hex.js\");\n/* harmony import */ var _util_jsonRpc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/jsonRpc */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/jsonRpc.js\");\n/* harmony import */ var _util_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/promises */ \"../../node_modules/@alch/alchemy-web3/dist/esm/util/promises.js\");\n\n\n\n\n\n\n\nvar HEARTBEAT_INTERVAL = 30000;\nvar HEARTBEAT_WAIT_TIME = 10000;\nvar BACKFILL_TIMEOUT = 60000;\nvar BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nvar RETAINED_EVENT_BLOCK_COUNT = 10;\nvar AlchemyWebSocketProvider = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(AlchemyWebSocketProvider, _super);\n    function AlchemyWebSocketProvider(ws, sendPayload, senders) {\n        var _this = _super.call(this) || this;\n        _this.ws = ws;\n        _this.sendPayload = sendPayload;\n        _this.senders = senders;\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\n        // create new ones to replace them, but we want to create the illusion that\n        // the original subscriptions persist. Thus, maintain a mapping from the\n        // \"virtual\" subscription ids which are visible to the consumer to the\n        // \"physical\" subscription ids of the actual connections. This terminology is\n        // borrowed from virtual and physical memory, which has a similar mapping.\n        _this.virtualSubscriptionsById = new Map();\n        _this.virtualIdsByPhysicalId = new Map();\n        _this.cancelBackfill = noop;\n        _this.startHeartbeat = function () {\n            if (_this.heartbeatIntervalId != null) {\n                return;\n            }\n            _this.heartbeatIntervalId = setInterval(function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(_this, void 0, void 0, function () {\n                var _a;\n                return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__generator)(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _b.trys.push([0, 2, , 3]);\n                            return [4 /*yield*/, (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.withTimeout)(this.senders.send(\"net_version\"), HEARTBEAT_WAIT_TIME)];\n                        case 1:\n                            _b.sent();\n                            return [3 /*break*/, 3];\n                        case 2:\n                            _a = _b.sent();\n                            this.ws.reconnect();\n                            return [3 /*break*/, 3];\n                        case 3: return [2 /*return*/];\n                    }\n                });\n            }); }, HEARTBEAT_INTERVAL);\n        };\n        _this.stopHeartbeatAndBackfill = function () {\n            if (_this.heartbeatIntervalId != null) {\n                clearInterval(_this.heartbeatIntervalId);\n                _this.heartbeatIntervalId = undefined;\n            }\n            _this.cancelBackfill();\n        };\n        _this.handleMessage = function (event) {\n            var message = JSON.parse(event.data);\n            if (!(0,_types__WEBPACK_IMPORTED_MODULE_3__.isSubscriptionEvent)(message)) {\n                return;\n            }\n            var physicalId = message.params.subscription;\n            var virtualId = _this.virtualIdsByPhysicalId.get(physicalId);\n            if (!virtualId) {\n                return;\n            }\n            var subscription = _this.virtualSubscriptionsById.get(virtualId);\n            if (subscription.method !== \"eth_subscribe\") {\n                _this.emitGenericEvent(virtualId, message.params.result);\n                return;\n            }\n            switch (subscription.params[0]) {\n                case \"newHeads\": {\n                    var newHeadsSubscription = subscription;\n                    var newHeadsMessage = message;\n                    var isBackfilling = newHeadsSubscription.isBackfilling, backfillBuffer = newHeadsSubscription.backfillBuffer;\n                    var result = newHeadsMessage.params.result;\n                    if (isBackfilling) {\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\n                    }\n                    else {\n                        _this.emitNewHeadsEvent(virtualId, result);\n                    }\n                    break;\n                }\n                case \"logs\": {\n                    var logsSubscription = subscription;\n                    var logsMessage = message;\n                    var isBackfilling = logsSubscription.isBackfilling, backfillBuffer = logsSubscription.backfillBuffer;\n                    var result = logsMessage.params.result;\n                    if (isBackfilling) {\n                        addToLogsEventsBuffer(backfillBuffer, result);\n                    }\n                    else {\n                        _this.emitLogsEvent(virtualId, result);\n                    }\n                    break;\n                }\n                default:\n                    _this.emitGenericEvent(virtualId, message.params.result);\n            }\n        };\n        _this.handleReopen = function () {\n            var e_1, _a;\n            _this.virtualIdsByPhysicalId.clear();\n            var _b = (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.makeCancelToken)(), cancel = _b.cancel, isCancelled = _b.isCancelled;\n            _this.cancelBackfill = cancel;\n            var _loop_1 = function (subscription) {\n                (function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(_this, void 0, void 0, function () {\n                    var error_1;\n                    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__generator)(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                _a.trys.push([0, 2, , 3]);\n                                return [4 /*yield*/, this.resubscribeAndBackfill(isCancelled, subscription)];\n                            case 1:\n                                _a.sent();\n                                return [3 /*break*/, 3];\n                            case 2:\n                                error_1 = _a.sent();\n                                if (!isCancelled()) {\n                                    console.error(\"Error while backfilling \\\"\" + subscription.params[0] + \"\\\" subscription. Some events may be missing.\", error_1);\n                                }\n                                return [3 /*break*/, 3];\n                            case 3: return [2 /*return*/];\n                        }\n                    });\n                }); })();\n            };\n            try {\n                for (var _c = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(_this.virtualSubscriptionsById.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var subscription = _d.value;\n                    _loop_1(subscription);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            _this.startHeartbeat();\n        };\n        _this.backfiller = (0,_subscriptions_subscriptionBackfill__WEBPACK_IMPORTED_MODULE_4__.makeBackfiller)(senders);\n        _this.addSocketListeners();\n        _this.startHeartbeat();\n        return _this;\n    }\n    AlchemyWebSocketProvider.prototype.send = function (request, callback) {\n        if (isSubscribeRequest(request)) {\n            var id = request.id;\n            if (id === undefined) {\n                // The JSON-RPC spec says to return nothing if there is no request id.\n                return;\n            }\n            (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.callWhenDone)(this.subscribe(request), callback);\n            return;\n        }\n        if (isUnsubscribeRequest(request)) {\n            (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.callWhenDone)(this.unsubscribe(request), callback);\n            return;\n        }\n        (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.callWhenDone)(this.sendPayload(request), callback);\n    };\n    AlchemyWebSocketProvider.prototype.supportsSubscriptions = function () {\n        return true;\n    };\n    AlchemyWebSocketProvider.prototype.disconnect = function (code, reason) {\n        this.removeSocketListeners();\n        this.removeAllListeners();\n        this.stopHeartbeatAndBackfill();\n        this.ws.close(code, reason);\n    };\n    AlchemyWebSocketProvider.prototype.connect = function () {\n        // No-op. We're already connected when passed a websocket in the\n        // constructor.\n    };\n    AlchemyWebSocketProvider.prototype.reset = function () {\n        // No-op.\n    };\n    AlchemyWebSocketProvider.prototype.reconnect = function () {\n        // No-op. This isn't called anywhere.\n    };\n    AlchemyWebSocketProvider.prototype.subscribe = function (request) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function () {\n            var method, _a, params, startingBlockNumber, response, id;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__generator)(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        method = request.method, _a = request.params, params = _a === void 0 ? [] : _a;\n                        return [4 /*yield*/, this.getBlockNumber()];\n                    case 1:\n                        startingBlockNumber = _b.sent();\n                        return [4 /*yield*/, this.sendPayload(request)];\n                    case 2:\n                        response = _b.sent();\n                        id = response.result;\n                        this.virtualSubscriptionsById.set(id, {\n                            method: method,\n                            params: params,\n                            startingBlockNumber: startingBlockNumber,\n                            virtualId: id,\n                            physicalId: id,\n                            sentEvents: [],\n                            isBackfilling: false,\n                            backfillBuffer: [],\n                        });\n                        this.virtualIdsByPhysicalId.set(id, id);\n                        return [2 /*return*/, (0,_util_jsonRpc__WEBPACK_IMPORTED_MODULE_5__.makeResponse)(request.id, id)];\n                }\n            });\n        });\n    };\n    AlchemyWebSocketProvider.prototype.unsubscribe = function (request) {\n        var _a;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function () {\n            var subscriptionId, virtualSubscription, physicalId, physicalRequest;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__generator)(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        subscriptionId = (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n                        virtualSubscription = this.virtualSubscriptionsById.get(subscriptionId);\n                        if (!virtualSubscription) {\n                            return [2 /*return*/, (0,_util_jsonRpc__WEBPACK_IMPORTED_MODULE_5__.makeResponse)(request.id, false)];\n                        }\n                        physicalId = virtualSubscription.physicalId;\n                        physicalRequest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, request), { params: [physicalId] });\n                        return [4 /*yield*/, this.sendPayload(physicalRequest)];\n                    case 1:\n                        _b.sent();\n                        this.virtualSubscriptionsById.delete(subscriptionId);\n                        this.virtualIdsByPhysicalId.delete(physicalId);\n                        return [2 /*return*/, (0,_util_jsonRpc__WEBPACK_IMPORTED_MODULE_5__.makeResponse)(request.id, true)];\n                }\n            });\n        });\n    };\n    AlchemyWebSocketProvider.prototype.addSocketListeners = function () {\n        this.ws.addEventListener(\"message\", this.handleMessage);\n        this.ws.addEventListener(\"reopen\", this.handleReopen);\n        this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    };\n    AlchemyWebSocketProvider.prototype.removeSocketListeners = function () {\n        this.ws.removeEventListener(\"message\", this.handleMessage);\n        this.ws.removeEventListener(\"reopen\", this.handleReopen);\n        this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    };\n    AlchemyWebSocketProvider.prototype.resubscribeAndBackfill = function (isCancelled, subscription) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function () {\n            var virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber, physicalId, _a, backfillEvents, events, filter_1, backfillEvents, events;\n            var _this = this;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__generator)(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        virtualId = subscription.virtualId, method = subscription.method, params = subscription.params, sentEvents = subscription.sentEvents, backfillBuffer = subscription.backfillBuffer, startingBlockNumber = subscription.startingBlockNumber;\n                        subscription.isBackfilling = true;\n                        backfillBuffer.length = 0;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, , 9, 10]);\n                        return [4 /*yield*/, this.senders.send(method, params)];\n                    case 2:\n                        physicalId = _b.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.throwIfCancelled)(isCancelled);\n                        subscription.physicalId = physicalId;\n                        this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n                        _a = params[0];\n                        switch (_a) {\n                            case \"newHeads\": return [3 /*break*/, 3];\n                            case \"logs\": return [3 /*break*/, 5];\n                        }\n                        return [3 /*break*/, 7];\n                    case 3: return [4 /*yield*/, (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.withBackoffRetries)(function () {\n                            return (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.withTimeout)(_this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n                        }, BACKFILL_RETRIES, function () { return !isCancelled(); })];\n                    case 4:\n                        backfillEvents = _b.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.throwIfCancelled)(isCancelled);\n                        events = (0,_subscriptions_subscriptionBackfill__WEBPACK_IMPORTED_MODULE_4__.dedupeNewHeads)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(backfillEvents)), (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(backfillBuffer)));\n                        events.forEach(function (event) { return _this.emitNewHeadsEvent(virtualId, event); });\n                        return [3 /*break*/, 8];\n                    case 5:\n                        filter_1 = params[1] || {};\n                        return [4 /*yield*/, (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.withBackoffRetries)(function () {\n                                return (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.withTimeout)(_this.backfiller.getLogsBackfill(isCancelled, filter_1, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n                            }, BACKFILL_RETRIES, function () { return !isCancelled(); })];\n                    case 6:\n                        backfillEvents = _b.sent();\n                        (0,_util_promises__WEBPACK_IMPORTED_MODULE_2__.throwIfCancelled)(isCancelled);\n                        events = (0,_subscriptions_subscriptionBackfill__WEBPACK_IMPORTED_MODULE_4__.dedupeLogs)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(backfillEvents)), (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(backfillBuffer)));\n                        events.forEach(function (event) { return _this.emitLogsEvent(virtualId, event); });\n                        return [3 /*break*/, 8];\n                    case 7: return [3 /*break*/, 8];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        subscription.isBackfilling = false;\n                        backfillBuffer.length = 0;\n                        return [7 /*endfinally*/];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AlchemyWebSocketProvider.prototype.getBlockNumber = function () {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function () {\n            var blockNumberHex;\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__generator)(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.senders.send(\"eth_blockNumber\")];\n                    case 1:\n                        blockNumberHex = _a.sent();\n                        return [2 /*return*/, (0,_util_hex__WEBPACK_IMPORTED_MODULE_6__.fromHex)(blockNumberHex)];\n                }\n            });\n        });\n    };\n    AlchemyWebSocketProvider.prototype.emitNewHeadsEvent = function (virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n    };\n    AlchemyWebSocketProvider.prototype.emitLogsEvent = function (virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n    };\n    /**\n     * Emits an event to consumers, but also remembers it in its subscriptions's\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n     * and needs to be reconnected.\n     */\n    AlchemyWebSocketProvider.prototype.emitAndRememberEvent = function (virtualId, result, getBlockNumber) {\n        var subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) {\n            return;\n        }\n        // Web3 modifies these event objects once we pass them on (changing hex\n        // numbers to numbers). We want the original event, so make a defensive\n        // copy.\n        addToPastEventsBuffer(subscription.sentEvents, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, result), getBlockNumber);\n        this.emitGenericEvent(virtualId, result);\n    };\n    AlchemyWebSocketProvider.prototype.emitGenericEvent = function (virtualId, result) {\n        var event = {\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: {\n                subscription: virtualId,\n                result: result,\n            },\n        };\n        this.emit(\"data\", event);\n    };\n    return AlchemyWebSocketProvider;\n}((eventemitter3__WEBPACK_IMPORTED_MODULE_0___default())));\n\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n    var currentBlockNumber = getBlockNumber(event);\n    // Find first index of an event recent enough to retain, then drop everything\n    // at a lower index.\n    var firstGoodIndex = pastEvents.findIndex(function (e) { return getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT; });\n    if (firstGoodIndex === -1) {\n        pastEvents.length = 0;\n    }\n    else {\n        pastEvents.splice(0, firstGoodIndex);\n    }\n    pastEvents.push(event);\n}\nfunction isSubscribeRequest(request) {\n    return !Array.isArray(request) && request.method === \"eth_subscribe\";\n}\nfunction isUnsubscribeRequest(request) {\n    return !Array.isArray(request) && request.method === \"eth_unsubscribe\";\n}\nfunction getNewHeadsBlockNumber(event) {\n    return (0,_util_hex__WEBPACK_IMPORTED_MODULE_6__.fromHex)(event.number);\n}\nfunction getLogsBlockNumber(event) {\n    return (0,_util_hex__WEBPACK_IMPORTED_MODULE_6__.fromHex)(event.blockNumber);\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=webSocketProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvd2ViU29ja2V0UHJvdmlkZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQzVEO0FBQzJEO0FBQ3BEO0FBQ1Y7QUFDUztBQUNzRTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTyxnREFBUztBQUNsRjtBQUNBLHVCQUF1QixrREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMkRBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQWU7QUFDcEM7QUFDQTtBQUNBLCtCQUErQixPQUFPLGdEQUFTO0FBQy9DO0FBQ0EsMkJBQTJCLGtEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0EsOEJBQThCLCtDQUFRLDJEQUEyRCxVQUFVO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1GQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQVk7QUFDeEI7QUFDQTtBQUNBLFFBQVEsNERBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnREFBUztBQUN4QjtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDhDQUE4QywyREFBWTtBQUMxRDtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnREFBUztBQUN4QjtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJEQUFZO0FBQzlEO0FBQ0E7QUFDQSwwQ0FBMEMsK0NBQVEsQ0FBQywrQ0FBUSxHQUFHLGNBQWMsc0JBQXNCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkRBQVk7QUFDMUQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQVM7QUFDeEI7QUFDQTtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtFQUFrQjtBQUNuRSxtQ0FBbUMsMkRBQVc7QUFDOUMseUJBQXlCLGtDQUFrQyx3QkFBd0I7QUFDbkY7QUFDQTtBQUNBLHdCQUF3QixnRUFBZ0I7QUFDeEMsaUNBQWlDLG1GQUFjLENBQUMsb0RBQWEsQ0FBQyxvREFBYSxLQUFLLDZDQUFNLG1CQUFtQiw2Q0FBTTtBQUMvRywwREFBMEQsbURBQW1EO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrRUFBa0I7QUFDL0QsdUNBQXVDLDJEQUFXO0FBQ2xELDZCQUE2QixrQ0FBa0Msd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWdCO0FBQ3hDLGlDQUFpQywrRUFBVSxDQUFDLG9EQUFhLENBQUMsb0RBQWEsS0FBSyw2Q0FBTSxtQkFBbUIsNkNBQU07QUFDM0csMERBQTBELCtDQUErQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLGdEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtEQUFPO0FBQ3JEO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtDQUFRLEdBQUc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHNEQUFZO0FBQ3NCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNkVBQTZFO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQU87QUFDbEI7QUFDQTtBQUNBLFdBQVcsa0RBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9kaXN0L2VzbS93ZWIzLWFkYXB0ZXIvd2ViU29ja2V0UHJvdmlkZXIuanM/MjBjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yLCBfX3JlYWQsIF9fc3ByZWFkQXJyYXksIF9fdmFsdWVzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudGVtaXR0ZXIzXCI7XG5pbXBvcnQgeyBkZWR1cGVMb2dzLCBkZWR1cGVOZXdIZWFkcywgbWFrZUJhY2tmaWxsZXIsIH0gZnJvbSBcIi4uL3N1YnNjcmlwdGlvbnMvc3Vic2NyaXB0aW9uQmFja2ZpbGxcIjtcbmltcG9ydCB7IGlzU3Vic2NyaXB0aW9uRXZlbnQsIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBmcm9tSGV4IH0gZnJvbSBcIi4uL3V0aWwvaGV4XCI7XG5pbXBvcnQgeyBtYWtlUmVzcG9uc2UgfSBmcm9tIFwiLi4vdXRpbC9qc29uUnBjXCI7XG5pbXBvcnQgeyBjYWxsV2hlbkRvbmUsIG1ha2VDYW5jZWxUb2tlbiwgdGhyb3dJZkNhbmNlbGxlZCwgd2l0aEJhY2tvZmZSZXRyaWVzLCB3aXRoVGltZW91dCwgfSBmcm9tIFwiLi4vdXRpbC9wcm9taXNlc1wiO1xudmFyIEhFQVJUQkVBVF9JTlRFUlZBTCA9IDMwMDAwO1xudmFyIEhFQVJUQkVBVF9XQUlUX1RJTUUgPSAxMDAwMDtcbnZhciBCQUNLRklMTF9USU1FT1VUID0gNjAwMDA7XG52YXIgQkFDS0ZJTExfUkVUUklFUyA9IDU7XG4vKipcbiAqIFN1YnNjcmlwdGlvbnMgaGF2ZSBhIG1lbW9yeSBvZiByZWNlbnQgZXZlbnRzIHRoZXkgaGF2ZSBzZW50IHNvIHRoYXQgaW4gdGhlXG4gKiBldmVudCB0aGF0IHRoZXkgZGlzY29ubmVjdCBhbmQgbmVlZCB0byBiYWNrZmlsbCwgdGhleSBjYW4gZGV0ZWN0IHJlLW9yZ3MuXG4gKiBLZWVwIGEgYnVmZmVyIHRoYXQgZ29lcyBiYWNrIGF0IGxlYXN0IHRoZXNlIG1hbnkgYmxvY2tzLCB0aGUgbWF4aW11bSBhbW91bnRcbiAqIGF0IHdoaWNoIHdlIG1pZ2h0IGNvbmNlaXZhYmx5IHNlZSBhIHJlLW9yZy5cbiAqXG4gKiBOb3RlIHRoYXQgd2hpbGUgb3VyIGJ1ZmZlciBnb2VzIGJhY2sgdGhpcyBtYW55IGJsb2NrcywgaXQgbWF5IGNvbnRhaW4gbW9yZVxuICogdGhhbiB0aGlzIG1hbnkgZWxlbWVudHMsIHNpbmNlIGluIHRoZSBjYXNlIG9mIGxvZ3Mgc3Vic2NyaXB0aW9ucyBtb3JlIHRoYW5cbiAqIG9uZSBldmVudCBtYXkgYmUgZW1pdHRlZCBmb3IgYSBibG9jay5cbiAqL1xudmFyIFJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UID0gMTA7XG52YXIgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyKHdzLCBzZW5kUGF5bG9hZCwgc2VuZGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53cyA9IHdzO1xuICAgICAgICBfdGhpcy5zZW5kUGF5bG9hZCA9IHNlbmRQYXlsb2FkO1xuICAgICAgICBfdGhpcy5zZW5kZXJzID0gc2VuZGVycztcbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBXZWJTb2NrZXQgcmVjb25uZWN0aW9uLCBhbGwgc3Vic2NyaXB0aW9ucyBhcmUgbG9zdCBhbmQgd2VcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvbmVzIHRvIHJlcGxhY2UgdGhlbSwgYnV0IHdlIHdhbnQgdG8gY3JlYXRlIHRoZSBpbGx1c2lvbiB0aGF0XG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBzdWJzY3JpcHRpb25zIHBlcnNpc3QuIFRodXMsIG1haW50YWluIGEgbWFwcGluZyBmcm9tIHRoZVxuICAgICAgICAvLyBcInZpcnR1YWxcIiBzdWJzY3JpcHRpb24gaWRzIHdoaWNoIGFyZSB2aXNpYmxlIHRvIHRoZSBjb25zdW1lciB0byB0aGVcbiAgICAgICAgLy8gXCJwaHlzaWNhbFwiIHN1YnNjcmlwdGlvbiBpZHMgb2YgdGhlIGFjdHVhbCBjb25uZWN0aW9ucy4gVGhpcyB0ZXJtaW5vbG9neSBpc1xuICAgICAgICAvLyBib3Jyb3dlZCBmcm9tIHZpcnR1YWwgYW5kIHBoeXNpY2FsIG1lbW9yeSwgd2hpY2ggaGFzIGEgc2ltaWxhciBtYXBwaW5nLlxuICAgICAgICBfdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLmNhbmNlbEJhY2tmaWxsID0gbm9vcDtcbiAgICAgICAgX3RoaXMuc3RhcnRIZWFydGJlYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3aXRoVGltZW91dCh0aGlzLnNlbmRlcnMuc2VuZChcIm5ldF92ZXJzaW9uXCIpLCBIRUFSVEJFQVRfV0FJVF9USU1FKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3MucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7IH0sIEhFQVJUQkVBVF9JTlRFUlZBTCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5oZWFydGJlYXRJbnRlcnZhbElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKF90aGlzLmhlYXJ0YmVhdEludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jYW5jZWxCYWNrZmlsbCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoIWlzU3Vic2NyaXB0aW9uRXZlbnQobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGh5c2ljYWxJZCA9IG1lc3NhZ2UucGFyYW1zLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHZhciB2aXJ0dWFsSWQgPSBfdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLmdldChwaHlzaWNhbElkKTtcbiAgICAgICAgICAgIGlmICghdmlydHVhbElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQodmlydHVhbElkKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ubWV0aG9kICE9PSBcImV0aF9zdWJzY3JpYmVcIikge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXRHZW5lcmljRXZlbnQodmlydHVhbElkLCBtZXNzYWdlLnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uLnBhcmFtc1swXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJuZXdIZWFkc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdIZWFkc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0hlYWRzTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0JhY2tmaWxsaW5nID0gbmV3SGVhZHNTdWJzY3JpcHRpb24uaXNCYWNrZmlsbGluZywgYmFja2ZpbGxCdWZmZXIgPSBuZXdIZWFkc1N1YnNjcmlwdGlvbi5iYWNrZmlsbEJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ld0hlYWRzTWVzc2FnZS5wYXJhbXMucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYWNrZmlsbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9OZXdIZWFkc0V2ZW50c0J1ZmZlcihiYWNrZmlsbEJ1ZmZlciwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXROZXdIZWFkc0V2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImxvZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9nc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ3NNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQmFja2ZpbGxpbmcgPSBsb2dzU3Vic2NyaXB0aW9uLmlzQmFja2ZpbGxpbmcsIGJhY2tmaWxsQnVmZmVyID0gbG9nc1N1YnNjcmlwdGlvbi5iYWNrZmlsbEJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZ3NNZXNzYWdlLnBhcmFtcy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JhY2tmaWxsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0xvZ3NFdmVudHNCdWZmZXIoYmFja2ZpbGxCdWZmZXIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0TG9nc0V2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdEdlbmVyaWNFdmVudCh2aXJ0dWFsSWQsIG1lc3NhZ2UucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVJlb3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgX3RoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5jbGVhcigpO1xuICAgICAgICAgICAgdmFyIF9iID0gbWFrZUNhbmNlbFRva2VuKCksIGNhbmNlbCA9IF9iLmNhbmNlbCwgaXNDYW5jZWxsZWQgPSBfYi5pc0NhbmNlbGxlZDtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbEJhY2tmaWxsID0gY2FuY2VsO1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yXzE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzdWJzY3JpYmVBbmRCYWNrZmlsbChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgYmFja2ZpbGxpbmcgXFxcIlwiICsgc3Vic2NyaXB0aW9uLnBhcmFtc1swXSArIFwiXFxcIiBzdWJzY3JpcHRpb24uIFNvbWUgZXZlbnRzIG1heSBiZSBtaXNzaW5nLlwiLCBlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKF90aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC52YWx1ZXMoKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc3RhcnRIZWFydGJlYXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYmFja2ZpbGxlciA9IG1ha2VCYWNrZmlsbGVyKHNlbmRlcnMpO1xuICAgICAgICBfdGhpcy5hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgX3RoaXMuc3RhcnRIZWFydGJlYXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzU3Vic2NyaWJlUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgICAgICAgdmFyIGlkID0gcmVxdWVzdC5pZDtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIEpTT04tUlBDIHNwZWMgc2F5cyB0byByZXR1cm4gbm90aGluZyBpZiB0aGVyZSBpcyBubyByZXF1ZXN0IGlkLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxXaGVuRG9uZSh0aGlzLnN1YnNjcmliZShyZXF1ZXN0KSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vuc3Vic2NyaWJlUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgICAgICAgY2FsbFdoZW5Eb25lKHRoaXMudW5zdWJzY3JpYmUocmVxdWVzdCksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2hlbkRvbmUodGhpcy5zZW5kUGF5bG9hZChyZXF1ZXN0KSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLnJlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCgpO1xuICAgICAgICB0aGlzLndzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgfTtcbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5vLW9wLiBXZSdyZSBhbHJlYWR5IGNvbm5lY3RlZCB3aGVuIHBhc3NlZCBhIHdlYnNvY2tldCBpbiB0aGVcbiAgICAgICAgLy8gY29uc3RydWN0b3IuXG4gICAgfTtcbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOby1vcC5cbiAgICB9O1xuICAgIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOby1vcC4gVGhpcyBpc24ndCBjYWxsZWQgYW55d2hlcmUuXG4gICAgfTtcbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QsIF9hLCBwYXJhbXMsIHN0YXJ0aW5nQmxvY2tOdW1iZXIsIHJlc3BvbnNlLCBpZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kLCBfYSA9IHJlcXVlc3QucGFyYW1zLCBwYXJhbXMgPSBfYSA9PT0gdm9pZCAwID8gW10gOiBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0aW5nQmxvY2tOdW1iZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmRQYXlsb2FkKHJlcXVlc3QpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0aW5nQmxvY2tOdW1iZXI6IHN0YXJ0aW5nQmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlydHVhbElkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHlzaWNhbElkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW50RXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0JhY2tmaWxsaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZmlsbEJ1ZmZlcjogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5zZXQoaWQsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBtYWtlUmVzcG9uc2UocmVxdWVzdC5pZCwgaWQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSWQsIHZpcnR1YWxTdWJzY3JpcHRpb24sIHBoeXNpY2FsSWQsIHBoeXNpY2FsUmVxdWVzdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbklkID0gKF9hID0gcmVxdWVzdC5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpcnR1YWxTdWJzY3JpcHRpb24gPSB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQoc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXJ0dWFsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1ha2VSZXNwb25zZShyZXF1ZXN0LmlkLCBmYWxzZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxJZCA9IHZpcnR1YWxTdWJzY3JpcHRpb24ucGh5c2ljYWxJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoeXNpY2FsUmVxdWVzdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBwYXJhbXM6IFtwaHlzaWNhbElkXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VuZFBheWxvYWQocGh5c2ljYWxSZXF1ZXN0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmRlbGV0ZShzdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuZGVsZXRlKHBoeXNpY2FsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1ha2VSZXNwb25zZShyZXF1ZXN0LmlkLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5hZGRTb2NrZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud3MuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgdGhpcy53cy5hZGRFdmVudExpc3RlbmVyKFwicmVvcGVuXCIsIHRoaXMuaGFuZGxlUmVvcGVuKTtcbiAgICAgICAgdGhpcy53cy5hZGRFdmVudExpc3RlbmVyKFwiZG93blwiLCB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCk7XG4gICAgfTtcbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnJlbW92ZVNvY2tldExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53cy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICB0aGlzLndzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZW9wZW5cIiwgdGhpcy5oYW5kbGVSZW9wZW4pO1xuICAgICAgICB0aGlzLndzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkb3duXCIsIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsKTtcbiAgICB9O1xuICAgIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVzdWJzY3JpYmVBbmRCYWNrZmlsbCA9IGZ1bmN0aW9uIChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aXJ0dWFsSWQsIG1ldGhvZCwgcGFyYW1zLCBzZW50RXZlbnRzLCBiYWNrZmlsbEJ1ZmZlciwgc3RhcnRpbmdCbG9ja051bWJlciwgcGh5c2ljYWxJZCwgX2EsIGJhY2tmaWxsRXZlbnRzLCBldmVudHMsIGZpbHRlcl8xLCBiYWNrZmlsbEV2ZW50cywgZXZlbnRzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpcnR1YWxJZCA9IHN1YnNjcmlwdGlvbi52aXJ0dWFsSWQsIG1ldGhvZCA9IHN1YnNjcmlwdGlvbi5tZXRob2QsIHBhcmFtcyA9IHN1YnNjcmlwdGlvbi5wYXJhbXMsIHNlbnRFdmVudHMgPSBzdWJzY3JpcHRpb24uc2VudEV2ZW50cywgYmFja2ZpbGxCdWZmZXIgPSBzdWJzY3JpcHRpb24uYmFja2ZpbGxCdWZmZXIsIHN0YXJ0aW5nQmxvY2tOdW1iZXIgPSBzdWJzY3JpcHRpb24uc3RhcnRpbmdCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5pc0JhY2tmaWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgLCA5LCAxMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kZXJzLnNlbmQobWV0aG9kLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxJZCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnBoeXNpY2FsSWQgPSBwaHlzaWNhbElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLnNldChwaHlzaWNhbElkLCB2aXJ0dWFsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5ld0hlYWRzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsb2dzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgd2l0aEJhY2tvZmZSZXRyaWVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2l0aFRpbWVvdXQoX3RoaXMuYmFja2ZpbGxlci5nZXROZXdIZWFkc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBzZW50RXZlbnRzLCBzdGFydGluZ0Jsb2NrTnVtYmVyKSwgQkFDS0ZJTExfVElNRU9VVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBCQUNLRklMTF9SRVRSSUVTLCBmdW5jdGlvbiAoKSB7IHJldHVybiAhaXNDYW5jZWxsZWQoKTsgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZmlsbEV2ZW50cyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZGVkdXBlTmV3SGVhZHMoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYmFja2ZpbGxFdmVudHMpKSwgX19yZWFkKGJhY2tmaWxsQnVmZmVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5lbWl0TmV3SGVhZHNFdmVudCh2aXJ0dWFsSWQsIGV2ZW50KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyXzEgPSBwYXJhbXNbMV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3aXRoQmFja29mZlJldHJpZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2l0aFRpbWVvdXQoX3RoaXMuYmFja2ZpbGxlci5nZXRMb2dzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIGZpbHRlcl8xLCBzZW50RXZlbnRzLCBzdGFydGluZ0Jsb2NrTnVtYmVyKSwgQkFDS0ZJTExfVElNRU9VVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgQkFDS0ZJTExfUkVUUklFUywgZnVuY3Rpb24gKCkgeyByZXR1cm4gIWlzQ2FuY2VsbGVkKCk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2ZpbGxFdmVudHMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGRlZHVwZUxvZ3MoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYmFja2ZpbGxFdmVudHMpKSwgX19yZWFkKGJhY2tmaWxsQnVmZmVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5lbWl0TG9nc0V2ZW50KHZpcnR1YWxJZCwgZXZlbnQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzQmFja2ZpbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5nZXRCbG9ja051bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVySGV4O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmRlcnMuc2VuZChcImV0aF9ibG9ja051bWJlclwiKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVySGV4ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21IZXgoYmxvY2tOdW1iZXJIZXgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmVtaXROZXdIZWFkc0V2ZW50ID0gZnVuY3Rpb24gKHZpcnR1YWxJZCwgcmVzdWx0KSB7XG4gICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xuICAgIH07XG4gICAgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5lbWl0TG9nc0V2ZW50ID0gZnVuY3Rpb24gKHZpcnR1YWxJZCwgcmVzdWx0KSB7XG4gICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldExvZ3NCbG9ja051bWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB0byBjb25zdW1lcnMsIGJ1dCBhbHNvIHJlbWVtYmVycyBpdCBpbiBpdHMgc3Vic2NyaXB0aW9ucydzXG4gICAgICogYHNlbnRFdmVudHNgIGJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBkZXRlY3QgcmUtb3JncyBpZiB0aGUgY29ubmVjdGlvbiBkcm9wc1xuICAgICAqIGFuZCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmVtaXRBbmRSZW1lbWJlckV2ZW50ID0gZnVuY3Rpb24gKHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2ViMyBtb2RpZmllcyB0aGVzZSBldmVudCBvYmplY3RzIG9uY2Ugd2UgcGFzcyB0aGVtIG9uIChjaGFuZ2luZyBoZXhcbiAgICAgICAgLy8gbnVtYmVycyB0byBudW1iZXJzKS4gV2Ugd2FudCB0aGUgb3JpZ2luYWwgZXZlbnQsIHNvIG1ha2UgYSBkZWZlbnNpdmVcbiAgICAgICAgLy8gY29weS5cbiAgICAgICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHN1YnNjcmlwdGlvbi5zZW50RXZlbnRzLCBfX2Fzc2lnbih7fSwgcmVzdWx0KSwgZ2V0QmxvY2tOdW1iZXIpO1xuICAgICAgICB0aGlzLmVtaXRHZW5lcmljRXZlbnQodmlydHVhbElkLCByZXN1bHQpO1xuICAgIH07XG4gICAgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5lbWl0R2VuZXJpY0V2ZW50ID0gZnVuY3Rpb24gKHZpcnR1YWxJZCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3N1YnNjcmlwdGlvblwiLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiB2aXJ0dWFsSWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGV2ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXI7XG59KEV2ZW50RW1pdHRlcikpO1xuZXhwb3J0IHsgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIH07XG5mdW5jdGlvbiBhZGRUb05ld0hlYWRzRXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50KSB7XG4gICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGFkZFRvTG9nc0V2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCkge1xuICAgIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcbn1cbi8qKlxuICogQWRkcyBhIG5ldyBldmVudCB0byBhbiBhcnJheSBvZiBldmVudHMsIGV2aWN0aW5nIGFueSBldmVudHMgd2hpY2hcbiAqIGFyZSBzbyBvbGQgdGhhdCB0aGV5IHdpbGwgbm8gbG9uZ2VyIGZlYXNpYmx5IGJlIHBhcnQgb2YgYSByZW9yZy5cbiAqL1xuZnVuY3Rpb24gYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXRCbG9ja051bWJlcikge1xuICAgIHZhciBjdXJyZW50QmxvY2tOdW1iZXIgPSBnZXRCbG9ja051bWJlcihldmVudCk7XG4gICAgLy8gRmluZCBmaXJzdCBpbmRleCBvZiBhbiBldmVudCByZWNlbnQgZW5vdWdoIHRvIHJldGFpbiwgdGhlbiBkcm9wIGV2ZXJ5dGhpbmdcbiAgICAvLyBhdCBhIGxvd2VyIGluZGV4LlxuICAgIHZhciBmaXJzdEdvb2RJbmRleCA9IHBhc3RFdmVudHMuZmluZEluZGV4KGZ1bmN0aW9uIChlKSB7IHJldHVybiBnZXRCbG9ja051bWJlcihlKSA+IGN1cnJlbnRCbG9ja051bWJlciAtIFJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UOyB9KTtcbiAgICBpZiAoZmlyc3RHb29kSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHBhc3RFdmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhc3RFdmVudHMuc3BsaWNlKDAsIGZpcnN0R29vZEluZGV4KTtcbiAgICB9XG4gICAgcGFzdEV2ZW50cy5wdXNoKGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGlzU3Vic2NyaWJlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHJlcXVlc3QpICYmIHJlcXVlc3QubWV0aG9kID09PSBcImV0aF9zdWJzY3JpYmVcIjtcbn1cbmZ1bmN0aW9uIGlzVW5zdWJzY3JpYmVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocmVxdWVzdCkgJiYgcmVxdWVzdC5tZXRob2QgPT09IFwiZXRoX3Vuc3Vic2NyaWJlXCI7XG59XG5mdW5jdGlvbiBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKGV2ZW50KSB7XG4gICAgcmV0dXJuIGZyb21IZXgoZXZlbnQubnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGdldExvZ3NCbG9ja051bWJlcihldmVudCkge1xuICAgIHJldHVybiBmcm9tSGV4KGV2ZW50LmJsb2NrTnVtYmVyKTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgLy8gTm90aGluZy5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYlNvY2tldFByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/dist/esm/web3-adapter/webSocketProvider.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/uuid/index.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/uuid/index.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var v1 = __webpack_require__(/*! ./v1 */ \"../../node_modules/@alch/alchemy-web3/node_modules/uuid/v1.js\");\nvar v4 = __webpack_require__(/*! ./v4 */ \"../../node_modules/@alch/alchemy-web3/node_modules/uuid/v4.js\");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvdXVpZC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTLG1CQUFPLENBQUMsMkVBQU07QUFDdkIsU0FBUyxtQkFBTyxDQUFDLDJFQUFNOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanM/OTNlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdjEgPSByZXF1aXJlKCcuL3YxJyk7XG52YXIgdjQgPSByZXF1aXJlKCcuL3Y0Jyk7XG5cbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/uuid/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************************************************/
/***/ (function(module) {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzP2NlZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/bytesToUuid.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/rng-browser.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************************************************/
/***/ (function(module) {

eval("// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzP2RiMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/rng-browser.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/uuid/v1.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/uuid/v1.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/bytesToUuid.js\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvdXVpZC92MS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsNkZBQVc7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMscUdBQW1COztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvdXVpZC92MS5qcz85ZDJkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG52YXIgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/uuid/v1.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/uuid/v4.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/uuid/v4.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"../../node_modules/@alch/alchemy-web3/node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvdXVpZC92NC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsNkZBQVc7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMscUdBQW1COztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvdXVpZC92NC5qcz80YzVlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/uuid/v4.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-bzz/lib/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-bzz/lib/index.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar swarm = __webpack_require__(/*! swarm-js */ \"../../node_modules/swarm-js/lib/api-browser.js\");\nvar Bzz = function Bzz(provider) {\n    this.givenProvider = Bzz.givenProvider;\n    if (provider && provider._requestManager) {\n        provider = provider.currentProvider;\n    }\n    // only allow file picker when in browser\n    if (typeof document !== 'undefined') {\n        this.pick = swarm.pick;\n    }\n    this.setProvider(provider);\n};\n// set default ethereum provider\n/* jshint ignore:start */\nBzz.givenProvider = null;\nif (typeof ethereum !== 'undefined' && ethereum.bzz) {\n    Bzz.givenProvider = ethereum.bzz;\n}\n/* jshint ignore:end */\nBzz.prototype.setProvider = function (provider) {\n    // is ethereum provider\n    if (!!provider && typeof provider === 'object' && typeof provider.bzz === 'string') {\n        provider = provider.bzz;\n        // is no string, set default\n    }\n    // else if(!_.isString(provider)) {\n    //      provider = 'http://swarm-gateways.net'; // default to gateway\n    // }\n    if (typeof provider === 'string') {\n        this.currentProvider = provider;\n    }\n    else {\n        this.currentProvider = null;\n        var noProviderError = new Error('No provider set, please set one using bzz.setProvider().');\n        this.download = this.upload = this.isAvailable = function () {\n            throw noProviderError;\n        };\n        return false;\n    }\n    // add functions\n    this.download = swarm.at(provider).download;\n    this.upload = swarm.at(provider).upload;\n    this.isAvailable = swarm.at(provider).isAvailable;\n    return true;\n};\nmodule.exports = Bzz;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ienovbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixZQUFZLG1CQUFPLENBQUMsZ0VBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtYnp6L2xpYi9pbmRleC5qcz9iNWZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGluZGV4LmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIHN3YXJtID0gcmVxdWlyZShcInN3YXJtLWpzXCIpO1xudmFyIEJ6eiA9IGZ1bmN0aW9uIEJ6eihwcm92aWRlcikge1xuICAgIHRoaXMuZ2l2ZW5Qcm92aWRlciA9IEJ6ei5naXZlblByb3ZpZGVyO1xuICAgIGlmIChwcm92aWRlciAmJiBwcm92aWRlci5fcmVxdWVzdE1hbmFnZXIpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlci5jdXJyZW50UHJvdmlkZXI7XG4gICAgfVxuICAgIC8vIG9ubHkgYWxsb3cgZmlsZSBwaWNrZXIgd2hlbiBpbiBicm93c2VyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5waWNrID0gc3dhcm0ucGljaztcbiAgICB9XG4gICAgdGhpcy5zZXRQcm92aWRlcihwcm92aWRlcik7XG59O1xuLy8gc2V0IGRlZmF1bHQgZXRoZXJldW0gcHJvdmlkZXJcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbkJ6ei5naXZlblByb3ZpZGVyID0gbnVsbDtcbmlmICh0eXBlb2YgZXRoZXJldW0gIT09ICd1bmRlZmluZWQnICYmIGV0aGVyZXVtLmJ6eikge1xuICAgIEJ6ei5naXZlblByb3ZpZGVyID0gZXRoZXJldW0uYnp6O1xufVxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbkJ6ei5wcm90b3R5cGUuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAvLyBpcyBldGhlcmV1bSBwcm92aWRlclxuICAgIGlmICghIXByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3ZpZGVyLmJ6eiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlci5ieno7XG4gICAgICAgIC8vIGlzIG5vIHN0cmluZywgc2V0IGRlZmF1bHRcbiAgICB9XG4gICAgLy8gZWxzZSBpZighXy5pc1N0cmluZyhwcm92aWRlcikpIHtcbiAgICAvLyAgICAgIHByb3ZpZGVyID0gJ2h0dHA6Ly9zd2FybS1nYXRld2F5cy5uZXQnOyAvLyBkZWZhdWx0IHRvIGdhdGV3YXlcbiAgICAvLyB9XG4gICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudFByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdmFyIG5vUHJvdmlkZXJFcnJvciA9IG5ldyBFcnJvcignTm8gcHJvdmlkZXIgc2V0LCBwbGVhc2Ugc2V0IG9uZSB1c2luZyBienouc2V0UHJvdmlkZXIoKS4nKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZCA9IHRoaXMudXBsb2FkID0gdGhpcy5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5vUHJvdmlkZXJFcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhZGQgZnVuY3Rpb25zXG4gICAgdGhpcy5kb3dubG9hZCA9IHN3YXJtLmF0KHByb3ZpZGVyKS5kb3dubG9hZDtcbiAgICB0aGlzLnVwbG9hZCA9IHN3YXJtLmF0KHByb3ZpZGVyKS51cGxvYWQ7XG4gICAgdGhpcy5pc0F2YWlsYWJsZSA9IHN3YXJtLmF0KHByb3ZpZGVyKS5pc0F2YWlsYWJsZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEJ6ejtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-bzz/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/errors.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/errors.js ***!
  \******************************************************************************************/
/***/ (function(module) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file errors.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nmodule.exports = {\n    ErrorResponse: function (result) {\n        var message = !!result && !!result.error && !!result.error.message ? result.error.message : JSON.stringify(result);\n        var data = (!!result.error && !!result.error.data) ? result.error.data : null;\n        var err = new Error('Returned error: ' + message);\n        err.data = data;\n        return err;\n    },\n    InvalidNumberOfParams: function (got, expected, method) {\n        return new Error('Invalid number of parameters for \"' + method + '\". Got ' + got + ' expected ' + expected + '!');\n    },\n    InvalidConnection: function (host, event) {\n        return this.ConnectionError('CONNECTION ERROR: Couldn\\'t connect to node ' + host + '.', event);\n    },\n    InvalidProvider: function () {\n        return new Error('Provider not set or invalid');\n    },\n    InvalidResponse: function (result) {\n        var message = !!result && !!result.error && !!result.error.message ? result.error.message : 'Invalid JSON RPC response: ' + JSON.stringify(result);\n        return new Error(message);\n    },\n    ConnectionTimeout: function (ms) {\n        return new Error('CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');\n    },\n    ConnectionNotOpenError: function (event) {\n        return this.ConnectionError('connection not open on send()', event);\n    },\n    ConnectionCloseError: function (event) {\n        if (typeof event === 'object' && event.code && event.reason) {\n            return this.ConnectionError('CONNECTION ERROR: The connection got closed with ' +\n                'the close code `' + event.code + '` and the following ' +\n                'reason string `' + event.reason + '`', event);\n        }\n        return new Error('CONNECTION ERROR: The connection closed unexpectedly');\n    },\n    MaxAttemptsReachedOnReconnectingError: function () {\n        return new Error('Maximum number of reconnect attempts reached!');\n    },\n    PendingRequestsOnReconnectingError: function () {\n        return new Error('CONNECTION ERROR: Provider started to reconnect before the response got received!');\n    },\n    ConnectionError: function (msg, event) {\n        const error = new Error(msg);\n        if (event) {\n            error.code = event.code;\n            error.reason = event.reason;\n        }\n        return error;\n    },\n    RevertInstructionError: function (reason, signature) {\n        var error = new Error('Your request got reverted with the following reason string: ' + reason);\n        error.reason = reason;\n        error.signature = signature;\n        return error;\n    },\n    TransactionRevertInstructionError: function (reason, signature, receipt) {\n        var error = new Error('Transaction has been reverted by the EVM:\\n' + JSON.stringify(receipt, null, 2));\n        error.reason = reason;\n        error.signature = signature;\n        error.receipt = receipt;\n        return error;\n    },\n    TransactionError: function (message, receipt) {\n        var error = new Error(message);\n        error.receipt = receipt;\n        return error;\n    },\n    NoContractAddressFoundError: function (receipt) {\n        return this.TransactionError('The transaction receipt didn\\'t contain a contract address.', receipt);\n    },\n    ContractCodeNotStoredError: function (receipt) {\n        return this.TransactionError('The contract code couldn\\'t be stored, please check your gas limit.', receipt);\n    },\n    TransactionRevertedWithoutReasonError: function (receipt) {\n        return this.TransactionError('Transaction has been reverted by the EVM:\\n' + JSON.stringify(receipt, null, 2), receipt);\n    },\n    TransactionOutOfGasError: function (receipt) {\n        return this.TransactionError('Transaction ran out of gas. Please provide more gas:\\n' + JSON.stringify(receipt, null, 2), receipt);\n    },\n    ResolverMethodMissingError: function (address, name) {\n        return new Error('The resolver at ' + address + 'does not implement requested method: \"' + name + '\".');\n    },\n    ContractMissingABIError: function () {\n        return new Error('You must provide the json interface of the contract when instantiating a contract object.');\n    },\n    ContractOnceRequiresCallbackError: function () {\n        return new Error('Once requires a callback as the second parameter.');\n    },\n    ContractEventDoesNotExistError: function (eventName) {\n        return new Error('Event \"' + eventName + '\" doesn\\'t exist in this contract.');\n    },\n    ContractReservedEventError: function (type) {\n        return new Error('The event \"' + type + '\" is a reserved event name, you can\\'t use it.');\n    },\n    ContractMissingDeployDataError: function () {\n        return new Error('No \"data\" specified in neither the given options, nor the default options.');\n    },\n    ContractNoAddressDefinedError: function () {\n        return new Error('This contract object doesn\\'t have address set yet, please set an address first.');\n    },\n    ContractNoFromAddressDefinedError: function () {\n        return new Error('No \"from\" address specified in neither the given options, nor the default options.');\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLWhlbHBlcnMvbGliL2Vycm9ycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1oZWxwZXJzL2xpYi9lcnJvcnMuanM/OGZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBlcnJvcnMuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQHBhcml0eS5pbz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFcnJvclJlc3BvbnNlOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gISFyZXN1bHQgJiYgISFyZXN1bHQuZXJyb3IgJiYgISFyZXN1bHQuZXJyb3IubWVzc2FnZSA/IHJlc3VsdC5lcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgdmFyIGRhdGEgPSAoISFyZXN1bHQuZXJyb3IgJiYgISFyZXN1bHQuZXJyb3IuZGF0YSkgPyByZXN1bHQuZXJyb3IuZGF0YSA6IG51bGw7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1JldHVybmVkIGVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9LFxuICAgIEludmFsaWROdW1iZXJPZlBhcmFtczogZnVuY3Rpb24gKGdvdCwgZXhwZWN0ZWQsIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBwYXJhbWV0ZXJzIGZvciBcIicgKyBtZXRob2QgKyAnXCIuIEdvdCAnICsgZ290ICsgJyBleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnIScpO1xuICAgIH0sXG4gICAgSW52YWxpZENvbm5lY3Rpb246IGZ1bmN0aW9uIChob3N0LCBldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Db25uZWN0aW9uRXJyb3IoJ0NPTk5FQ1RJT04gRVJST1I6IENvdWxkblxcJ3QgY29ubmVjdCB0byBub2RlICcgKyBob3N0ICsgJy4nLCBldmVudCk7XG4gICAgfSxcbiAgICBJbnZhbGlkUHJvdmlkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignUHJvdmlkZXIgbm90IHNldCBvciBpbnZhbGlkJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAhIXJlc3VsdCAmJiAhIXJlc3VsdC5lcnJvciAmJiAhIXJlc3VsdC5lcnJvci5tZXNzYWdlID8gcmVzdWx0LmVycm9yLm1lc3NhZ2UgOiAnSW52YWxpZCBKU09OIFJQQyByZXNwb25zZTogJyArIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSxcbiAgICBDb25uZWN0aW9uVGltZW91dDogZnVuY3Rpb24gKG1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0NPTk5FQ1RJT04gVElNRU9VVDogdGltZW91dCBvZiAnICsgbXMgKyAnIG1zIGFjaGl2ZWQnKTtcbiAgICB9LFxuICAgIENvbm5lY3Rpb25Ob3RPcGVuRXJyb3I6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Db25uZWN0aW9uRXJyb3IoJ2Nvbm5lY3Rpb24gbm90IG9wZW4gb24gc2VuZCgpJywgZXZlbnQpO1xuICAgIH0sXG4gICAgQ29ubmVjdGlvbkNsb3NlRXJyb3I6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0JyAmJiBldmVudC5jb2RlICYmIGV2ZW50LnJlYXNvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ29ubmVjdGlvbkVycm9yKCdDT05ORUNUSU9OIEVSUk9SOiBUaGUgY29ubmVjdGlvbiBnb3QgY2xvc2VkIHdpdGggJyArXG4gICAgICAgICAgICAgICAgJ3RoZSBjbG9zZSBjb2RlIGAnICsgZXZlbnQuY29kZSArICdgIGFuZCB0aGUgZm9sbG93aW5nICcgK1xuICAgICAgICAgICAgICAgICdyZWFzb24gc3RyaW5nIGAnICsgZXZlbnQucmVhc29uICsgJ2AnLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignQ09OTkVDVElPTiBFUlJPUjogVGhlIGNvbm5lY3Rpb24gY2xvc2VkIHVuZXhwZWN0ZWRseScpO1xuICAgIH0sXG4gICAgTWF4QXR0ZW1wdHNSZWFjaGVkT25SZWNvbm5lY3RpbmdFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3QgYXR0ZW1wdHMgcmVhY2hlZCEnKTtcbiAgICB9LFxuICAgIFBlbmRpbmdSZXF1ZXN0c09uUmVjb25uZWN0aW5nRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignQ09OTkVDVElPTiBFUlJPUjogUHJvdmlkZXIgc3RhcnRlZCB0byByZWNvbm5lY3QgYmVmb3JlIHRoZSByZXNwb25zZSBnb3QgcmVjZWl2ZWQhJyk7XG4gICAgfSxcbiAgICBDb25uZWN0aW9uRXJyb3I6IGZ1bmN0aW9uIChtc2csIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IGV2ZW50LmNvZGU7XG4gICAgICAgICAgICBlcnJvci5yZWFzb24gPSBldmVudC5yZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sXG4gICAgUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcjogZnVuY3Rpb24gKHJlYXNvbiwgc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignWW91ciByZXF1ZXN0IGdvdCByZXZlcnRlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcmVhc29uIHN0cmluZzogJyArIHJlYXNvbik7XG4gICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgZXJyb3Iuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcbiAgICBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I6IGZ1bmN0aW9uIChyZWFzb24sIHNpZ25hdHVyZSwgcmVjZWlwdCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGhhcyBiZWVuIHJldmVydGVkIGJ5IHRoZSBFVk06XFxuJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgICAgIGVycm9yLnJlY2VpcHQgPSByZWNlaXB0O1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcbiAgICBUcmFuc2FjdGlvbkVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSwgcmVjZWlwdCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnJlY2VpcHQgPSByZWNlaXB0O1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcbiAgICBOb0NvbnRyYWN0QWRkcmVzc0ZvdW5kRXJyb3I6IGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRyYW5zYWN0aW9uRXJyb3IoJ1RoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGRpZG5cXCd0IGNvbnRhaW4gYSBjb250cmFjdCBhZGRyZXNzLicsIHJlY2VpcHQpO1xuICAgIH0sXG4gICAgQ29udHJhY3RDb2RlTm90U3RvcmVkRXJyb3I6IGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRyYW5zYWN0aW9uRXJyb3IoJ1RoZSBjb250cmFjdCBjb2RlIGNvdWxkblxcJ3QgYmUgc3RvcmVkLCBwbGVhc2UgY2hlY2sgeW91ciBnYXMgbGltaXQuJywgcmVjZWlwdCk7XG4gICAgfSxcbiAgICBUcmFuc2FjdGlvblJldmVydGVkV2l0aG91dFJlYXNvbkVycm9yOiBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5UcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgYmVlbiByZXZlcnRlZCBieSB0aGUgRVZNOlxcbicgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSwgcmVjZWlwdCk7XG4gICAgfSxcbiAgICBUcmFuc2FjdGlvbk91dE9mR2FzRXJyb3I6IGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIHJhbiBvdXQgb2YgZ2FzLiBQbGVhc2UgcHJvdmlkZSBtb3JlIGdhczpcXG4nICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMiksIHJlY2VpcHQpO1xuICAgIH0sXG4gICAgUmVzb2x2ZXJNZXRob2RNaXNzaW5nRXJyb3I6IGZ1bmN0aW9uIChhZGRyZXNzLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1RoZSByZXNvbHZlciBhdCAnICsgYWRkcmVzcyArICdkb2VzIG5vdCBpbXBsZW1lbnQgcmVxdWVzdGVkIG1ldGhvZDogXCInICsgbmFtZSArICdcIi4nKTtcbiAgICB9LFxuICAgIENvbnRyYWN0TWlzc2luZ0FCSUVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgdGhlIGpzb24gaW50ZXJmYWNlIG9mIHRoZSBjb250cmFjdCB3aGVuIGluc3RhbnRpYXRpbmcgYSBjb250cmFjdCBvYmplY3QuJyk7XG4gICAgfSxcbiAgICBDb250cmFjdE9uY2VSZXF1aXJlc0NhbGxiYWNrRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignT25jZSByZXF1aXJlcyBhIGNhbGxiYWNrIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLicpO1xuICAgIH0sXG4gICAgQ29udHJhY3RFdmVudERvZXNOb3RFeGlzdEVycm9yOiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0V2ZW50IFwiJyArIGV2ZW50TmFtZSArICdcIiBkb2VzblxcJ3QgZXhpc3QgaW4gdGhpcyBjb250cmFjdC4nKTtcbiAgICB9LFxuICAgIENvbnRyYWN0UmVzZXJ2ZWRFdmVudEVycm9yOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdUaGUgZXZlbnQgXCInICsgdHlwZSArICdcIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWUsIHlvdSBjYW5cXCd0IHVzZSBpdC4nKTtcbiAgICB9LFxuICAgIENvbnRyYWN0TWlzc2luZ0RlcGxveURhdGFFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdObyBcImRhdGFcIiBzcGVjaWZpZWQgaW4gbmVpdGhlciB0aGUgZ2l2ZW4gb3B0aW9ucywgbm9yIHRoZSBkZWZhdWx0IG9wdGlvbnMuJyk7XG4gICAgfSxcbiAgICBDb250cmFjdE5vQWRkcmVzc0RlZmluZWRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdUaGlzIGNvbnRyYWN0IG9iamVjdCBkb2VzblxcJ3QgaGF2ZSBhZGRyZXNzIHNldCB5ZXQsIHBsZWFzZSBzZXQgYW4gYWRkcmVzcyBmaXJzdC4nKTtcbiAgICB9LFxuICAgIENvbnRyYWN0Tm9Gcm9tQWRkcmVzc0RlZmluZWRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdObyBcImZyb21cIiBhZGRyZXNzIHNwZWNpZmllZCBpbiBuZWl0aGVyIHRoZSBnaXZlbiBvcHRpb25zLCBub3IgdGhlIGRlZmF1bHQgb3B0aW9ucy4nKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/errors.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/formatters.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/formatters.js ***!
  \**********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file formatters.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar Iban = __webpack_require__(/*! web3-eth-iban */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-iban/lib/index.js\");\n/**\n * Will format the given storage key array values to hex strings.\n *\n * @method inputStorageKeysFormatter\n *\n * @param {Array<Number|String|BN|BigNumber>} keys\n *\n * @returns {Array<String>}\n */\nvar inputStorageKeysFormatter = function (keys) {\n    return keys.map(utils.numberToHex);\n};\n/**\n * Will format the given proof response from the node.\n *\n * @method outputProofFormatter\n *\n * @param {object} proof\n *\n * @returns {object}\n */\nvar outputProofFormatter = function (proof) {\n    proof.address = utils.toChecksumAddress(proof.address);\n    proof.nonce = utils.hexToNumberString(proof.nonce);\n    proof.balance = utils.hexToNumberString(proof.balance);\n    return proof;\n};\n/**\n * Should the format output to a big number\n *\n * @method outputBigNumberFormatter\n *\n * @param {String|Number|BigNumber|BN} number\n *\n * @returns {BN} object\n */\nvar outputBigNumberFormatter = function (number) {\n    return utils.toBN(number).toString(10);\n};\n/**\n * Returns true if the given blockNumber is 'latest', 'pending', or 'earliest.\n *\n * @method isPredefinedBlockNumber\n *\n * @param {String} blockNumber\n *\n * @returns {Boolean}\n */\nvar isPredefinedBlockNumber = function (blockNumber) {\n    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n};\n/**\n * Returns the given block number as hex string or does return the defaultBlock property of the current module\n *\n * @method inputDefaultBlockNumberFormatter\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\nvar inputDefaultBlockNumberFormatter = function (blockNumber) {\n    if (this && (blockNumber === undefined || blockNumber === null)) {\n        return inputBlockNumberFormatter(this.defaultBlock);\n    }\n    return inputBlockNumberFormatter(blockNumber);\n};\n/**\n * Returns the given block number as hex string or the predefined block number 'latest', 'pending', 'earliest', 'genesis'\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\nvar inputBlockNumberFormatter = function (blockNumber) {\n    if (blockNumber === undefined) {\n        return undefined;\n    }\n    if (isPredefinedBlockNumber(blockNumber)) {\n        return blockNumber;\n    }\n    if (blockNumber === 'genesis') {\n        return '0x0';\n    }\n    return (utils.isHexStrict(blockNumber)) ? ((typeof blockNumber === 'string') ? blockNumber.toLowerCase() : blockNumber) : utils.numberToHex(blockNumber);\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method _txInputFormatter\n * @param {Object} transaction options\n * @returns object\n */\nvar _txInputFormatter = function (options) {\n    if (options.to) { // it might be contract creation\n        options.to = inputAddressFormatter(options.to);\n    }\n    if (options.data && options.input) {\n        throw new Error('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n    }\n    if (!options.data && options.input) {\n        options.data = options.input;\n        delete options.input;\n    }\n    if (options.data && !options.data.startsWith('0x')) {\n        options.data = '0x' + options.data;\n    }\n    if (options.data && !utils.isHex(options.data)) {\n        throw new Error('The data field must be HEX encoded data.');\n    }\n    // allow both\n    if (options.gas || options.gasLimit) {\n        options.gas = options.gas || options.gasLimit;\n    }\n    if (options.maxPriorityFeePerGas || options.maxFeePerGas) {\n        delete options.gasPrice;\n    }\n    ['gasPrice', 'gas', 'value', 'maxPriorityFeePerGas', 'maxFeePerGas', 'nonce'].filter(function (key) {\n        return options[key] !== undefined;\n    }).forEach(function (key) {\n        options[key] = utils.numberToHex(options[key]);\n    });\n    return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputCallFormatter\n * @param {Object} transaction options\n * @returns object\n */\nvar inputCallFormatter = function (options) {\n    options = _txInputFormatter(options);\n    var from = options.from || (this ? this.defaultAccount : null);\n    if (from) {\n        options.from = inputAddressFormatter(from);\n    }\n    return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputTransactionFormatter\n * @param {Object} options\n * @returns object\n */\nvar inputTransactionFormatter = function (options) {\n    options = _txInputFormatter(options);\n    // check from, only if not number, or object\n    if (!(typeof options.from === 'number') && !(!!options.from && typeof options.from === 'object')) {\n        options.from = options.from || (this ? this.defaultAccount : null);\n        if (!options.from && !(typeof options.from === 'number')) {\n            throw new Error('The send transactions \"from\" field must be defined!');\n        }\n        options.from = inputAddressFormatter(options.from);\n    }\n    return options;\n};\n/**\n * Hex encodes the data passed to eth_sign and personal_sign\n *\n * @method inputSignFormatter\n * @param {String} data\n * @returns {String}\n */\nvar inputSignFormatter = function (data) {\n    return (utils.isHexStrict(data)) ? data : utils.utf8ToHex(data);\n};\n/**\n * Formats the output of a transaction to its proper values\n *\n * @method outputTransactionFormatter\n * @param {Object} tx\n * @returns {Object}\n */\nvar outputTransactionFormatter = function (tx) {\n    if (tx.blockNumber !== null)\n        tx.blockNumber = utils.hexToNumber(tx.blockNumber);\n    if (tx.transactionIndex !== null)\n        tx.transactionIndex = utils.hexToNumber(tx.transactionIndex);\n    tx.nonce = utils.hexToNumber(tx.nonce);\n    tx.gas = utils.hexToNumber(tx.gas);\n    if (tx.gasPrice)\n        tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n    if (tx.maxFeePerGas)\n        tx.maxFeePerGas = outputBigNumberFormatter(tx.maxFeePerGas);\n    if (tx.maxPriorityFeePerGas)\n        tx.maxPriorityFeePerGas = outputBigNumberFormatter(tx.maxPriorityFeePerGas);\n    if (tx.type)\n        tx.type = utils.hexToNumber(tx.type);\n    tx.value = outputBigNumberFormatter(tx.value);\n    if (tx.to && utils.isAddress(tx.to)) { // tx.to could be `0x0` or `null` while contract creation\n        tx.to = utils.toChecksumAddress(tx.to);\n    }\n    else {\n        tx.to = null; // set to `null` if invalid address\n    }\n    if (tx.from) {\n        tx.from = utils.toChecksumAddress(tx.from);\n    }\n    return tx;\n};\n/**\n * Formats the output of a transaction receipt to its proper values\n *\n * @method outputTransactionReceiptFormatter\n * @param {Object} receipt\n * @returns {Object}\n */\nvar outputTransactionReceiptFormatter = function (receipt) {\n    if (typeof receipt !== 'object') {\n        throw new Error('Received receipt is invalid: ' + receipt);\n    }\n    if (receipt.blockNumber !== null)\n        receipt.blockNumber = utils.hexToNumber(receipt.blockNumber);\n    if (receipt.transactionIndex !== null)\n        receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex);\n    receipt.cumulativeGasUsed = utils.hexToNumber(receipt.cumulativeGasUsed);\n    receipt.gasUsed = utils.hexToNumber(receipt.gasUsed);\n    if (Array.isArray(receipt.logs)) {\n        receipt.logs = receipt.logs.map(outputLogFormatter);\n    }\n    if (receipt.contractAddress) {\n        receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress);\n    }\n    if (typeof receipt.status !== 'undefined' && receipt.status !== null) {\n        receipt.status = Boolean(parseInt(receipt.status));\n    }\n    return receipt;\n};\n/**\n * Formats the output of a block to its proper values\n *\n * @method outputBlockFormatter\n * @param {Object} block\n * @returns {Object}\n */\nvar outputBlockFormatter = function (block) {\n    // transform to number\n    block.gasLimit = utils.hexToNumber(block.gasLimit);\n    block.gasUsed = utils.hexToNumber(block.gasUsed);\n    block.size = utils.hexToNumber(block.size);\n    block.timestamp = utils.hexToNumber(block.timestamp);\n    if (block.number !== null)\n        block.number = utils.hexToNumber(block.number);\n    if (block.difficulty)\n        block.difficulty = outputBigNumberFormatter(block.difficulty);\n    if (block.totalDifficulty)\n        block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n    if (Array.isArray(block.transactions)) {\n        block.transactions.forEach(function (item) {\n            if (!(typeof item === 'string'))\n                return outputTransactionFormatter(item);\n        });\n    }\n    if (block.miner)\n        block.miner = utils.toChecksumAddress(block.miner);\n    return block;\n};\n/**\n * Formats the input of a log\n *\n * @method inputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nvar inputLogFormatter = function (options) {\n    var toTopic = function (value) {\n        if (value === null || typeof value === 'undefined')\n            return null;\n        value = String(value);\n        if (value.indexOf('0x') === 0)\n            return value;\n        else\n            return utils.fromUtf8(value);\n    };\n    if (options === undefined)\n        options = {};\n    // If options !== undefined, don't blow out existing data\n    if (options.fromBlock === undefined)\n        options = { ...options, fromBlock: 'latest' };\n    if (options.fromBlock || options.fromBlock === 0)\n        options.fromBlock = inputBlockNumberFormatter(options.fromBlock);\n    if (options.toBlock || options.toBlock === 0)\n        options.toBlock = inputBlockNumberFormatter(options.toBlock);\n    // make sure topics, get converted to hex\n    options.topics = options.topics || [];\n    options.topics = options.topics.map(function (topic) {\n        return (Array.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);\n    });\n    toTopic = null;\n    if (options.address) {\n        options.address = (Array.isArray(options.address)) ? options.address.map(function (addr) {\n            return inputAddressFormatter(addr);\n        }) : inputAddressFormatter(options.address);\n    }\n    return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nvar outputLogFormatter = function (log) {\n    // generate a custom log id\n    if (typeof log.blockHash === 'string' &&\n        typeof log.transactionHash === 'string' &&\n        typeof log.logIndex === 'string') {\n        var shaId = utils.sha3(log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''));\n        log.id = 'log_' + shaId.replace('0x', '').substr(0, 8);\n    }\n    else if (!log.id) {\n        log.id = null;\n    }\n    if (log.blockNumber !== null)\n        log.blockNumber = utils.hexToNumber(log.blockNumber);\n    if (log.transactionIndex !== null)\n        log.transactionIndex = utils.hexToNumber(log.transactionIndex);\n    if (log.logIndex !== null)\n        log.logIndex = utils.hexToNumber(log.logIndex);\n    if (log.address) {\n        log.address = utils.toChecksumAddress(log.address);\n    }\n    return log;\n};\n/**\n * Formats the input of a whisper post and converts all values to HEX\n *\n * @method inputPostFormatter\n * @param {Object} transaction object\n * @returns {Object}\n */\nvar inputPostFormatter = function (post) {\n    // post.payload = utils.toHex(post.payload);\n    if (post.ttl)\n        post.ttl = utils.numberToHex(post.ttl);\n    if (post.workToProve)\n        post.workToProve = utils.numberToHex(post.workToProve);\n    if (post.priority)\n        post.priority = utils.numberToHex(post.priority);\n    // fallback\n    if (!Array.isArray(post.topics)) {\n        post.topics = post.topics ? [post.topics] : [];\n    }\n    // format the following options\n    post.topics = post.topics.map(function (topic) {\n        // convert only if not hex\n        return (topic.indexOf('0x') === 0) ? topic : utils.fromUtf8(topic);\n    });\n    return post;\n};\n/**\n * Formats the output of a received post message\n *\n * @method outputPostFormatter\n * @param {Object}\n * @returns {Object}\n */\nvar outputPostFormatter = function (post) {\n    post.expiry = utils.hexToNumber(post.expiry);\n    post.sent = utils.hexToNumber(post.sent);\n    post.ttl = utils.hexToNumber(post.ttl);\n    post.workProved = utils.hexToNumber(post.workProved);\n    // post.payloadRaw = post.payload;\n    // post.payload = utils.hexToAscii(post.payload);\n    // if (utils.isJson(post.payload)) {\n    //     post.payload = JSON.parse(post.payload);\n    // }\n    // format the following options\n    if (!post.topics) {\n        post.topics = [];\n    }\n    post.topics = post.topics.map(function (topic) {\n        return utils.toUtf8(topic);\n    });\n    return post;\n};\nvar inputAddressFormatter = function (address) {\n    var iban = new Iban(address);\n    if (iban.isValid() && iban.isDirect()) {\n        return iban.toAddress().toLowerCase();\n    }\n    else if (utils.isAddress(address)) {\n        return '0x' + address.toLowerCase().replace('0x', '');\n    }\n    throw new Error(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);\n};\nvar outputSyncingFormatter = function (result) {\n    result.startingBlock = utils.hexToNumber(result.startingBlock);\n    result.currentBlock = utils.hexToNumber(result.currentBlock);\n    result.highestBlock = utils.hexToNumber(result.highestBlock);\n    if (result.knownStates) {\n        result.knownStates = utils.hexToNumber(result.knownStates);\n        result.pulledStates = utils.hexToNumber(result.pulledStates);\n    }\n    return result;\n};\nmodule.exports = {\n    inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,\n    inputBlockNumberFormatter: inputBlockNumberFormatter,\n    inputCallFormatter: inputCallFormatter,\n    inputTransactionFormatter: inputTransactionFormatter,\n    inputAddressFormatter: inputAddressFormatter,\n    inputPostFormatter: inputPostFormatter,\n    inputLogFormatter: inputLogFormatter,\n    inputSignFormatter: inputSignFormatter,\n    inputStorageKeysFormatter: inputStorageKeysFormatter,\n    outputProofFormatter: outputProofFormatter,\n    outputBigNumberFormatter: outputBigNumberFormatter,\n    outputTransactionFormatter: outputTransactionFormatter,\n    outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,\n    outputBlockFormatter: outputBlockFormatter,\n    outputLogFormatter: outputLogFormatter,\n    outputPostFormatter: outputPostFormatter,\n    outputSyncingFormatter: outputSyncingFormatter\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLWhlbHBlcnMvbGliL2Zvcm1hdHRlcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLDhGQUFZO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxvR0FBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1oZWxwZXJzL2xpYi9mb3JtYXR0ZXJzLmpzPzBhZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZm9ybWF0dGVycy5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnd2ViMy1ldGgtaWJhbicpO1xuLyoqXG4gKiBXaWxsIGZvcm1hdCB0aGUgZ2l2ZW4gc3RvcmFnZSBrZXkgYXJyYXkgdmFsdWVzIHRvIGhleCBzdHJpbmdzLlxuICpcbiAqIEBtZXRob2QgaW5wdXRTdG9yYWdlS2V5c0Zvcm1hdHRlclxuICpcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyfFN0cmluZ3xCTnxCaWdOdW1iZXI+fSBrZXlzXG4gKlxuICogQHJldHVybnMge0FycmF5PFN0cmluZz59XG4gKi9cbnZhciBpbnB1dFN0b3JhZ2VLZXlzRm9ybWF0dGVyID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5tYXAodXRpbHMubnVtYmVyVG9IZXgpO1xufTtcbi8qKlxuICogV2lsbCBmb3JtYXQgdGhlIGdpdmVuIHByb29mIHJlc3BvbnNlIGZyb20gdGhlIG5vZGUuXG4gKlxuICogQG1ldGhvZCBvdXRwdXRQcm9vZkZvcm1hdHRlclxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9vZlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbnZhciBvdXRwdXRQcm9vZkZvcm1hdHRlciA9IGZ1bmN0aW9uIChwcm9vZikge1xuICAgIHByb29mLmFkZHJlc3MgPSB1dGlscy50b0NoZWNrc3VtQWRkcmVzcyhwcm9vZi5hZGRyZXNzKTtcbiAgICBwcm9vZi5ub25jZSA9IHV0aWxzLmhleFRvTnVtYmVyU3RyaW5nKHByb29mLm5vbmNlKTtcbiAgICBwcm9vZi5iYWxhbmNlID0gdXRpbHMuaGV4VG9OdW1iZXJTdHJpbmcocHJvb2YuYmFsYW5jZSk7XG4gICAgcmV0dXJuIHByb29mO1xufTtcbi8qKlxuICogU2hvdWxkIHRoZSBmb3JtYXQgb3V0cHV0IHRvIGEgYmlnIG51bWJlclxuICpcbiAqIEBtZXRob2Qgb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcnxCTn0gbnVtYmVyXG4gKlxuICogQHJldHVybnMge0JOfSBvYmplY3RcbiAqL1xudmFyIG91dHB1dEJpZ051bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICByZXR1cm4gdXRpbHMudG9CTihudW1iZXIpLnRvU3RyaW5nKDEwKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYmxvY2tOdW1iZXIgaXMgJ2xhdGVzdCcsICdwZW5kaW5nJywgb3IgJ2VhcmxpZXN0LlxuICpcbiAqIEBtZXRob2QgaXNQcmVkZWZpbmVkQmxvY2tOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmxvY2tOdW1iZXJcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzUHJlZGVmaW5lZEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgcmV0dXJuIGJsb2NrTnVtYmVyID09PSAnbGF0ZXN0JyB8fCBibG9ja051bWJlciA9PT0gJ3BlbmRpbmcnIHx8IGJsb2NrTnVtYmVyID09PSAnZWFybGllc3QnO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZ2l2ZW4gYmxvY2sgbnVtYmVyIGFzIGhleCBzdHJpbmcgb3IgZG9lcyByZXR1cm4gdGhlIGRlZmF1bHRCbG9jayBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBtb2R1bGVcbiAqXG4gKiBAbWV0aG9kIGlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfEJpZ051bWJlcn0gYmxvY2tOdW1iZXJcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG52YXIgaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICBpZiAodGhpcyAmJiAoYmxvY2tOdW1iZXIgPT09IHVuZGVmaW5lZCB8fCBibG9ja051bWJlciA9PT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIodGhpcy5kZWZhdWx0QmxvY2spO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihibG9ja051bWJlcik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBibG9jayBudW1iZXIgYXMgaGV4IHN0cmluZyBvciB0aGUgcHJlZGVmaW5lZCBibG9jayBudW1iZXIgJ2xhdGVzdCcsICdwZW5kaW5nJywgJ2VhcmxpZXN0JywgJ2dlbmVzaXMnXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfEJpZ051bWJlcn0gYmxvY2tOdW1iZXJcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG52YXIgaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgIGlmIChibG9ja051bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1ByZWRlZmluZWRCbG9ja051bWJlcihibG9ja051bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICBpZiAoYmxvY2tOdW1iZXIgPT09ICdnZW5lc2lzJykge1xuICAgICAgICByZXR1cm4gJzB4MCc7XG4gICAgfVxuICAgIHJldHVybiAodXRpbHMuaXNIZXhTdHJpY3QoYmxvY2tOdW1iZXIpKSA/ICgodHlwZW9mIGJsb2NrTnVtYmVyID09PSAnc3RyaW5nJykgPyBibG9ja051bWJlci50b0xvd2VyQ2FzZSgpIDogYmxvY2tOdW1iZXIpIDogdXRpbHMubnVtYmVyVG9IZXgoYmxvY2tOdW1iZXIpO1xufTtcbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB0cmFuc2FjdGlvbiBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIF90eElucHV0Rm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gb3B0aW9uc1xuICogQHJldHVybnMgb2JqZWN0XG4gKi9cbnZhciBfdHhJbnB1dEZvcm1hdHRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudG8pIHsgLy8gaXQgbWlnaHQgYmUgY29udHJhY3QgY3JlYXRpb25cbiAgICAgICAgb3B0aW9ucy50byA9IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLnRvKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhblxcJ3QgaGF2ZSBcImRhdGFcIiBhbmQgXCJpbnB1dFwiIGFzIHByb3BlcnRpZXMgb2YgdHJhbnNhY3Rpb25zIGF0IHRoZSBzYW1lIHRpbWUsIHBsZWFzZSB1c2UgZWl0aGVyIFwiZGF0YVwiIG9yIFwiaW5wdXRcIiBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlucHV0KSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuaW5wdXQ7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmlucHV0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmICFvcHRpb25zLmRhdGEuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBvcHRpb25zLmRhdGEgPSAnMHgnICsgb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmICF1dGlscy5pc0hleChvcHRpb25zLmRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgZmllbGQgbXVzdCBiZSBIRVggZW5jb2RlZCBkYXRhLicpO1xuICAgIH1cbiAgICAvLyBhbGxvdyBib3RoXG4gICAgaWYgKG9wdGlvbnMuZ2FzIHx8IG9wdGlvbnMuZ2FzTGltaXQpIHtcbiAgICAgICAgb3B0aW9ucy5nYXMgPSBvcHRpb25zLmdhcyB8fCBvcHRpb25zLmdhc0xpbWl0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCBvcHRpb25zLm1heEZlZVBlckdhcykge1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5nYXNQcmljZTtcbiAgICB9XG4gICAgWydnYXNQcmljZScsICdnYXMnLCAndmFsdWUnLCAnbWF4UHJpb3JpdHlGZWVQZXJHYXMnLCAnbWF4RmVlUGVyR2FzJywgJ25vbmNlJ10uZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvcHRpb25zW2tleV0gPSB1dGlscy5udW1iZXJUb0hleChvcHRpb25zW2tleV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB0cmFuc2FjdGlvbiBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0Q2FsbEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIG9iamVjdFxuICovXG52YXIgaW5wdXRDYWxsRm9ybWF0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX3R4SW5wdXRGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgdmFyIGZyb20gPSBvcHRpb25zLmZyb20gfHwgKHRoaXMgPyB0aGlzLmRlZmF1bHRBY2NvdW50IDogbnVsbCk7XG4gICAgaWYgKGZyb20pIHtcbiAgICAgICAgb3B0aW9ucy5mcm9tID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKGZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIEZvcm1hdHMgdGhlIGlucHV0IG9mIGEgdHJhbnNhY3Rpb24gYW5kIGNvbnZlcnRzIGFsbCB2YWx1ZXMgdG8gSEVYXG4gKlxuICogQG1ldGhvZCBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMgb2JqZWN0XG4gKi9cbnZhciBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX3R4SW5wdXRGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgLy8gY2hlY2sgZnJvbSwgb25seSBpZiBub3QgbnVtYmVyLCBvciBvYmplY3RcbiAgICBpZiAoISh0eXBlb2Ygb3B0aW9ucy5mcm9tID09PSAnbnVtYmVyJykgJiYgISghIW9wdGlvbnMuZnJvbSAmJiB0eXBlb2Ygb3B0aW9ucy5mcm9tID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgb3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tIHx8ICh0aGlzID8gdGhpcy5kZWZhdWx0QWNjb3VudCA6IG51bGwpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuZnJvbSAmJiAhKHR5cGVvZiBvcHRpb25zLmZyb20gPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VuZCB0cmFuc2FjdGlvbnMgXCJmcm9tXCIgZmllbGQgbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIEhleCBlbmNvZGVzIHRoZSBkYXRhIHBhc3NlZCB0byBldGhfc2lnbiBhbmQgcGVyc29uYWxfc2lnblxuICpcbiAqIEBtZXRob2QgaW5wdXRTaWduRm9ybWF0dGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xudmFyIGlucHV0U2lnbkZvcm1hdHRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc0hleFN0cmljdChkYXRhKSkgPyBkYXRhIDogdXRpbHMudXRmOFRvSGV4KGRhdGEpO1xufTtcbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgdHJhbnNhY3Rpb24gdG8gaXRzIHByb3BlciB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdHhcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbnZhciBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlciA9IGZ1bmN0aW9uICh0eCkge1xuICAgIGlmICh0eC5ibG9ja051bWJlciAhPT0gbnVsbClcbiAgICAgICAgdHguYmxvY2tOdW1iZXIgPSB1dGlscy5oZXhUb051bWJlcih0eC5ibG9ja051bWJlcik7XG4gICAgaWYgKHR4LnRyYW5zYWN0aW9uSW5kZXggIT09IG51bGwpXG4gICAgICAgIHR4LnRyYW5zYWN0aW9uSW5kZXggPSB1dGlscy5oZXhUb051bWJlcih0eC50cmFuc2FjdGlvbkluZGV4KTtcbiAgICB0eC5ub25jZSA9IHV0aWxzLmhleFRvTnVtYmVyKHR4Lm5vbmNlKTtcbiAgICB0eC5nYXMgPSB1dGlscy5oZXhUb051bWJlcih0eC5nYXMpO1xuICAgIGlmICh0eC5nYXNQcmljZSlcbiAgICAgICAgdHguZ2FzUHJpY2UgPSBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXIodHguZ2FzUHJpY2UpO1xuICAgIGlmICh0eC5tYXhGZWVQZXJHYXMpXG4gICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IG91dHB1dEJpZ051bWJlckZvcm1hdHRlcih0eC5tYXhGZWVQZXJHYXMpO1xuICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGlmICh0eC50eXBlKVxuICAgICAgICB0eC50eXBlID0gdXRpbHMuaGV4VG9OdW1iZXIodHgudHlwZSk7XG4gICAgdHgudmFsdWUgPSBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXIodHgudmFsdWUpO1xuICAgIGlmICh0eC50byAmJiB1dGlscy5pc0FkZHJlc3ModHgudG8pKSB7IC8vIHR4LnRvIGNvdWxkIGJlIGAweDBgIG9yIGBudWxsYCB3aGlsZSBjb250cmFjdCBjcmVhdGlvblxuICAgICAgICB0eC50byA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzKHR4LnRvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHR4LnRvID0gbnVsbDsgLy8gc2V0IHRvIGBudWxsYCBpZiBpbnZhbGlkIGFkZHJlc3NcbiAgICB9XG4gICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgdHguZnJvbSA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzKHR4LmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59O1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSB0cmFuc2FjdGlvbiByZWNlaXB0IHRvIGl0cyBwcm9wZXIgdmFsdWVzXG4gKlxuICogQG1ldGhvZCBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNlaXB0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG52YXIgb3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyID0gZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICBpZiAodHlwZW9mIHJlY2VpcHQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZWQgcmVjZWlwdCBpcyBpbnZhbGlkOiAnICsgcmVjZWlwdCk7XG4gICAgfVxuICAgIGlmIChyZWNlaXB0LmJsb2NrTnVtYmVyICE9PSBudWxsKVxuICAgICAgICByZWNlaXB0LmJsb2NrTnVtYmVyID0gdXRpbHMuaGV4VG9OdW1iZXIocmVjZWlwdC5ibG9ja051bWJlcik7XG4gICAgaWYgKHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCAhPT0gbnVsbClcbiAgICAgICAgcmVjZWlwdC50cmFuc2FjdGlvbkluZGV4ID0gdXRpbHMuaGV4VG9OdW1iZXIocmVjZWlwdC50cmFuc2FjdGlvbkluZGV4KTtcbiAgICByZWNlaXB0LmN1bXVsYXRpdmVHYXNVc2VkID0gdXRpbHMuaGV4VG9OdW1iZXIocmVjZWlwdC5jdW11bGF0aXZlR2FzVXNlZCk7XG4gICAgcmVjZWlwdC5nYXNVc2VkID0gdXRpbHMuaGV4VG9OdW1iZXIocmVjZWlwdC5nYXNVc2VkKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNlaXB0LmxvZ3MpKSB7XG4gICAgICAgIHJlY2VpcHQubG9ncyA9IHJlY2VpcHQubG9ncy5tYXAob3V0cHV0TG9nRm9ybWF0dGVyKTtcbiAgICB9XG4gICAgaWYgKHJlY2VpcHQuY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHJlY2VpcHQuY29udHJhY3RBZGRyZXNzID0gdXRpbHMudG9DaGVja3N1bUFkZHJlc3MocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlY2VpcHQuc3RhdHVzICE9PSAndW5kZWZpbmVkJyAmJiByZWNlaXB0LnN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgICByZWNlaXB0LnN0YXR1cyA9IEJvb2xlYW4ocGFyc2VJbnQocmVjZWlwdC5zdGF0dXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY2VpcHQ7XG59O1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSBibG9jayB0byBpdHMgcHJvcGVyIHZhbHVlc1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBibG9ja1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xudmFyIG91dHB1dEJsb2NrRm9ybWF0dGVyID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgLy8gdHJhbnNmb3JtIHRvIG51bWJlclxuICAgIGJsb2NrLmdhc0xpbWl0ID0gdXRpbHMuaGV4VG9OdW1iZXIoYmxvY2suZ2FzTGltaXQpO1xuICAgIGJsb2NrLmdhc1VzZWQgPSB1dGlscy5oZXhUb051bWJlcihibG9jay5nYXNVc2VkKTtcbiAgICBibG9jay5zaXplID0gdXRpbHMuaGV4VG9OdW1iZXIoYmxvY2suc2l6ZSk7XG4gICAgYmxvY2sudGltZXN0YW1wID0gdXRpbHMuaGV4VG9OdW1iZXIoYmxvY2sudGltZXN0YW1wKTtcbiAgICBpZiAoYmxvY2subnVtYmVyICE9PSBudWxsKVxuICAgICAgICBibG9jay5udW1iZXIgPSB1dGlscy5oZXhUb051bWJlcihibG9jay5udW1iZXIpO1xuICAgIGlmIChibG9jay5kaWZmaWN1bHR5KVxuICAgICAgICBibG9jay5kaWZmaWN1bHR5ID0gb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyKGJsb2NrLmRpZmZpY3VsdHkpO1xuICAgIGlmIChibG9jay50b3RhbERpZmZpY3VsdHkpXG4gICAgICAgIGJsb2NrLnRvdGFsRGlmZmljdWx0eSA9IG91dHB1dEJpZ051bWJlckZvcm1hdHRlcihibG9jay50b3RhbERpZmZpY3VsdHkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2NrLnRyYW5zYWN0aW9ucykpIHtcbiAgICAgICAgYmxvY2sudHJhbnNhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLm1pbmVyKVxuICAgICAgICBibG9jay5taW5lciA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzKGJsb2NrLm1pbmVyKTtcbiAgICByZXR1cm4gYmxvY2s7XG59O1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBpbnB1dCBvZiBhIGxvZ1xuICpcbiAqIEBtZXRob2QgaW5wdXRMb2dGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2cgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2dcbiAqL1xudmFyIGlucHV0TG9nRm9ybWF0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdG9Ub3BpYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCcweCcpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuZnJvbVV0ZjgodmFsdWUpO1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIC8vIElmIG9wdGlvbnMgIT09IHVuZGVmaW5lZCwgZG9uJ3QgYmxvdyBvdXQgZXhpc3RpbmcgZGF0YVxuICAgIGlmIChvcHRpb25zLmZyb21CbG9jayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBmcm9tQmxvY2s6ICdsYXRlc3QnIH07XG4gICAgaWYgKG9wdGlvbnMuZnJvbUJsb2NrIHx8IG9wdGlvbnMuZnJvbUJsb2NrID09PSAwKVxuICAgICAgICBvcHRpb25zLmZyb21CbG9jayA9IGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9ucy5mcm9tQmxvY2spO1xuICAgIGlmIChvcHRpb25zLnRvQmxvY2sgfHwgb3B0aW9ucy50b0Jsb2NrID09PSAwKVxuICAgICAgICBvcHRpb25zLnRvQmxvY2sgPSBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKG9wdGlvbnMudG9CbG9jayk7XG4gICAgLy8gbWFrZSBzdXJlIHRvcGljcywgZ2V0IGNvbnZlcnRlZCB0byBoZXhcbiAgICBvcHRpb25zLnRvcGljcyA9IG9wdGlvbnMudG9waWNzIHx8IFtdO1xuICAgIG9wdGlvbnMudG9waWNzID0gb3B0aW9ucy50b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodG9waWMpKSA/IHRvcGljLm1hcCh0b1RvcGljKSA6IHRvVG9waWModG9waWMpO1xuICAgIH0pO1xuICAgIHRvVG9waWMgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmFkZHJlc3MpIHtcbiAgICAgICAgb3B0aW9ucy5hZGRyZXNzID0gKEFycmF5LmlzQXJyYXkob3B0aW9ucy5hZGRyZXNzKSkgPyBvcHRpb25zLmFkZHJlc3MubWFwKGZ1bmN0aW9uIChhZGRyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKGFkZHIpO1xuICAgICAgICB9KSA6IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLmFkZHJlc3MpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIGxvZ1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0TG9nRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbG9nIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gbG9nXG4gKi9cbnZhciBvdXRwdXRMb2dGb3JtYXR0ZXIgPSBmdW5jdGlvbiAobG9nKSB7XG4gICAgLy8gZ2VuZXJhdGUgYSBjdXN0b20gbG9nIGlkXG4gICAgaWYgKHR5cGVvZiBsb2cuYmxvY2tIYXNoID09PSAnc3RyaW5nJyAmJlxuICAgICAgICB0eXBlb2YgbG9nLnRyYW5zYWN0aW9uSGFzaCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdHlwZW9mIGxvZy5sb2dJbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHNoYUlkID0gdXRpbHMuc2hhMyhsb2cuYmxvY2tIYXNoLnJlcGxhY2UoJzB4JywgJycpICsgbG9nLnRyYW5zYWN0aW9uSGFzaC5yZXBsYWNlKCcweCcsICcnKSArIGxvZy5sb2dJbmRleC5yZXBsYWNlKCcweCcsICcnKSk7XG4gICAgICAgIGxvZy5pZCA9ICdsb2dfJyArIHNoYUlkLnJlcGxhY2UoJzB4JywgJycpLnN1YnN0cigwLCA4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWxvZy5pZCkge1xuICAgICAgICBsb2cuaWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobG9nLmJsb2NrTnVtYmVyICE9PSBudWxsKVxuICAgICAgICBsb2cuYmxvY2tOdW1iZXIgPSB1dGlscy5oZXhUb051bWJlcihsb2cuYmxvY2tOdW1iZXIpO1xuICAgIGlmIChsb2cudHJhbnNhY3Rpb25JbmRleCAhPT0gbnVsbClcbiAgICAgICAgbG9nLnRyYW5zYWN0aW9uSW5kZXggPSB1dGlscy5oZXhUb051bWJlcihsb2cudHJhbnNhY3Rpb25JbmRleCk7XG4gICAgaWYgKGxvZy5sb2dJbmRleCAhPT0gbnVsbClcbiAgICAgICAgbG9nLmxvZ0luZGV4ID0gdXRpbHMuaGV4VG9OdW1iZXIobG9nLmxvZ0luZGV4KTtcbiAgICBpZiAobG9nLmFkZHJlc3MpIHtcbiAgICAgICAgbG9nLmFkZHJlc3MgPSB1dGlscy50b0NoZWNrc3VtQWRkcmVzcyhsb2cuYWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiBsb2c7XG59O1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBpbnB1dCBvZiBhIHdoaXNwZXIgcG9zdCBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0UG9zdEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xudmFyIGlucHV0UG9zdEZvcm1hdHRlciA9IGZ1bmN0aW9uIChwb3N0KSB7XG4gICAgLy8gcG9zdC5wYXlsb2FkID0gdXRpbHMudG9IZXgocG9zdC5wYXlsb2FkKTtcbiAgICBpZiAocG9zdC50dGwpXG4gICAgICAgIHBvc3QudHRsID0gdXRpbHMubnVtYmVyVG9IZXgocG9zdC50dGwpO1xuICAgIGlmIChwb3N0LndvcmtUb1Byb3ZlKVxuICAgICAgICBwb3N0LndvcmtUb1Byb3ZlID0gdXRpbHMubnVtYmVyVG9IZXgocG9zdC53b3JrVG9Qcm92ZSk7XG4gICAgaWYgKHBvc3QucHJpb3JpdHkpXG4gICAgICAgIHBvc3QucHJpb3JpdHkgPSB1dGlscy5udW1iZXJUb0hleChwb3N0LnByaW9yaXR5KTtcbiAgICAvLyBmYWxsYmFja1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb3N0LnRvcGljcykpIHtcbiAgICAgICAgcG9zdC50b3BpY3MgPSBwb3N0LnRvcGljcyA/IFtwb3N0LnRvcGljc10gOiBbXTtcbiAgICB9XG4gICAgLy8gZm9ybWF0IHRoZSBmb2xsb3dpbmcgb3B0aW9uc1xuICAgIHBvc3QudG9waWNzID0gcG9zdC50b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICAvLyBjb252ZXJ0IG9ubHkgaWYgbm90IGhleFxuICAgICAgICByZXR1cm4gKHRvcGljLmluZGV4T2YoJzB4JykgPT09IDApID8gdG9waWMgOiB1dGlscy5mcm9tVXRmOCh0b3BpYyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvc3Q7XG59O1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSByZWNlaXZlZCBwb3N0IG1lc3NhZ2VcbiAqXG4gKiBAbWV0aG9kIG91dHB1dFBvc3RGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xudmFyIG91dHB1dFBvc3RGb3JtYXR0ZXIgPSBmdW5jdGlvbiAocG9zdCkge1xuICAgIHBvc3QuZXhwaXJ5ID0gdXRpbHMuaGV4VG9OdW1iZXIocG9zdC5leHBpcnkpO1xuICAgIHBvc3Quc2VudCA9IHV0aWxzLmhleFRvTnVtYmVyKHBvc3Quc2VudCk7XG4gICAgcG9zdC50dGwgPSB1dGlscy5oZXhUb051bWJlcihwb3N0LnR0bCk7XG4gICAgcG9zdC53b3JrUHJvdmVkID0gdXRpbHMuaGV4VG9OdW1iZXIocG9zdC53b3JrUHJvdmVkKTtcbiAgICAvLyBwb3N0LnBheWxvYWRSYXcgPSBwb3N0LnBheWxvYWQ7XG4gICAgLy8gcG9zdC5wYXlsb2FkID0gdXRpbHMuaGV4VG9Bc2NpaShwb3N0LnBheWxvYWQpO1xuICAgIC8vIGlmICh1dGlscy5pc0pzb24ocG9zdC5wYXlsb2FkKSkge1xuICAgIC8vICAgICBwb3N0LnBheWxvYWQgPSBKU09OLnBhcnNlKHBvc3QucGF5bG9hZCk7XG4gICAgLy8gfVxuICAgIC8vIGZvcm1hdCB0aGUgZm9sbG93aW5nIG9wdGlvbnNcbiAgICBpZiAoIXBvc3QudG9waWNzKSB7XG4gICAgICAgIHBvc3QudG9waWNzID0gW107XG4gICAgfVxuICAgIHBvc3QudG9waWNzID0gcG9zdC50b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICByZXR1cm4gdXRpbHMudG9VdGY4KHRvcGljKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9zdDtcbn07XG52YXIgaW5wdXRBZGRyZXNzRm9ybWF0dGVyID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKGFkZHJlc3MpO1xuICAgIGlmIChpYmFuLmlzVmFsaWQoKSAmJiBpYmFuLmlzRGlyZWN0KCkpIHtcbiAgICAgICAgcmV0dXJuIGliYW4udG9BZGRyZXNzKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbHMuaXNBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIGFkZHJlc3MgJHthZGRyZXNzfSBpcyBpbnZhbGlkLCB0aGUgY2FwaXRhbGl6YXRpb24gY2hlY2tzdW0gdGVzdCBmYWlsZWQsIG9yIGl0J3MgYW4gaW5kaXJlY3QgSUJBTiBhZGRyZXNzIHdoaWNoIGNhbid0IGJlIGNvbnZlcnRlZC5gKTtcbn07XG52YXIgb3V0cHV0U3luY2luZ0Zvcm1hdHRlciA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXN1bHQuc3RhcnRpbmdCbG9jayA9IHV0aWxzLmhleFRvTnVtYmVyKHJlc3VsdC5zdGFydGluZ0Jsb2NrKTtcbiAgICByZXN1bHQuY3VycmVudEJsb2NrID0gdXRpbHMuaGV4VG9OdW1iZXIocmVzdWx0LmN1cnJlbnRCbG9jayk7XG4gICAgcmVzdWx0LmhpZ2hlc3RCbG9jayA9IHV0aWxzLmhleFRvTnVtYmVyKHJlc3VsdC5oaWdoZXN0QmxvY2spO1xuICAgIGlmIChyZXN1bHQua25vd25TdGF0ZXMpIHtcbiAgICAgICAgcmVzdWx0Lmtub3duU3RhdGVzID0gdXRpbHMuaGV4VG9OdW1iZXIocmVzdWx0Lmtub3duU3RhdGVzKTtcbiAgICAgICAgcmVzdWx0LnB1bGxlZFN0YXRlcyA9IHV0aWxzLmhleFRvTnVtYmVyKHJlc3VsdC5wdWxsZWRTdGF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyOiBpbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcixcbiAgICBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyOiBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLFxuICAgIGlucHV0Q2FsbEZvcm1hdHRlcjogaW5wdXRDYWxsRm9ybWF0dGVyLFxuICAgIGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXI6IGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIsXG4gICAgaW5wdXRBZGRyZXNzRm9ybWF0dGVyOiBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIsXG4gICAgaW5wdXRQb3N0Rm9ybWF0dGVyOiBpbnB1dFBvc3RGb3JtYXR0ZXIsXG4gICAgaW5wdXRMb2dGb3JtYXR0ZXI6IGlucHV0TG9nRm9ybWF0dGVyLFxuICAgIGlucHV0U2lnbkZvcm1hdHRlcjogaW5wdXRTaWduRm9ybWF0dGVyLFxuICAgIGlucHV0U3RvcmFnZUtleXNGb3JtYXR0ZXI6IGlucHV0U3RvcmFnZUtleXNGb3JtYXR0ZXIsXG4gICAgb3V0cHV0UHJvb2ZGb3JtYXR0ZXI6IG91dHB1dFByb29mRm9ybWF0dGVyLFxuICAgIG91dHB1dEJpZ051bWJlckZvcm1hdHRlcjogb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyLFxuICAgIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOiBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcixcbiAgICBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXI6IG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlcixcbiAgICBvdXRwdXRCbG9ja0Zvcm1hdHRlcjogb3V0cHV0QmxvY2tGb3JtYXR0ZXIsXG4gICAgb3V0cHV0TG9nRm9ybWF0dGVyOiBvdXRwdXRMb2dGb3JtYXR0ZXIsXG4gICAgb3V0cHV0UG9zdEZvcm1hdHRlcjogb3V0cHV0UG9zdEZvcm1hdHRlcixcbiAgICBvdXRwdXRTeW5jaW5nRm9ybWF0dGVyOiBvdXRwdXRTeW5jaW5nRm9ybWF0dGVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/formatters.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar errors = __webpack_require__(/*! ./errors */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/errors.js\");\nvar formatters = __webpack_require__(/*! ./formatters */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/formatters.js\");\nmodule.exports = {\n    errors: errors,\n    formatters: formatters\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLWhlbHBlcnMvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixhQUFhLG1CQUFPLENBQUMsb0dBQVU7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsNEdBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1oZWxwZXJzL2xpYi9pbmRleC5qcz9iNzExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGluZGV4LmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgZm9ybWF0dGVyczogZm9ybWF0dGVyc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js ***!
  \****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar promiEvent = __webpack_require__(/*! web3-core-promievent */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/lib/index.js\");\nvar Subscriptions = (__webpack_require__(/*! web3-core-subscriptions */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js\").subscriptions);\nvar EthersTransactionUtils = __webpack_require__(/*! @ethersproject/transactions */ \"../../node_modules/@ethersproject/transactions/lib.esm/index.js\");\nvar Method = function Method(options) {\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n    this.requestManager = options.requestManager;\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n    return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    }\n    else {\n        obj[name[0]] = func;\n    }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return typeof this.call === 'function' ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (typeof (args[args.length - 1]) === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n    if (!this.inputFormatter) {\n        return args;\n    }\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n    if (Array.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    }\n    else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n    return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, lastBlock = null, receiptJSON = '', gasProvided = ((!!payload.params[0] && typeof payload.params[0] === 'object') && payload.params[0].gas) ? payload.params[0].gas : null, isContractDeployment = (!!payload.params[0] && typeof payload.params[0] === 'object') &&\n        payload.params[0].data &&\n        payload.params[0].from &&\n        !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                    return !!val;\n                }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getTransactionByHash',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads',\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _ethereumCalls.forEach(mthd => {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n                // catch error from requesting receipt\n                .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({\n                    message: 'Failed to check for transaction receipt:',\n                    data: err\n                }, defer.eventEmitter, defer.reject);\n            })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    var block;\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\n                        // Get latest block to emit with confirmation\n                        var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\n                        if (isPolling) { // Check if actually a new block is existing on polling\n                            if (lastBlock) {\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                if (block) {\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                }\n                            }\n                            else {\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                lastBlock = block;\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                            }\n                        }\n                        else {\n                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                        }\n                    }\n                    if ((isPolling && block) || !isPolling) {\n                        confirmationCount++;\n                    }\n                    canUnsubscribe = false;\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n                return receipt;\n            })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n                if (isContractDeployment && !promiseResolved) {\n                    if (!receipt.contractAddress) {\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        return;\n                    }\n                    var code;\n                    try {\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\n                    }\n                    catch (err) {\n                        // ignore;\n                    }\n                    if (!code) {\n                        return;\n                    }\n                    // If deployment is status.true and there was a real\n                    // bytecode string, assume it was successful.\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\n                    if (deploymentSuccess || code.length > 2) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        // if contract, return instance instead of receipt\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                        }\n                        else {\n                            defer.resolve(receipt);\n                        }\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n                return receipt;\n            })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                if (!isContractDeployment && !promiseResolved) {\n                    if (!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            try {\n                                var revertMessage = null;\n                                if (method.handleRevert &&\n                                    (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                                    var txReplayOptions = payload.params[0];\n                                    // If send was raw, fetch the transaction and reconstitute the\n                                    // original params so they can be replayed with `eth_call`\n                                    if (method.call === 'eth_sendRawTransaction') {\n                                        var rawTransactionHex = payload.params[0];\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                                        txReplayOptions = formatters.inputTransactionFormatter({\n                                            data: parsedTx.data,\n                                            to: parsedTx.to,\n                                            from: parsedTx.from,\n                                            gas: parsedTx.gasLimit.toHexString(),\n                                            gasPrice: parsedTx.gasPrice.toHexString(),\n                                            value: parsedTx.value.toHexString()\n                                        });\n                                    }\n                                    // Get revert reason string with eth_call\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                                    if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                                    }\n                                    else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                }\n                                else {\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                }\n                            }\n                            catch (error) {\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                            }\n                        }\n                        else {\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        }\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n            })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                timeoutCount++;\n                // check to see if we are http polling\n                if (!!isPolling) {\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n                else {\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n        }\n        else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        const startInterval = () => {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        };\n        if (!this.requestManager.provider.on) {\n            startInterval();\n        }\n        else {\n            _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n                if (err || !blockHeader) {\n                    // fall back to polling\n                    startInterval();\n                }\n                else {\n                    checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n                }\n            });\n        }\n    }.bind(this);\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n        }\n        else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n        .catch(function () {\n        if (!promiseResolved)\n            startWatching();\n    });\n};\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n    // is index given\n    if (typeof from === 'number') {\n        wallet = accounts.wallet[from];\n        // is account given\n    }\n    else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\n        wallet = from;\n        // search in wallet for address\n    }\n    else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n    return wallet;\n};\nMethod.prototype.buildCall = function () {\n    var method = this, isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n    isCall = (method.call === 'eth_call');\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(Array.prototype.slice.call(arguments));\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)) {\n                    reasonData = result.substring(10);\n                }\n                else if (err && err.data) {\n                    reasonData = err.data.substring(10);\n                }\n                if (reasonData) {\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n                    var signature = 'Error(String)';\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n                        reason: reason,\n                        signature: signature\n                    });\n                    return;\n                }\n            }\n            try {\n                result = method.formatOutput(result);\n            }\n            catch (e) {\n                err = e;\n            }\n            if (result instanceof Error) {\n                err = result;\n            }\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            }\n            else {\n                if (err.error) {\n                    err = err.error;\n                }\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n                // return PROMIEVENT\n            }\n            else {\n                defer.eventEmitter.emit('transactionHash', result);\n                method._confirmTransaction(defer, result, payload);\n            }\n        };\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n            var signedPayload = { ...payload,\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            };\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n        var sendRequest = function (payload, method) {\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((!!tx && typeof tx === 'object') ? tx.from : null, method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var tx = JSON.parse(JSON.stringify(tx));\n                        delete tx.from;\n                        if (method.defaultChain && !tx.chain) {\n                            tx.chain = method.defaultChain;\n                        }\n                        if (method.defaultHardfork && !tx.hardfork) {\n                            tx.hardfork = method.defaultHardfork;\n                        }\n                        if (method.defaultCommon && !tx.common) {\n                            tx.common = method.defaultCommon;\n                        }\n                        method.accounts.signTransaction(tx, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                            if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\n                                try {\n                                    defer.eventEmitter.emit('error', err);\n                                }\n                                catch (err) {\n                                    // Ignore userland error prevent it to bubble up within web3.\n                                }\n                                defer.eventEmitter.removeAllListeners();\n                                defer.eventEmitter.catch(function () {\n                                });\n                            }\n                            defer.reject(err);\n                        });\n                        return;\n                    }\n                    // ETH_SIGN\n                }\n                else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n                }\n            }\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n        // Send the actual transaction\n        if (isSendTx\n            && !!payload.params[0]\n            && typeof payload.params[0] === 'object'\n            && (typeof payload.params[0].gasPrice === 'undefined'\n                && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined'\n                    || typeof payload.params[0].maxFeePerGas === 'undefined'))) {\n            _handleTxPricing(method, payload.params[0]).then(txPricing => {\n                if (txPricing.gasPrice !== undefined) {\n                    payload.params[0].gasPrice = txPricing.gasPrice;\n                }\n                else if (txPricing.maxPriorityFeePerGas !== undefined\n                    && txPricing.maxFeePerGas !== undefined) {\n                    payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n                    payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n                }\n                if (isSendTx) {\n                    setTimeout(() => {\n                        defer.eventEmitter.emit('sending', payload);\n                    }, 0);\n                }\n                sendRequest(payload, method);\n            });\n        }\n        else {\n            if (isSendTx) {\n                setTimeout(() => {\n                    defer.eventEmitter.emit('sending', payload);\n                }, 0);\n            }\n            sendRequest(payload, method);\n        }\n        if (isSendTx) {\n            setTimeout(() => {\n                defer.eventEmitter.emit('sent', payload);\n            }, 0);\n        }\n        return defer.eventEmitter;\n    };\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\nfunction _handleTxPricing(method, tx) {\n    return new Promise((resolve, reject) => {\n        try {\n            var getBlockByNumber = (new Method({\n                name: 'getBlockByNumber',\n                call: 'eth_getBlockByNumber',\n                params: 2,\n                inputFormatter: [function (blockNumber) {\n                        return blockNumber ? utils.toHex(blockNumber) : 'latest';\n                    }, function () {\n                        return false;\n                    }]\n            })).createFunction(method.requestManager);\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n            Promise.all([\n                getBlockByNumber(),\n                getGasPrice()\n            ]).then(responses => {\n                const [block, gasPrice] = responses;\n                if ((tx.type === '0x2' || tx.type === undefined) &&\n                    (block && block.baseFeePerGas)) {\n                    // The network supports EIP-1559\n                    // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                    let maxPriorityFeePerGas, maxFeePerGas;\n                    if (tx.gasPrice) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        maxPriorityFeePerGas = tx.gasPrice;\n                        maxFeePerGas = tx.gasPrice;\n                        delete tx.gasPrice;\n                    }\n                    else {\n                        maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n                        maxFeePerGas = tx.maxFeePerGas ||\n                            utils.toHex(utils.toBN(block.baseFeePerGas)\n                                .mul(utils.toBN(2))\n                                .add(utils.toBN(maxPriorityFeePerGas)));\n                    }\n                    resolve({ maxFeePerGas, maxPriorityFeePerGas });\n                }\n                else {\n                    if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\n                        throw Error(\"Network doesn't support eip-1559\");\n                    resolve({ gasPrice });\n                }\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n            resolve(false);\n        })\n            .catch(function (error) {\n            if (error.reason) {\n                resolve({\n                    reason: error.reason,\n                    signature: error.signature\n                });\n            }\n            else {\n                reject(error);\n            }\n        });\n    });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return typeof data === 'string' && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\nmodule.exports = Method;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLW1ldGhvZC9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsYUFBYSwwSUFBbUM7QUFDaEQsaUJBQWlCLDhJQUF1QztBQUN4RCxZQUFZLG1CQUFPLENBQUMsOEZBQVk7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsa0hBQXNCO0FBQy9DLG9CQUFvQiw2SkFBZ0Q7QUFDcEUsNkJBQTZCLG1CQUFPLENBQUMsb0dBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1tZXRob2QvbGliL2luZGV4LmpzPzhhOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgaW5kZXguanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQHBhcml0eS5pbz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmZvcm1hdHRlcnM7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgcHJvbWlFdmVudCA9IHJlcXVpcmUoJ3dlYjMtY29yZS1wcm9taWV2ZW50Jyk7XG52YXIgU3Vic2NyaXB0aW9ucyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1zdWJzY3JpcHRpb25zJykuc3Vic2NyaXB0aW9ucztcbnZhciBFdGhlcnNUcmFuc2FjdGlvblV0aWxzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zJyk7XG52YXIgTWV0aG9kID0gZnVuY3Rpb24gTWV0aG9kKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuY2FsbCB8fCAhb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjcmVhdGluZyBhIG1ldGhvZCB5b3UgbmVlZCB0byBwcm92aWRlIGF0IGxlYXN0IHRoZSBcIm5hbWVcIiBhbmQgXCJjYWxsXCIgcHJvcGVydHkuJyk7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLmNhbGwgPSBvcHRpb25zLmNhbGw7XG4gICAgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCAwO1xuICAgIHRoaXMuaW5wdXRGb3JtYXR0ZXIgPSBvcHRpb25zLmlucHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMub3V0cHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5vdXRwdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy50cmFuc2Zvcm1QYXlsb2FkID0gb3B0aW9ucy50cmFuc2Zvcm1QYXlsb2FkO1xuICAgIHRoaXMuZXh0cmFGb3JtYXR0ZXJzID0gb3B0aW9ucy5leHRyYUZvcm1hdHRlcnM7XG4gICAgdGhpcy5hYmlDb2RlciA9IG9wdGlvbnMuYWJpQ29kZXI7IC8vIFdpbGwgYmUgdXNlZCB0byBlbmNvZGUgdGhlIHJldmVydCByZWFzb24gc3RyaW5nXG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IG9wdGlvbnMucmVxdWVzdE1hbmFnZXI7XG4gICAgLy8gcmVmZXJlbmNlIHRvIGV0aC5hY2NvdW50c1xuICAgIHRoaXMuYWNjb3VudHMgPSBvcHRpb25zLmFjY291bnRzO1xuICAgIHRoaXMuZGVmYXVsdEJsb2NrID0gb3B0aW9ucy5kZWZhdWx0QmxvY2sgfHwgJ2xhdGVzdCc7XG4gICAgdGhpcy5kZWZhdWx0QWNjb3VudCA9IG9wdGlvbnMuZGVmYXVsdEFjY291bnQgfHwgbnVsbDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0ID0gb3B0aW9ucy50cmFuc2FjdGlvbkJsb2NrVGltZW91dCB8fCA1MDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzID0gb3B0aW9ucy50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyB8fCAyNDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQgPSBvcHRpb25zLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQgfHwgNzUwO1xuICAgIHRoaXMuZGVmYXVsdENvbW1vbiA9IG9wdGlvbnMuZGVmYXVsdENvbW1vbjtcbiAgICB0aGlzLmRlZmF1bHRDaGFpbiA9IG9wdGlvbnMuZGVmYXVsdENoYWluO1xuICAgIHRoaXMuZGVmYXVsdEhhcmRmb3JrID0gb3B0aW9ucy5kZWZhdWx0SGFyZGZvcms7XG4gICAgdGhpcy5oYW5kbGVSZXZlcnQgPSBvcHRpb25zLmhhbmRsZVJldmVydDtcbn07XG5NZXRob2QucHJvdG90eXBlLnNldFJlcXVlc3RNYW5hZ2VyID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBhY2NvdW50cykge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSByZXF1ZXN0TWFuYWdlcjtcbiAgICAvLyByZWZlcmVuY2UgdG8gZXRoLmFjY291bnRzXG4gICAgaWYgKGFjY291bnRzKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICB9XG59O1xuTWV0aG9kLnByb3RvdHlwZS5jcmVhdGVGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwgYWNjb3VudHMpIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuYnVpbGRDYWxsKCk7XG4gICAgZnVuYy5jYWxsID0gdGhpcy5jYWxsO1xuICAgIHRoaXMuc2V0UmVxdWVzdE1hbmFnZXIocmVxdWVzdE1hbmFnZXIgfHwgdGhpcy5yZXF1ZXN0TWFuYWdlciwgYWNjb3VudHMgfHwgdGhpcy5hY2NvdW50cyk7XG4gICAgcmV0dXJuIGZ1bmM7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuYnVpbGRDYWxsKCk7XG4gICAgZnVuYy5jYWxsID0gdGhpcy5jYWxsO1xuICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLnNwbGl0KCcuJyk7XG4gICAgaWYgKG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICBvYmpbbmFtZVswXV0gPSBvYmpbbmFtZVswXV0gfHwge307XG4gICAgICAgIG9ialtuYW1lWzBdXVtuYW1lWzFdXSA9IGZ1bmM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmpbbmFtZVswXV0gPSBmdW5jO1xuICAgIH1cbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBuYW1lIG9mIHRoZSBqc29ucnBjIG1ldGhvZCBiYXNlZCBvbiBhcmd1bWVudHNcbiAqXG4gKiBAbWV0aG9kIGdldENhbGxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7U3RyaW5nfSBuYW1lIG9mIGpzb25ycGMgbWV0aG9kXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZ2V0Q2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmNhbGwgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNhbGwoYXJncykgOiB0aGlzLmNhbGw7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBleHRyYWN0IGNhbGxiYWNrIGZyb20gYXJyYXkgb2YgYXJndW1lbnRzLiBNb2RpZmllcyBpbnB1dCBwYXJhbVxuICpcbiAqIEBtZXRob2QgZXh0cmFjdENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufE51bGx9IGNhbGxiYWNrLCBpZiBleGlzdHNcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MucG9wKCk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGlzIGNvcnJlY3RcbiAqXG4gKiBAbWV0aG9kIHZhbGlkYXRlQXJnc1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgbm90XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IHRoaXMucGFyYW1zKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZQYXJhbXMoYXJncy5sZW5ndGgsIHRoaXMucGFyYW1zLCB0aGlzLm5hbWUpO1xuICAgIH1cbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IGlucHV0IGFyZ3Mgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dFxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5NZXRob2QucHJvdG90eXBlLmZvcm1hdElucHV0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICghdGhpcy5pbnB1dEZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRGb3JtYXR0ZXIubWFwKGZ1bmN0aW9uIChmb3JtYXR0ZXIsIGluZGV4KSB7XG4gICAgICAgIC8vIGJpbmQgdGhpcyBmb3IgZGVmYXVsdEJsb2NrLCBhbmQgZGVmYXVsdEFjY291bnRcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlci5jYWxsKF90aGlzLCBhcmdzW2luZGV4XSkgOiBhcmdzW2luZGV4XTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IG91dHB1dChyZXN1bHQpIG9mIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5mb3JtYXRPdXRwdXQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzID8gX3RoaXMub3V0cHV0Rm9ybWF0dGVyKHJlcykgOiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0Rm9ybWF0dGVyICYmIHJlc3VsdCA/IHRoaXMub3V0cHV0Rm9ybWF0dGVyKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBwYXlsb2FkIGZyb20gZ2l2ZW4gaW5wdXQgYXJnc1xuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9QYXlsb2FkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgY2FsbCA9IHRoaXMuZ2V0Q2FsbChhcmdzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5mb3JtYXRJbnB1dChhcmdzKTtcbiAgICB0aGlzLnZhbGlkYXRlQXJncyhwYXJhbXMpO1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICBtZXRob2Q6IGNhbGwsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xuICAgIGlmICh0aGlzLnRyYW5zZm9ybVBheWxvYWQpIHtcbiAgICAgICAgcGF5bG9hZCA9IHRoaXMudHJhbnNmb3JtUGF5bG9hZChwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5fY29uZmlybVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGRlZmVyLCByZXN1bHQsIHBheWxvYWQpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcywgcHJvbWlzZVJlc29sdmVkID0gZmFsc2UsIGNhblVuc3Vic2NyaWJlID0gdHJ1ZSwgdGltZW91dENvdW50ID0gMCwgY29uZmlybWF0aW9uQ291bnQgPSAwLCBpbnRlcnZhbElkID0gbnVsbCwgbGFzdEJsb2NrID0gbnVsbCwgcmVjZWlwdEpTT04gPSAnJywgZ2FzUHJvdmlkZWQgPSAoKCEhcGF5bG9hZC5wYXJhbXNbMF0gJiYgdHlwZW9mIHBheWxvYWQucGFyYW1zWzBdID09PSAnb2JqZWN0JykgJiYgcGF5bG9hZC5wYXJhbXNbMF0uZ2FzKSA/IHBheWxvYWQucGFyYW1zWzBdLmdhcyA6IG51bGwsIGlzQ29udHJhY3REZXBsb3ltZW50ID0gKCEhcGF5bG9hZC5wYXJhbXNbMF0gJiYgdHlwZW9mIHBheWxvYWQucGFyYW1zWzBdID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0uZGF0YSAmJlxuICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5mcm9tICYmXG4gICAgICAgICFwYXlsb2FkLnBhcmFtc1swXS50bywgaGFzQnl0ZWNvZGUgPSBpc0NvbnRyYWN0RGVwbG95bWVudCAmJiBwYXlsb2FkLnBhcmFtc1swXS5kYXRhLmxlbmd0aCA+IDI7XG4gICAgLy8gYWRkIGN1c3RvbSBzZW5kIE1ldGhvZHNcbiAgICB2YXIgX2V0aGVyZXVtQ2FsbHMgPSBbXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbDtcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRCbG9ja0Zvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRDb2RlJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0Q29kZScsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgU3Vic2NyaXB0aW9ucyh7XG4gICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlJyxcbiAgICAgICAgICAgIHR5cGU6ICdldGgnLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczoge1xuICAgICAgICAgICAgICAgICduZXdCbG9ja0hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbk5hbWU6ICduZXdIZWFkcycsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIF07XG4gICAgLy8gYXR0YWNoIG1ldGhvZHMgdG8gdGhpcy5fZXRoZXJldW1DYWxsXG4gICAgdmFyIF9ldGhlcmV1bUNhbGwgPSB7fTtcbiAgICBfZXRoZXJldW1DYWxscy5mb3JFYWNoKG10aGQgPT4ge1xuICAgICAgICBtdGhkLmF0dGFjaFRvT2JqZWN0KF9ldGhlcmV1bUNhbGwpO1xuICAgICAgICBtdGhkLnJlcXVlc3RNYW5hZ2VyID0gbWV0aG9kLnJlcXVlc3RNYW5hZ2VyOyAvLyBhc3NpZ24gcmF0aGVyIHRoYW4gY2FsbCBzZXRSZXF1ZXN0TWFuYWdlcigpXG4gICAgfSk7XG4gICAgLy8gZmlyZSBcInJlY2VpcHRcIiBhbmQgY29uZmlybWF0aW9uIGV2ZW50cyBhbmQgcmVzb2x2ZSBhZnRlclxuICAgIHZhciBjaGVja0NvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIChleGlzdGluZ1JlY2VpcHQsIGlzUG9sbGluZywgZXJyLCBibG9ja0hlYWRlciwgc3ViKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZmFrZSB1bnN1YnNjcmliZVxuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSB2YWxpZCByZWNlaXB0IHdlIGRvbid0IG5lZWQgdG8gc2VuZCBhIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiAoZXhpc3RpbmdSZWNlaXB0ID8gcHJvbWlFdmVudC5yZXNvbHZlKGV4aXN0aW5nUmVjZWlwdCkgOiBfZXRoZXJldW1DYWxsLmdldFRyYW5zYWN0aW9uUmVjZWlwdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yIGZyb20gcmVxdWVzdGluZyByZWNlaXB0XG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGNoZWNrIGZvciB0cmFuc2FjdGlvbiByZWNlaXB0OicsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgICAgICAgIH0sIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gaWYgQ09ORklSTUFUSU9OIGxpc3RlbmVyIGV4aXN0cyBjaGVjayBmb3IgY29uZmlybWF0aW9ucywgYnkgc2V0dGluZyBjYW5VbnN1YnNjcmliZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgIXJlY2VpcHQuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWlwdCBtaXNzaW5nIG9yIGJsb2NrSGFzaCBudWxsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGV4dHJhIGZvcm1hdHRlcnNcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmV4dHJhRm9ybWF0dGVycyAmJiBtZXRob2QuZXh0cmFGb3JtYXR0ZXJzLnJlY2VpcHRGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdCA9IG1ldGhvZC5leHRyYUZvcm1hdHRlcnMucmVjZWlwdEZvcm1hdHRlcihyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgY29uZmlybWF0aW9uIGxpc3RlbmVyIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChkZWZlci5ldmVudEVtaXR0ZXIubGlzdGVuZXJzKCdjb25maXJtYXRpb24nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGltbWVkaWF0ZWx5IHJldHJpZXZlZCByZWNlaXB0LCBpdCdzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBjb25maXJtZWQgYnkgdGhlIGRpcmVjdCBjYWxsIHRvIGNoZWNrQ29uZmlybWF0aW9uIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcGFyaXR5IGluc3RhbnQtc2VhbFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdSZWNlaXB0ID09PSB1bmRlZmluZWQgfHwgY29uZmlybWF0aW9uQ291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBsYXRlc3QgYmxvY2sgdG8gZW1pdCB3aXRoIGNvbmZpcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhdGVzdEJsb2NrID0gYXdhaXQgX2V0aGVyZXVtQ2FsbC5nZXRCbG9ja0J5TnVtYmVyKCdsYXRlc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXRlc3RCbG9ja0hhc2ggPSBsYXRlc3RCbG9jayA/IGxhdGVzdEJsb2NrLmhhc2ggOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUG9sbGluZykgeyAvLyBDaGVjayBpZiBhY3R1YWxseSBhIG5ldyBibG9jayBpcyBleGlzdGluZyBvbiBwb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IGF3YWl0IF9ldGhlcmV1bUNhbGwuZ2V0QmxvY2tCeU51bWJlcihsYXN0QmxvY2subnVtYmVyICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnY29uZmlybWF0aW9uJywgY29uZmlybWF0aW9uQ291bnQsIHJlY2VpcHQsIGxhdGVzdEJsb2NrSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYXdhaXQgX2V0aGVyZXVtQ2FsbC5nZXRCbG9ja0J5TnVtYmVyKHJlY2VpcHQuYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbmZpcm1hdGlvbicsIGNvbmZpcm1hdGlvbkNvdW50LCByZWNlaXB0LCBsYXRlc3RCbG9ja0hhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdjb25maXJtYXRpb24nLCBjb25maXJtYXRpb25Db3VudCwgcmVjZWlwdCwgbGF0ZXN0QmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGlzUG9sbGluZyAmJiBibG9jaykgfHwgIWlzUG9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYW5VbnN1YnNjcmliZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uQ291bnQgPT09IG1ldGhvZC50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyArIDEpIHsgLy8gYWRkIDEgc28gd2UgYWNjb3VudCBmb3IgY29uZiAwXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gQ0hFQ0sgZm9yIENPTlRSQUNUIERFUExPWU1FTlRcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbnRyYWN0RGVwbG95bWVudCAmJiAhcHJvbWlzZVJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdC5jb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5Ob0NvbnRyYWN0QWRkcmVzc0ZvdW5kRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBhd2FpdCBfZXRoZXJldW1DYWxsLmdldENvZGUocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZXBsb3ltZW50IGlzIHN0YXR1cy50cnVlIGFuZCB0aGVyZSB3YXMgYSByZWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5dGVjb2RlIHN0cmluZywgYXNzdW1lIGl0IHdhcyBzdWNjZXNzZnVsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwbG95bWVudFN1Y2Nlc3MgPSByZWNlaXB0LnN0YXR1cyA9PT0gdHJ1ZSAmJiBoYXNCeXRlY29kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGxveW1lbnRTdWNjZXNzIHx8IGNvZGUubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3JlY2VpcHQnLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbnRyYWN0LCByZXR1cm4gaW5zdGFuY2UgaW5zdGVhZCBvZiByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmV4dHJhRm9ybWF0dGVycyAmJiBtZXRob2QuZXh0cmFGb3JtYXR0ZXJzLmNvbnRyYWN0RGVwbG95Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShtZXRob2QuZXh0cmFGb3JtYXR0ZXJzLmNvbnRyYWN0RGVwbG95Rm9ybWF0dGVyKHJlY2VpcHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHJlbW92ZSBsaXN0ZW5lcnMsIGFzIHRoZXkgYXJlbid0IHJlbW92ZWQgYXV0b21hdGljYWxseSB3aGVuIHN1Y2Nlc2Z1bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLkNvbnRyYWN0Q29kZU5vdFN0b3JlZEVycm9yKHJlY2VpcHQpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgbnVsbCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gQ0hFQ0sgZm9yIG5vcm1hbCB0eCBjaGVjayBmb3IgcmVjZWlwdCBvbmx5XG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJhY3REZXBsb3ltZW50ICYmICFwcm9taXNlUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0Lm91dE9mR2FzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWdhc1Byb3ZpZGVkIHx8IGdhc1Byb3ZpZGVkICE9PSByZWNlaXB0Lmdhc1VzZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVjZWlwdC5zdGF0dXMgPT09IHRydWUgfHwgcmVjZWlwdC5zdGF0dXMgPT09ICcweDEnIHx8IHR5cGVvZiByZWNlaXB0LnN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgncmVjZWlwdCcsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVtb3ZlIGxpc3RlbmVycywgYXMgdGhleSBhcmVuJ3QgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gc3VjY2VzZnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdEpTT04gPSBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LnN0YXR1cyA9PT0gZmFsc2UgfHwgcmVjZWlwdC5zdGF0dXMgPT09ICcweDAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldmVydE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmhhbmRsZVJldmVydCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicgfHwgbWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eFJlcGxheU9wdGlvbnMgPSBwYXlsb2FkLnBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbmQgd2FzIHJhdywgZmV0Y2ggdGhlIHRyYW5zYWN0aW9uIGFuZCByZWNvbnN0aXR1dGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBwYXJhbXMgc28gdGhleSBjYW4gYmUgcmVwbGF5ZWQgd2l0aCBgZXRoX2NhbGxgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdUcmFuc2FjdGlvbkhleCA9IHBheWxvYWQucGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRUeCA9IEV0aGVyc1RyYW5zYWN0aW9uVXRpbHMucGFyc2UocmF3VHJhbnNhY3Rpb25IZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4UmVwbGF5T3B0aW9ucyA9IGZvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnNlZFR4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBwYXJzZWRUeC50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogcGFyc2VkVHguZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FzOiBwYXJzZWRUeC5nYXNMaW1pdC50b0hleFN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZTogcGFyc2VkVHguZ2FzUHJpY2UudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlZFR4LnZhbHVlLnRvSGV4U3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCByZXZlcnQgcmVhc29uIHN0cmluZyB3aXRoIGV0aF9jYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnRNZXNzYWdlID0gYXdhaXQgbWV0aG9kLmdldFJldmVydFJlYXNvbih0eFJlcGxheU9wdGlvbnMsIHJlY2VpcHQuYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldmVydE1lc3NhZ2UpIHsgLy8gT25seSB0aHJvdyBhIHJldmVydCBlcnJvciBpZiBhIHJldmVydCByZWFzb24gaXMgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3IocmV2ZXJ0TWVzc2FnZS5yZWFzb24sIHJldmVydE1lc3NhZ2Uuc2lnbmF0dXJlLCByZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFsc2U7IC8vIFRocm93IGZhbHNlIGFuZCBsZXQgdGhlIHRyeS9jYXRjaCBzdGF0ZW1lbnQgaGFuZGxlIHRoZSBlcnJvciBjb3JyZWN0bHkgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGZhbHNlOyAvLyBUaHJvdyBmYWxzZSBhbmQgbGV0IHRoZSB0cnkvY2F0Y2ggc3RhdGVtZW50IGhhbmRsZSB0aGUgZXJyb3IgY29ycmVjdGx5IGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGFuIG5vcm1hbCByZXZlcnQgZXJyb3IgaWYgbm8gcmV2ZXJ0IHJlYXNvbiBpcyBnaXZlbiBvciB0aGUgZGV0ZWN0aW9uIG9mIGl0IGlzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uUmV2ZXJ0ZWRXaXRob3V0UmVhc29uRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBPT0cgaWYgc3RhdHVzIGlzIG5vdCBleGlzdGluZyBhbmQgcHJvdmlkZWQgZ2FzIGFuZCB1c2VkIGdhcyBhcmUgZXF1YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvbk91dE9mR2FzRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyB0aW1lIG91dCB0aGUgdHJhbnNhY3Rpb24gaWYgbm90IG1pbmVkIGFmdGVyIDUwIGJsb2Nrc1xuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dENvdW50Kys7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBodHRwIHBvbGxpbmdcbiAgICAgICAgICAgICAgICBpZiAoISFpc1BvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9sbGluZyB0aW1lb3V0IGlzIGRpZmZlcmVudCB0aGFuIHRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0IGJsb2NrcyBzaW5jZSB3ZSBhcmUgdHJpZ2dlcmluZyBldmVyeSBzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRDb3VudCAtIDEgPj0gbWV0aG9kLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIHdhcyBub3QgbWluZWQgd2l0aGluICcgKyBtZXRob2QudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCArICcgc2Vjb25kcywgcGxlYXNlIG1ha2Ugc3VyZSB5b3VyIHRyYW5zYWN0aW9uIHdhcyBwcm9wZXJseSBzZW50LiBCZSBhd2FyZSB0aGF0IGl0IG1pZ2h0IHN0aWxsIGJlIG1pbmVkIScpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0Q291bnQgLSAxID49IG1ldGhvZC50cmFuc2FjdGlvbkJsb2NrVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gd2FzIG5vdCBtaW5lZCB3aXRoaW4gJyArIG1ldGhvZC50cmFuc2FjdGlvbkJsb2NrVGltZW91dCArICcgYmxvY2tzLCBwbGVhc2UgbWFrZSBzdXJlIHlvdXIgdHJhbnNhY3Rpb24gd2FzIHByb3Blcmx5IHNlbnQuIEJlIGF3YXJlIHRoYXQgaXQgbWlnaHQgc3RpbGwgYmUgbWluZWQhJyksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBzdWJzY3JpYmUgdG8gbmV3IG5ld0Jsb2NrSGVhZGVycyB0byBjb25maXJtIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0cy4nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgICAgfSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBzdGFydCB3YXRjaGluZyBmb3IgY29uZmlybWF0aW9uIGRlcGVuZGluZyBvbiB0aGUgc3VwcG9ydCBmZWF0dXJlcyBvZiB0aGUgcHJvdmlkZXJcbiAgICB2YXIgc3RhcnRXYXRjaGluZyA9IGZ1bmN0aW9uIChleGlzdGluZ1JlY2VpcHQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbnRlcnZhbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChjaGVja0NvbmZpcm1hdGlvbi5iaW5kKG51bGwsIGV4aXN0aW5nUmVjZWlwdCwgdHJ1ZSksIDEwMDApO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdE1hbmFnZXIucHJvdmlkZXIub24pIHtcbiAgICAgICAgICAgIHN0YXJ0SW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9ldGhlcmV1bUNhbGwuc3Vic2NyaWJlKCduZXdCbG9ja0hlYWRlcnMnLCBmdW5jdGlvbiAoZXJyLCBibG9ja0hlYWRlciwgc3ViKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciB8fCAhYmxvY2tIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHBvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDb25maXJtYXRpb24oZXhpc3RpbmdSZWNlaXB0LCBmYWxzZSwgZXJyLCBibG9ja0hlYWRlciwgc3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcbiAgICAvLyBmaXJzdCBjaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICBfZXRoZXJldW1DYWxsLmdldFRyYW5zYWN0aW9uUmVjZWlwdChyZXN1bHQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIGlmIChyZWNlaXB0ICYmIHJlY2VpcHQuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICBpZiAoZGVmZXIuZXZlbnRFbWl0dGVyLmxpc3RlbmVycygnY29uZmlybWF0aW9uJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG11c3Qga2VlcCBvbiB3YXRjaGluZyBmb3IgbmV3IEJsb2NrcywgaWYgYSBjb25maXJtYXRpb24gbGlzdGVuZXIgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgIHN0YXJ0V2F0Y2hpbmcocmVjZWlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0NvbmZpcm1hdGlvbihyZWNlaXB0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXByb21pc2VSZXNvbHZlZCkge1xuICAgICAgICAgICAgc3RhcnRXYXRjaGluZygpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlUmVzb2x2ZWQpXG4gICAgICAgICAgICBzdGFydFdhdGNoaW5nKCk7XG4gICAgfSk7XG59O1xudmFyIGdldFdhbGxldCA9IGZ1bmN0aW9uIChmcm9tLCBhY2NvdW50cykge1xuICAgIHZhciB3YWxsZXQgPSBudWxsO1xuICAgIC8vIGlzIGluZGV4IGdpdmVuXG4gICAgaWYgKHR5cGVvZiBmcm9tID09PSAnbnVtYmVyJykge1xuICAgICAgICB3YWxsZXQgPSBhY2NvdW50cy53YWxsZXRbZnJvbV07XG4gICAgICAgIC8vIGlzIGFjY291bnQgZ2l2ZW5cbiAgICB9XG4gICAgZWxzZSBpZiAoISFmcm9tICYmIHR5cGVvZiBmcm9tID09PSAnb2JqZWN0JyAmJiBmcm9tLmFkZHJlc3MgJiYgZnJvbS5wcml2YXRlS2V5KSB7XG4gICAgICAgIHdhbGxldCA9IGZyb207XG4gICAgICAgIC8vIHNlYXJjaCBpbiB3YWxsZXQgZm9yIGFkZHJlc3NcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhbGxldCA9IGFjY291bnRzLndhbGxldFtmcm9tLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0O1xufTtcbk1ldGhvZC5wcm90b3R5cGUuYnVpbGRDYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLCBpc1NlbmRUeCA9IChtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHx8IG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicpLCAvLyB8fCBtZXRob2QuY2FsbCA9PT0gJ3BlcnNvbmFsX3NlbmRUcmFuc2FjdGlvbidcbiAgICBpc0NhbGwgPSAobWV0aG9kLmNhbGwgPT09ICdldGhfY2FsbCcpO1xuICAgIC8vIGFjdHVhbCBzZW5kIGZ1bmN0aW9uXG4gICAgdmFyIHNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlciA9IHByb21pRXZlbnQoIWlzU2VuZFR4KSwgcGF5bG9hZCA9IG1ldGhvZC50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIC8vIENBTExCQUNLIGZ1bmN0aW9uXG4gICAgICAgIHZhciBzZW5kVHhDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5oYW5kbGVSZXZlcnQgJiYgaXNDYWxsICYmIG1ldGhvZC5hYmlDb2Rlcikge1xuICAgICAgICAgICAgICAgIHZhciByZWFzb25EYXRhO1xuICAgICAgICAgICAgICAgIC8vIEdhbmFjaGUgLyBHZXRoIDw9IDEuOS4xMyByZXR1cm4gdGhlIHJlYXNvbiBkYXRhIGFzIGEgc3VjY2Vzc2Z1bCBldGhfY2FsbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIEdldGggPj0gMS45LjE1IGF0dGFjaGVzIHRoZSByZWFzb24gZGF0YSB0byBhbiBlcnJvciBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gR2V0aCAxLjkuMTQgaXMgbWlzc2luZyByZXZlcnQgcmVhc29uIChodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2ViMy5qcy9pc3N1ZXMvMzUyMClcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBtZXRob2QuaXNSZXZlcnRSZWFzb25TdHJpbmcocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb25EYXRhID0gcmVzdWx0LnN1YnN0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyciAmJiBlcnIuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb25EYXRhID0gZXJyLmRhdGEuc3Vic3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IG1ldGhvZC5hYmlDb2Rlci5kZWNvZGVQYXJhbWV0ZXIoJ3N0cmluZycsICcweCcgKyByZWFzb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9ICdFcnJvcihTdHJpbmcpJztcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcihyZWFzb24sIHNpZ25hdHVyZSksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBwYXlsb2FkLmNhbGxiYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuZm9ybWF0T3V0cHV0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyci5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLl9maXJlRXJyb3IoZXJyLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgcGF5bG9hZC5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gUFJPTUlTRVxuICAgICAgICAgICAgaWYgKCFpc1NlbmRUeCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIFBST01JRVZFTlRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCd0cmFuc2FjdGlvbkhhc2gnLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5fY29uZmlybVRyYW5zYWN0aW9uKGRlZmVyLCByZXN1bHQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBTRU5EUyB0aGUgU0lHTkVEIFNJR05BVFVSRVxuICAgICAgICB2YXIgc2VuZFNpZ25lZFR4ID0gZnVuY3Rpb24gKHNpZ24pIHtcbiAgICAgICAgICAgIHZhciBzaWduZWRQYXlsb2FkID0geyAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3NpZ24ucmF3VHJhbnNhY3Rpb25dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmQoc2lnbmVkUGF5bG9hZCwgc2VuZFR4Q2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kICYmIG1ldGhvZC5hY2NvdW50cyAmJiBtZXRob2QuYWNjb3VudHMud2FsbGV0ICYmIG1ldGhvZC5hY2NvdW50cy53YWxsZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdhbGxldDtcbiAgICAgICAgICAgICAgICAvLyBFVEhfU0VORFRSQU5TQUNUSU9OXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IGdldFdhbGxldCgoISF0eCAmJiB0eXBlb2YgdHggPT09ICdvYmplY3QnKSA/IHR4LmZyb20gOiBudWxsLCBtZXRob2QuYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3YWxsZXQgd2FzIGZvdW5kLCBzaWduIHR4LCBhbmQgc2VuZCB1c2luZyBzZW5kUmF3VHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldCAmJiB3YWxsZXQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0eCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4LmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmRlZmF1bHRDaGFpbiAmJiAhdHguY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jaGFpbiA9IG1ldGhvZC5kZWZhdWx0Q2hhaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmRlZmF1bHRIYXJkZm9yayAmJiAhdHguaGFyZGZvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5oYXJkZm9yayA9IG1ldGhvZC5kZWZhdWx0SGFyZGZvcms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmRlZmF1bHRDb21tb24gJiYgIXR4LmNvbW1vbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbW1vbiA9IG1ldGhvZC5kZWZhdWx0Q29tbW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmFjY291bnRzLnNpZ25UcmFuc2FjdGlvbih0eCwgd2FsbGV0LnByaXZhdGVLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oc2VuZFNpZ25lZFR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZlci5ldmVudEVtaXR0ZXIubGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmIGRlZmVyLmV2ZW50RW1pdHRlci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB1c2VybGFuZCBlcnJvciBwcmV2ZW50IGl0IHRvIGJ1YmJsZSB1cCB3aXRoaW4gd2ViMy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVUSF9TSUdOXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NpZ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcGF5bG9hZC5wYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IGdldFdhbGxldChwYXlsb2FkLnBhcmFtc1swXSwgbWV0aG9kLmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2FsbGV0IHdhcyBmb3VuZCwgc2lnbiB0eCwgYW5kIHNlbmQgdXNpbmcgc2VuZFJhd1RyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXQgJiYgd2FsbGV0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gbWV0aG9kLmFjY291bnRzLnNpZ24oZGF0YSwgd2FsbGV0LnByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGxiYWNrKG51bGwsIHNpZ24uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoc2lnbi5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5yZXF1ZXN0TWFuYWdlci5zZW5kKHBheWxvYWQsIHNlbmRUeENhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2VuZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uXG4gICAgICAgIGlmIChpc1NlbmRUeFxuICAgICAgICAgICAgJiYgISFwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICAgICAgJiYgdHlwZW9mIHBheWxvYWQucGFyYW1zWzBdID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgJiYgKHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXS5nYXNQcmljZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAmJiAodHlwZW9mIHBheWxvYWQucGFyYW1zWzBdLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICB8fCB0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMF0ubWF4RmVlUGVyR2FzID09PSAndW5kZWZpbmVkJykpKSB7XG4gICAgICAgICAgICBfaGFuZGxlVHhQcmljaW5nKG1ldGhvZCwgcGF5bG9hZC5wYXJhbXNbMF0pLnRoZW4odHhQcmljaW5nID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHhQcmljaW5nLmdhc1ByaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0uZ2FzUHJpY2UgPSB0eFByaWNpbmcuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4UHJpY2luZy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICYmIHR4UHJpY2luZy5tYXhGZWVQZXJHYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4UHJpY2luZy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0ubWF4RmVlUGVyR2FzID0gdHhQcmljaW5nLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VuZFR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3NlbmRpbmcnLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0KHBheWxvYWQsIG1ldGhvZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1NlbmRUeCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnc2VuZGluZycsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZFJlcXVlc3QocGF5bG9hZCwgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZW5kVHgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdzZW50JywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXIuZXZlbnRFbWl0dGVyO1xuICAgIH07XG4gICAgLy8gbmVjZXNzYXJ5IHRvIGF0dGFjaCB0aGluZ3MgdG8gdGhlIG1ldGhvZFxuICAgIHNlbmQubWV0aG9kID0gbWV0aG9kO1xuICAgIC8vIG5lY2Vzc2FyeSBmb3IgYmF0Y2ggcmVxdWVzdHNcbiAgICBzZW5kLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gc2VuZDtcbn07XG5mdW5jdGlvbiBfaGFuZGxlVHhQcmljaW5nKG1ldGhvZCwgdHgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGdldEJsb2NrQnlOdW1iZXIgPSAobmV3IE1ldGhvZCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgPyB1dGlscy50b0hleChibG9ja051bWJlcikgOiAnbGF0ZXN0JztcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSkpLmNyZWF0ZUZ1bmN0aW9uKG1ldGhvZC5yZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgICAgICB2YXIgZ2V0R2FzUHJpY2UgPSAobmV3IE1ldGhvZCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dldEdhc1ByaWNlJyxcbiAgICAgICAgICAgICAgICBjYWxsOiAnZXRoX2dhc1ByaWNlJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgICAgIH0pKS5jcmVhdGVGdW5jdGlvbihtZXRob2QucmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdldEJsb2NrQnlOdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBnZXRHYXNQcmljZSgpXG4gICAgICAgICAgICBdKS50aGVuKHJlc3BvbnNlcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2Jsb2NrLCBnYXNQcmljZV0gPSByZXNwb25zZXM7XG4gICAgICAgICAgICAgICAgaWYgKCh0eC50eXBlID09PSAnMHgyJyB8fCB0eC50eXBlID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICAgIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcnMtaW8vZXRoZXJzLmpzL2Jsb2IvYmE2ODU0YmRkNWE5MTJmZTg3M2Q1ZGE0OTRjYjVjNjJjMTkwYWRkZS9wYWNrYWdlcy9hYnN0cmFjdC1wcm92aWRlci9zcmMudHMvaW5kZXgudHMjTDIzMFxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8ICcweDk1MDJGOTAwJzsgLy8gMi41IEd3ZWlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnRvSGV4KHV0aWxzLnRvQk4oYmxvY2suYmFzZUZlZVBlckdhcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm11bCh1dGlscy50b0JOKDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHV0aWxzLnRvQk4obWF4UHJpb3JpdHlGZWVQZXJHYXMpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgdHgubWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBlaXAtMTU1OVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGdhc1ByaWNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXZlcnQgcmVhc29uIHN0cmluZyBpZiBleGlzdGluZyBvciBvdGhlcndpc2UgZmFsc2UuXG4gKlxuICogQG1ldGhvZCBnZXRSZXZlcnRSZWFzb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdHhPcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gYmxvY2tOdW1iZXJcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCb29sZWFufFN0cmluZz59XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZ2V0UmV2ZXJ0UmVhc29uID0gZnVuY3Rpb24gKHR4T3B0aW9ucywgYmxvY2tOdW1iZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgKG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2NhbGwnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9jYWxsJyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGFiaUNvZGVyOiBzZWxmLmFiaUNvZGVyLFxuICAgICAgICAgICAgaGFuZGxlUmV2ZXJ0OiB0cnVlXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmNyZWF0ZUZ1bmN0aW9uKHNlbGYucmVxdWVzdE1hbmFnZXIpKHR4T3B0aW9ucywgdXRpbHMubnVtYmVyVG9IZXgoYmxvY2tOdW1iZXIpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGVycm9yLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGhleCBzdHJpbmcgaXMgYSByZXZlcnQgbWVzc2FnZSBmcm9tIHRoZSBFVk1cbiAqXG4gKiBAbWV0aG9kIGlzUmV2ZXJ0UmVhc29uU3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSBIZXggc3RyaW5nIHByZWZpeGVkIHdpdGggMHhcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5pc1JldmVydFJlYXNvblN0cmluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiAoKGRhdGEubGVuZ3RoIC0gMikgLyAyKSAlIDMyID09PSA0ICYmIGRhdGEuc3Vic3RyaW5nKDAsIDEwKSA9PT0gJzB4MDhjMzc5YTAnO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgdGhlIHB1cmUgSlNPTlJQQyByZXF1ZXN0IHdoaWNoIGNhbiBiZSB1c2VkIGluIGEgYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFxuICogQHJldHVybiB7T2JqZWN0fSBqc29ucnBjIHJlcXVlc3RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcGF5bG9hZC5mb3JtYXQgPSB0aGlzLmZvcm1hdE91dHB1dC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/lib/index.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/lib/index.js ***!
  \********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2016\n */\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/node_modules/eventemitter3/index.js\");\n/**\n * This function generates a defer promise and adds eventEmitter functionality to it\n *\n * @method eventifiedPromise\n */\nvar PromiEvent = function PromiEvent(justPromise) {\n    var resolve, reject, eventEmitter = new Promise(function () {\n        resolve = arguments[0];\n        reject = arguments[1];\n    });\n    if (justPromise) {\n        return {\n            resolve: resolve,\n            reject: reject,\n            eventEmitter: eventEmitter\n        };\n    }\n    // get eventEmitter\n    var emitter = new EventEmitter();\n    // add eventEmitter to the promise\n    eventEmitter._events = emitter._events;\n    eventEmitter.emit = emitter.emit;\n    eventEmitter.on = emitter.on;\n    eventEmitter.once = emitter.once;\n    eventEmitter.off = emitter.off;\n    eventEmitter.listeners = emitter.listeners;\n    eventEmitter.addListener = emitter.addListener;\n    eventEmitter.removeListener = emitter.removeListener;\n    eventEmitter.removeAllListeners = emitter.removeAllListeners;\n    return {\n        resolve: resolve,\n        reject: reject,\n        eventEmitter: eventEmitter\n    };\n};\nPromiEvent.resolve = function (value) {\n    var promise = PromiEvent(true);\n    promise.resolve(value);\n    return promise.eventEmitter;\n};\nmodule.exports = PromiEvent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXByb21pZXZlbnQvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyxrSUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1wcm9taWV2ZW50L2xpYi9pbmRleC5qcz9iMWFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxNlxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIGEgZGVmZXIgcHJvbWlzZSBhbmQgYWRkcyBldmVudEVtaXR0ZXIgZnVuY3Rpb25hbGl0eSB0byBpdFxuICpcbiAqIEBtZXRob2QgZXZlbnRpZmllZFByb21pc2VcbiAqL1xudmFyIFByb21pRXZlbnQgPSBmdW5jdGlvbiBQcm9taUV2ZW50KGp1c3RQcm9taXNlKSB7XG4gICAgdmFyIHJlc29sdmUsIHJlamVjdCwgZXZlbnRFbWl0dGVyID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICByZWplY3QgPSBhcmd1bWVudHNbMV07XG4gICAgfSk7XG4gICAgaWYgKGp1c3RQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlclxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBnZXQgZXZlbnRFbWl0dGVyXG4gICAgdmFyIGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLy8gYWRkIGV2ZW50RW1pdHRlciB0byB0aGUgcHJvbWlzZVxuICAgIGV2ZW50RW1pdHRlci5fZXZlbnRzID0gZW1pdHRlci5fZXZlbnRzO1xuICAgIGV2ZW50RW1pdHRlci5lbWl0ID0gZW1pdHRlci5lbWl0O1xuICAgIGV2ZW50RW1pdHRlci5vbiA9IGVtaXR0ZXIub247XG4gICAgZXZlbnRFbWl0dGVyLm9uY2UgPSBlbWl0dGVyLm9uY2U7XG4gICAgZXZlbnRFbWl0dGVyLm9mZiA9IGVtaXR0ZXIub2ZmO1xuICAgIGV2ZW50RW1pdHRlci5saXN0ZW5lcnMgPSBlbWl0dGVyLmxpc3RlbmVycztcbiAgICBldmVudEVtaXR0ZXIuYWRkTGlzdGVuZXIgPSBlbWl0dGVyLmFkZExpc3RlbmVyO1xuICAgIGV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9IGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXI7XG4gICAgZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyA9IGVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlclxuICAgIH07XG59O1xuUHJvbWlFdmVudC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taUV2ZW50KHRydWUpO1xuICAgIHByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHByb21pc2UuZXZlbnRFbWl0dGVyO1xufTtcbm1vZHVsZS5leHBvcnRzID0gUHJvbWlFdmVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/node_modules/eventemitter3/index.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/node_modules/eventemitter3/index.js ***!
  \*******************************************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXByb21pZXZlbnQvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1wcm9taWV2ZW50L25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2ZlOWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/batch.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/batch.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file batch.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2015\n */\n\nvar Jsonrpc = __webpack_require__(/*! ./jsonrpc */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/jsonrpc.js\");\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar Batch = function (requestManager) {\n    this.requestManager = requestManager;\n    this.requests = [];\n};\n/**\n * Should be called to add create new request to batch request\n *\n * @method add\n * @param {Object} jsonrpc requet object\n */\nBatch.prototype.add = function (request) {\n    this.requests.push(request);\n};\n/**\n * Should be called to execute batch request\n *\n * @method execute\n */\nBatch.prototype.execute = function () {\n    var requests = this.requests;\n    this.requestManager.sendBatch(requests, function (err, results) {\n        results = results || [];\n        requests.map(function (request, index) {\n            return results[index] || {};\n        }).forEach(function (result, index) {\n            if (requests[index].callback) {\n                if (result && result.error) {\n                    return requests[index].callback(errors.ErrorResponse(result));\n                }\n                if (!Jsonrpc.isValidResponse(result)) {\n                    return requests[index].callback(errors.InvalidResponse(result));\n                }\n                try {\n                    requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);\n                }\n                catch (err) {\n                    requests[index].callback(err);\n                }\n            }\n        });\n    });\n};\nmodule.exports = Batch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXJlcXVlc3RtYW5hZ2VyL2xpYi9iYXRjaC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLDZHQUFXO0FBQ2pDLGFBQWEsMElBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1yZXF1ZXN0bWFuYWdlci9saWIvYmF0Y2guanM/YjQwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBiYXRjaC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgSnNvbnJwYyA9IHJlcXVpcmUoJy4vanNvbnJwYycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIEJhdGNoID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMucmVxdWVzdHMgPSBbXTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gYWRkIGNyZWF0ZSBuZXcgcmVxdWVzdCB0byBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBqc29ucnBjIHJlcXVldCBvYmplY3RcbiAqL1xuQmF0Y2gucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgdGhpcy5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBleGVjdXRlIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqL1xuQmF0Y2gucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcXVlc3RzID0gdGhpcy5yZXF1ZXN0cztcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyLnNlbmRCYXRjaChyZXF1ZXN0cywgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgICAgICAgcmVxdWVzdHMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0LCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbaW5kZXhdIHx8IHt9O1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdHNbaW5kZXhdLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RzW2luZGV4XS5jYWxsYmFjayhlcnJvcnMuRXJyb3JSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0c1tpbmRleF0uY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHNbaW5kZXhdLmNhbGxiYWNrKG51bGwsIHJlcXVlc3RzW2luZGV4XS5mb3JtYXQgPyByZXF1ZXN0c1tpbmRleF0uZm9ybWF0KHJlc3VsdC5yZXN1bHQpIDogcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHNbaW5kZXhdLmNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEJhdGNoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/batch.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/givenProvider.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/givenProvider.js ***!
  \********************************************************************************************************/
/***/ (function(module) {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file givenProvider.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar givenProvider = null;\n// ADD GIVEN PROVIDER\n/* jshint ignore:start */\nvar global;\ntry {\n    global = Function('return this')();\n}\ncatch (e) {\n    global = window;\n}\n// EIP-1193: window.ethereum\nif (typeof global.ethereum !== 'undefined') {\n    givenProvider = global.ethereum;\n    // Legacy web3.currentProvider\n}\nelse if (typeof global.web3 !== 'undefined' && global.web3.currentProvider) {\n    if (global.web3.currentProvider.sendAsync) {\n        global.web3.currentProvider.send = global.web3.currentProvider.sendAsync;\n        delete global.web3.currentProvider.sendAsync;\n    }\n    // if connection is 'ipcProviderWrapper', add subscription support\n    if (!global.web3.currentProvider.on &&\n        global.web3.currentProvider.connection &&\n        global.web3.currentProvider.connection.constructor.name === 'ipcProviderWrapper') {\n        global.web3.currentProvider.on = function (type, callback) {\n            if (typeof callback !== 'function')\n                throw new Error('The second parameter callback must be a function.');\n            switch (type) {\n                case 'data':\n                    this.connection.on('data', function (data) {\n                        var result = '';\n                        data = data.toString();\n                        try {\n                            result = JSON.parse(data);\n                        }\n                        catch (e) {\n                            return callback(new Error('Couldn\\'t parse response data' + data));\n                        }\n                        // notification\n                        if (!result.id && result.method.indexOf('_subscription') !== -1) {\n                            callback(null, result);\n                        }\n                    });\n                    break;\n                default:\n                    this.connection.on(type, callback);\n                    break;\n            }\n        };\n    }\n    givenProvider = global.web3.currentProvider;\n}\n/* jshint ignore:end */\nmodule.exports = givenProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXJlcXVlc3RtYW5hZ2VyL2xpYi9naXZlblByb3ZpZGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXJlcXVlc3RtYW5hZ2VyL2xpYi9naXZlblByb3ZpZGVyLmpzPzQ4ODciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIGdpdmVuUHJvdmlkZXIuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZ2l2ZW5Qcm92aWRlciA9IG51bGw7XG4vLyBBREQgR0lWRU4gUFJPVklERVJcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbnZhciBnbG9iYWw7XG50cnkge1xuICAgIGdsb2JhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5jYXRjaCAoZSkge1xuICAgIGdsb2JhbCA9IHdpbmRvdztcbn1cbi8vIEVJUC0xMTkzOiB3aW5kb3cuZXRoZXJldW1cbmlmICh0eXBlb2YgZ2xvYmFsLmV0aGVyZXVtICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdpdmVuUHJvdmlkZXIgPSBnbG9iYWwuZXRoZXJldW07XG4gICAgLy8gTGVnYWN5IHdlYjMuY3VycmVudFByb3ZpZGVyXG59XG5lbHNlIGlmICh0eXBlb2YgZ2xvYmFsLndlYjMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC53ZWIzLmN1cnJlbnRQcm92aWRlcikge1xuICAgIGlmIChnbG9iYWwud2ViMy5jdXJyZW50UHJvdmlkZXIuc2VuZEFzeW5jKSB7XG4gICAgICAgIGdsb2JhbC53ZWIzLmN1cnJlbnRQcm92aWRlci5zZW5kID0gZ2xvYmFsLndlYjMuY3VycmVudFByb3ZpZGVyLnNlbmRBc3luYztcbiAgICAgICAgZGVsZXRlIGdsb2JhbC53ZWIzLmN1cnJlbnRQcm92aWRlci5zZW5kQXN5bmM7XG4gICAgfVxuICAgIC8vIGlmIGNvbm5lY3Rpb24gaXMgJ2lwY1Byb3ZpZGVyV3JhcHBlcicsIGFkZCBzdWJzY3JpcHRpb24gc3VwcG9ydFxuICAgIGlmICghZ2xvYmFsLndlYjMuY3VycmVudFByb3ZpZGVyLm9uICYmXG4gICAgICAgIGdsb2JhbC53ZWIzLmN1cnJlbnRQcm92aWRlci5jb25uZWN0aW9uICYmXG4gICAgICAgIGdsb2JhbC53ZWIzLmN1cnJlbnRQcm92aWRlci5jb25uZWN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdpcGNQcm92aWRlcldyYXBwZXInKSB7XG4gICAgICAgIGdsb2JhbC53ZWIzLmN1cnJlbnRQcm92aWRlci5vbiA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgcGFyYW1ldGVyIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQ291bGRuXFwndCBwYXJzZSByZXNwb25zZSBkYXRhJyArIGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuaWQgJiYgcmVzdWx0Lm1ldGhvZC5pbmRleE9mKCdfc3Vic2NyaXB0aW9uJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbih0eXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnaXZlblByb3ZpZGVyID0gZ2xvYmFsLndlYjMuY3VycmVudFByb3ZpZGVyO1xufVxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbm1vZHVsZS5leHBvcnRzID0gZ2l2ZW5Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/givenProvider.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/index.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/index.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst { callbackify } = __webpack_require__(/*! util */ \"../../node_modules/util/util.js\");\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar Jsonrpc = __webpack_require__(/*! ./jsonrpc.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/jsonrpc.js\");\nvar BatchManager = __webpack_require__(/*! ./batch.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/batch.js\");\nvar givenProvider = __webpack_require__(/*! ./givenProvider.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/givenProvider.js\");\n/**\n * It's responsible for passing messages to providers\n * It's also responsible for polling the ethereum node for incoming messages\n * Default poll timeout is 1 second\n * Singleton\n *\n * @param {string|Object}provider\n * @param {Net.Socket} net\n *\n * @constructor\n */\nvar RequestManager = function RequestManager(provider, net) {\n    this.provider = null;\n    this.providers = RequestManager.providers;\n    this.setProvider(provider, net);\n    this.subscriptions = new Map();\n};\nRequestManager.givenProvider = givenProvider;\nRequestManager.providers = {\n    WebsocketProvider: __webpack_require__(/*! web3-providers-ws */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/index.js\"),\n    HttpProvider: __webpack_require__(/*! web3-providers-http */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-http/lib/index.js\"),\n    IpcProvider: __webpack_require__(/*! web3-providers-ipc */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ipc/lib/index.js\")\n};\n/**\n * Should be used to set provider of request manager\n *\n * @method setProvider\n *\n * @param {Object} provider\n * @param {net.Socket} net\n *\n * @returns void\n */\nRequestManager.prototype.setProvider = function (provider, net) {\n    var _this = this;\n    // autodetect provider\n    if (provider && typeof provider === 'string' && this.providers) {\n        // HTTP\n        if (/^http(s)?:\\/\\//i.test(provider)) {\n            provider = new this.providers.HttpProvider(provider);\n            // WS\n        }\n        else if (/^ws(s)?:\\/\\//i.test(provider)) {\n            provider = new this.providers.WebsocketProvider(provider);\n            // IPC\n        }\n        else if (provider && typeof net === 'object' && typeof net.connect === 'function') {\n            provider = new this.providers.IpcProvider(provider, net);\n        }\n        else if (provider) {\n            throw new Error('Can\\'t autodetect provider for \"' + provider + '\"');\n        }\n    }\n    // reset the old one before changing, if still connected\n    if (this.provider && this.provider.connected)\n        this.clearSubscriptions();\n    this.provider = provider || null;\n    // listen to incoming notifications\n    if (this.provider && this.provider.on) {\n        if (typeof provider.request === 'function') { // EIP-1193 provider\n            this.provider.on('message', function (payload) {\n                if (payload && payload.type === 'eth_subscription' && payload.data) {\n                    const data = payload.data;\n                    if (data.subscription && _this.subscriptions.has(data.subscription)) {\n                        _this.subscriptions.get(data.subscription).callback(null, data.result);\n                    }\n                }\n            });\n        }\n        else { // legacy provider subscription event\n            this.provider.on('data', function data(result, deprecatedResult) {\n                result = result || deprecatedResult; // this is for possible old providers, which may had the error first handler\n                // if result is a subscription, call callback for that subscription\n                if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {\n                    _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);\n                }\n            });\n        }\n        // resubscribe if the provider has reconnected\n        this.provider.on('connect', function connect() {\n            _this.subscriptions.forEach(function (subscription) {\n                subscription.subscription.resubscribe();\n            });\n        });\n        // notify all subscriptions about the error condition\n        this.provider.on('error', function error(error) {\n            _this.subscriptions.forEach(function (subscription) {\n                subscription.callback(error);\n            });\n        });\n        // notify all subscriptions about bad close conditions\n        const disconnect = function disconnect(event) {\n            if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {\n                _this.subscriptions.forEach(function (subscription) {\n                    subscription.callback(errors.ConnectionCloseError(event));\n                    _this.subscriptions.delete(subscription.subscription.id);\n                });\n                if (_this.provider && _this.provider.emit) {\n                    _this.provider.emit('error', errors.ConnectionCloseError(event));\n                }\n            }\n            if (_this.provider && _this.provider.emit) {\n                _this.provider.emit('end', event);\n            }\n        };\n        // TODO: Remove close once the standard allows it\n        this.provider.on('close', disconnect);\n        this.provider.on('disconnect', disconnect);\n        // TODO add end, timeout??\n    }\n};\n/**\n * Asynchronously send request to provider.\n * Prefers to use the `request` method available on the provider as specified in [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193).\n * If `request` is not available, falls back to `sendAsync` and `send` respectively.\n * @method send\n * @param {Object} data\n * @param {Function} callback\n */\nRequestManager.prototype.send = function (data, callback) {\n    callback = callback || function () { };\n    if (!this.provider) {\n        return callback(errors.InvalidProvider());\n    }\n    const { method, params } = data;\n    const jsonrpcPayload = Jsonrpc.toPayload(method, params);\n    const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);\n    if (this.provider.request) {\n        const callbackRequest = callbackify(this.provider.request.bind(this.provider));\n        const requestArgs = { method, params };\n        callbackRequest(requestArgs, callback);\n    }\n    else if (this.provider.sendAsync) {\n        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);\n    }\n    else if (this.provider.send) {\n        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);\n    }\n    else {\n        throw new Error('Provider does not have a request or send method to use.');\n    }\n};\n/**\n * Asynchronously send batch request.\n * Only works if provider supports batch methods through `sendAsync` or `send`.\n * @method sendBatch\n * @param {Array} data - array of payload objects\n * @param {Function} callback\n */\nRequestManager.prototype.sendBatch = function (data, callback) {\n    if (!this.provider) {\n        return callback(errors.InvalidProvider());\n    }\n    var payload = Jsonrpc.toBatchPayload(data);\n    this.provider[this.provider.sendAsync ? 'sendAsync' : 'send'](payload, function (err, results) {\n        if (err) {\n            return callback(err);\n        }\n        if (!Array.isArray(results)) {\n            return callback(errors.InvalidResponse(results));\n        }\n        callback(null, results);\n    });\n};\n/**\n * Waits for notifications\n *\n * @method addSubscription\n * @param {Subscription} subscription         the subscription\n * @param {String} type         the subscription namespace (eth, personal, etc)\n * @param {Function} callback   the callback to call for incoming notifications\n */\nRequestManager.prototype.addSubscription = function (subscription, callback) {\n    if (this.provider.on) {\n        this.subscriptions.set(subscription.id, {\n            callback: callback,\n            subscription: subscription\n        });\n    }\n    else {\n        throw new Error('The provider doesn\\'t support subscriptions: ' + this.provider.constructor.name);\n    }\n};\n/**\n * Waits for notifications\n *\n * @method removeSubscription\n * @param {String} id           the subscription id\n * @param {Function} callback   fired once the subscription is removed\n */\nRequestManager.prototype.removeSubscription = function (id, callback) {\n    if (this.subscriptions.has(id)) {\n        var type = this.subscriptions.get(id).subscription.options.type;\n        // remove subscription first to avoid reentry\n        this.subscriptions.delete(id);\n        // then, try to actually unsubscribe\n        this.send({\n            method: type + '_unsubscribe',\n            params: [id]\n        }, callback);\n        return;\n    }\n    if (typeof callback === 'function') {\n        // call the callback if the subscription was already removed\n        callback(null);\n    }\n};\n/**\n * Should be called to reset the subscriptions\n *\n * @method reset\n *\n * @returns {boolean}\n */\nRequestManager.prototype.clearSubscriptions = function (keepIsSyncing) {\n    try {\n        var _this = this;\n        // uninstall all subscriptions\n        if (this.subscriptions.size > 0) {\n            this.subscriptions.forEach(function (value, id) {\n                if (!keepIsSyncing || value.name !== 'syncing')\n                    _this.removeSubscription(id);\n            });\n        }\n        //  reset notification callbacks etc.\n        if (this.provider.reset)\n            this.provider.reset();\n        return true;\n    }\n    catch (e) {\n        throw new Error(`Error while clearing subscriptions: ${e}`);\n    }\n};\n/**\n * Evaluates WS close event\n *\n * @method _isCleanClose\n *\n * @param {CloseEvent | boolean} event WS close event or exception flag\n *\n * @returns {boolean}\n */\nRequestManager.prototype._isCleanCloseEvent = function (event) {\n    return typeof event === 'object' && ([1000].includes(event.code) || event.wasClean === true);\n};\n/**\n * Detects Ipc close error. The node.net module emits ('close', isException)\n *\n * @method _isIpcCloseError\n *\n * @param {CloseEvent | boolean} event WS close event or exception flag\n *\n * @returns {boolean}\n */\nRequestManager.prototype._isIpcCloseError = function (event) {\n    return typeof event === 'boolean' && event;\n};\n/**\n * The jsonrpc result callback for RequestManager.send\n *\n * @method _jsonrpcResultCallback\n *\n * @param {Function} callback the callback to use\n * @param {Object} payload the jsonrpc payload\n *\n * @returns {Function} return callback of form (err, result)\n *\n */\nRequestManager.prototype._jsonrpcResultCallback = function (callback, payload) {\n    return function (err, result) {\n        if (result && result.id && payload.id !== result.id) {\n            return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));\n        }\n        if (err) {\n            return callback(err);\n        }\n        if (result && result.error) {\n            return callback(errors.ErrorResponse(result));\n        }\n        if (!Jsonrpc.isValidResponse(result)) {\n            return callback(errors.InvalidResponse(result));\n        }\n        callback(null, result.result);\n    };\n};\nmodule.exports = {\n    Manager: RequestManager,\n    BatchManager: BatchManager\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXJlcXVlc3RtYW5hZ2VyL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw2Q0FBTTtBQUN0QyxhQUFhLDBJQUFtQztBQUNoRCxjQUFjLG1CQUFPLENBQUMsZ0hBQWM7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsNEdBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsNEhBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDRHQUFtQjtBQUNsRCxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBcUI7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsOEdBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVcsYUFBYSxXQUFXLE9BQU8sd0JBQXdCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1yZXF1ZXN0bWFuYWdlci9saWIvaW5kZXguanM/Mjc3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHsgY2FsbGJhY2tpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmVycm9ycztcbnZhciBKc29ucnBjID0gcmVxdWlyZSgnLi9qc29ucnBjLmpzJyk7XG52YXIgQmF0Y2hNYW5hZ2VyID0gcmVxdWlyZSgnLi9iYXRjaC5qcycpO1xudmFyIGdpdmVuUHJvdmlkZXIgPSByZXF1aXJlKCcuL2dpdmVuUHJvdmlkZXIuanMnKTtcbi8qKlxuICogSXQncyByZXNwb25zaWJsZSBmb3IgcGFzc2luZyBtZXNzYWdlcyB0byBwcm92aWRlcnNcbiAqIEl0J3MgYWxzbyByZXNwb25zaWJsZSBmb3IgcG9sbGluZyB0aGUgZXRoZXJldW0gbm9kZSBmb3IgaW5jb21pbmcgbWVzc2FnZXNcbiAqIERlZmF1bHQgcG9sbCB0aW1lb3V0IGlzIDEgc2Vjb25kXG4gKiBTaW5nbGV0b25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9cHJvdmlkZXJcbiAqIEBwYXJhbSB7TmV0LlNvY2tldH0gbmV0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIFJlcXVlc3RNYW5hZ2VyKHByb3ZpZGVyLCBuZXQpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb3ZpZGVycyA9IFJlcXVlc3RNYW5hZ2VyLnByb3ZpZGVycztcbiAgICB0aGlzLnNldFByb3ZpZGVyKHByb3ZpZGVyLCBuZXQpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbn07XG5SZXF1ZXN0TWFuYWdlci5naXZlblByb3ZpZGVyID0gZ2l2ZW5Qcm92aWRlcjtcblJlcXVlc3RNYW5hZ2VyLnByb3ZpZGVycyA9IHtcbiAgICBXZWJzb2NrZXRQcm92aWRlcjogcmVxdWlyZSgnd2ViMy1wcm92aWRlcnMtd3MnKSxcbiAgICBIdHRwUHJvdmlkZXI6IHJlcXVpcmUoJ3dlYjMtcHJvdmlkZXJzLWh0dHAnKSxcbiAgICBJcGNQcm92aWRlcjogcmVxdWlyZSgnd2ViMy1wcm92aWRlcnMtaXBjJylcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHNldCBwcm92aWRlciBvZiByZXF1ZXN0IG1hbmFnZXJcbiAqXG4gKiBAbWV0aG9kIHNldFByb3ZpZGVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3ZpZGVyXG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IG5ldFxuICpcbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBuZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIGF1dG9kZXRlY3QgcHJvdmlkZXJcbiAgICBpZiAocHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyID09PSAnc3RyaW5nJyAmJiB0aGlzLnByb3ZpZGVycykge1xuICAgICAgICAvLyBIVFRQXG4gICAgICAgIGlmICgvXmh0dHAocyk/OlxcL1xcLy9pLnRlc3QocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IG5ldyB0aGlzLnByb3ZpZGVycy5IdHRwUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgICAgLy8gV1NcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXndzKHMpPzpcXC9cXC8vaS50ZXN0KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgdGhpcy5wcm92aWRlcnMuV2Vic29ja2V0UHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgICAgLy8gSVBDXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgJiYgdHlwZW9mIG5ldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5ldC5jb25uZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IG5ldyB0aGlzLnByb3ZpZGVycy5JcGNQcm92aWRlcihwcm92aWRlciwgbmV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGF1dG9kZXRlY3QgcHJvdmlkZXIgZm9yIFwiJyArIHByb3ZpZGVyICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVzZXQgdGhlIG9sZCBvbmUgYmVmb3JlIGNoYW5naW5nLCBpZiBzdGlsbCBjb25uZWN0ZWRcbiAgICBpZiAodGhpcy5wcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyLmNvbm5lY3RlZClcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbnMoKTtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXIgfHwgbnVsbDtcbiAgICAvLyBsaXN0ZW4gdG8gaW5jb21pbmcgbm90aWZpY2F0aW9uc1xuICAgIGlmICh0aGlzLnByb3ZpZGVyICYmIHRoaXMucHJvdmlkZXIub24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlci5yZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7IC8vIEVJUC0xMTkzIHByb3ZpZGVyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnR5cGUgPT09ICdldGhfc3Vic2NyaXB0aW9uJyAmJiBwYXlsb2FkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc3Vic2NyaXB0aW9uICYmIF90aGlzLnN1YnNjcmlwdGlvbnMuaGFzKGRhdGEuc3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucy5nZXQoZGF0YS5zdWJzY3JpcHRpb24pLmNhbGxiYWNrKG51bGwsIGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBsZWdhY3kgcHJvdmlkZXIgc3Vic2NyaXB0aW9uIGV2ZW50XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdkYXRhJywgZnVuY3Rpb24gZGF0YShyZXN1bHQsIGRlcHJlY2F0ZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgZGVwcmVjYXRlZFJlc3VsdDsgLy8gdGhpcyBpcyBmb3IgcG9zc2libGUgb2xkIHByb3ZpZGVycywgd2hpY2ggbWF5IGhhZCB0aGUgZXJyb3IgZmlyc3QgaGFuZGxlclxuICAgICAgICAgICAgICAgIC8vIGlmIHJlc3VsdCBpcyBhIHN1YnNjcmlwdGlvbiwgY2FsbCBjYWxsYmFjayBmb3IgdGhhdCBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1ldGhvZCAmJiByZXN1bHQucGFyYW1zICYmIHJlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uICYmIF90aGlzLnN1YnNjcmlwdGlvbnMuaGFzKHJlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zLmdldChyZXN1bHQucGFyYW1zLnN1YnNjcmlwdGlvbikuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc3Vic2NyaWJlIGlmIHRoZSBwcm92aWRlciBoYXMgcmVjb25uZWN0ZWRcbiAgICAgICAgdGhpcy5wcm92aWRlci5vbignY29ubmVjdCcsIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb24ucmVzdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbm90aWZ5IGFsbCBzdWJzY3JpcHRpb25zIGFib3V0IHRoZSBlcnJvciBjb25kaXRpb25cbiAgICAgICAgdGhpcy5wcm92aWRlci5vbignZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3RpZnkgYWxsIHN1YnNjcmlwdGlvbnMgYWJvdXQgYmFkIGNsb3NlIGNvbmRpdGlvbnNcbiAgICAgICAgY29uc3QgZGlzY29ubmVjdCA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2lzQ2xlYW5DbG9zZUV2ZW50KGV2ZW50KSB8fCBfdGhpcy5faXNJcGNDbG9zZUVycm9yKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhlcnJvcnMuQ29ubmVjdGlvbkNsb3NlRXJyb3IoZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3ZpZGVyICYmIF90aGlzLnByb3ZpZGVyLmVtaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvdmlkZXIuZW1pdCgnZXJyb3InLCBlcnJvcnMuQ29ubmVjdGlvbkNsb3NlRXJyb3IoZXZlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvdmlkZXIgJiYgX3RoaXMucHJvdmlkZXIuZW1pdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3ZpZGVyLmVtaXQoJ2VuZCcsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGNsb3NlIG9uY2UgdGhlIHN0YW5kYXJkIGFsbG93cyBpdFxuICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdjbG9zZScsIGRpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgIC8vIFRPRE8gYWRkIGVuZCwgdGltZW91dD8/XG4gICAgfVxufTtcbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyLlxuICogUHJlZmVycyB0byB1c2UgdGhlIGByZXF1ZXN0YCBtZXRob2QgYXZhaWxhYmxlIG9uIHRoZSBwcm92aWRlciBhcyBzcGVjaWZpZWQgaW4gW0VJUC0xMTkzXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMpLlxuICogSWYgYHJlcXVlc3RgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2sgdG8gYHNlbmRBc3luY2AgYW5kIGBzZW5kYCByZXNwZWN0aXZlbHkuXG4gKiBAbWV0aG9kIHNlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICB9XG4gICAgY29uc3QgeyBtZXRob2QsIHBhcmFtcyB9ID0gZGF0YTtcbiAgICBjb25zdCBqc29ucnBjUGF5bG9hZCA9IEpzb25ycGMudG9QYXlsb2FkKG1ldGhvZCwgcGFyYW1zKTtcbiAgICBjb25zdCBqc29ucnBjUmVzdWx0Q2FsbGJhY2sgPSB0aGlzLl9qc29ucnBjUmVzdWx0Q2FsbGJhY2soY2FsbGJhY2ssIGpzb25ycGNQYXlsb2FkKTtcbiAgICBpZiAodGhpcy5wcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrUmVxdWVzdCA9IGNhbGxiYWNraWZ5KHRoaXMucHJvdmlkZXIucmVxdWVzdC5iaW5kKHRoaXMucHJvdmlkZXIpKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEFyZ3MgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgIGNhbGxiYWNrUmVxdWVzdChyZXF1ZXN0QXJncywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnByb3ZpZGVyLnNlbmRBc3luYykge1xuICAgICAgICB0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhqc29ucnBjUGF5bG9hZCwganNvbnJwY1Jlc3VsdENhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5wcm92aWRlci5zZW5kKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIuc2VuZChqc29ucnBjUGF5bG9hZCwganNvbnJwY1Jlc3VsdENhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgZG9lcyBub3QgaGF2ZSBhIHJlcXVlc3Qgb3Igc2VuZCBtZXRob2QgdG8gdXNlLicpO1xuICAgIH1cbn07XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNlbmQgYmF0Y2ggcmVxdWVzdC5cbiAqIE9ubHkgd29ya3MgaWYgcHJvdmlkZXIgc3VwcG9ydHMgYmF0Y2ggbWV0aG9kcyB0aHJvdWdoIGBzZW5kQXN5bmNgIG9yIGBzZW5kYC5cbiAqIEBtZXRob2Qgc2VuZEJhdGNoXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gYXJyYXkgb2YgcGF5bG9hZCBvYmplY3RzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZEJhdGNoID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZCA9IEpzb25ycGMudG9CYXRjaFBheWxvYWQoZGF0YSk7XG4gICAgdGhpcy5wcm92aWRlclt0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyA/ICdzZW5kQXN5bmMnIDogJ3NlbmQnXShwYXlsb2FkLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVzdWx0cykpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgIH0pO1xufTtcbi8qKlxuICogV2FpdHMgZm9yIG5vdGlmaWNhdGlvbnNcbiAqXG4gKiBAbWV0aG9kIGFkZFN1YnNjcmlwdGlvblxuICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiAgICAgICAgIHRoZSBzdWJzY3JpcHRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICAgICAgdGhlIHN1YnNjcmlwdGlvbiBuYW1lc3BhY2UgKGV0aCwgcGVyc29uYWwsIGV0YylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgdGhlIGNhbGxiYWNrIHRvIGNhbGwgZm9yIGluY29taW5nIG5vdGlmaWNhdGlvbnNcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLmFkZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucHJvdmlkZXIub24pIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWJzY3JpcHRpb24uaWQsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZXIgZG9lc25cXCd0IHN1cHBvcnQgc3Vic2NyaXB0aW9uczogJyArIHRoaXMucHJvdmlkZXIuY29uc3RydWN0b3IubmFtZSk7XG4gICAgfVxufTtcbi8qKlxuICogV2FpdHMgZm9yIG5vdGlmaWNhdGlvbnNcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZVN1YnNjcmlwdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGlkICAgICAgICAgICB0aGUgc3Vic2NyaXB0aW9uIGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIGZpcmVkIG9uY2UgdGhlIHN1YnNjcmlwdGlvbiBpcyByZW1vdmVkXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoaWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucy5oYXMoaWQpKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChpZCkuc3Vic2NyaXB0aW9uLm9wdGlvbnMudHlwZTtcbiAgICAgICAgLy8gcmVtb3ZlIHN1YnNjcmlwdGlvbiBmaXJzdCB0byBhdm9pZCByZWVudHJ5XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICAvLyB0aGVuLCB0cnkgdG8gYWN0dWFsbHkgdW5zdWJzY3JpYmVcbiAgICAgICAgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIG1ldGhvZDogdHlwZSArICdfdW5zdWJzY3JpYmUnLFxuICAgICAgICAgICAgcGFyYW1zOiBbaWRdXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIGlmIHRoZSBzdWJzY3JpcHRpb24gd2FzIGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHJlc2V0IHRoZSBzdWJzY3JpcHRpb25zXG4gKlxuICogQG1ldGhvZCByZXNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuY2xlYXJTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKGtlZXBJc1N5bmNpbmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyB1bmluc3RhbGwgYWxsIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucy5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpZCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcElzU3luY2luZyB8fCB2YWx1ZS5uYW1lICE9PSAnc3luY2luZycpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAgcmVzZXQgbm90aWZpY2F0aW9uIGNhbGxiYWNrcyBldGMuXG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVyLnJlc2V0KVxuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5yZXNldCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBjbGVhcmluZyBzdWJzY3JpcHRpb25zOiAke2V9YCk7XG4gICAgfVxufTtcbi8qKlxuICogRXZhbHVhdGVzIFdTIGNsb3NlIGV2ZW50XG4gKlxuICogQG1ldGhvZCBfaXNDbGVhbkNsb3NlXG4gKlxuICogQHBhcmFtIHtDbG9zZUV2ZW50IHwgYm9vbGVhbn0gZXZlbnQgV1MgY2xvc2UgZXZlbnQgb3IgZXhjZXB0aW9uIGZsYWdcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLl9pc0NsZWFuQ2xvc2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgZXZlbnQgPT09ICdvYmplY3QnICYmIChbMTAwMF0uaW5jbHVkZXMoZXZlbnQuY29kZSkgfHwgZXZlbnQud2FzQ2xlYW4gPT09IHRydWUpO1xufTtcbi8qKlxuICogRGV0ZWN0cyBJcGMgY2xvc2UgZXJyb3IuIFRoZSBub2RlLm5ldCBtb2R1bGUgZW1pdHMgKCdjbG9zZScsIGlzRXhjZXB0aW9uKVxuICpcbiAqIEBtZXRob2QgX2lzSXBjQ2xvc2VFcnJvclxuICpcbiAqIEBwYXJhbSB7Q2xvc2VFdmVudCB8IGJvb2xlYW59IGV2ZW50IFdTIGNsb3NlIGV2ZW50IG9yIGV4Y2VwdGlvbiBmbGFnXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5faXNJcGNDbG9zZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBldmVudCA9PT0gJ2Jvb2xlYW4nICYmIGV2ZW50O1xufTtcbi8qKlxuICogVGhlIGpzb25ycGMgcmVzdWx0IGNhbGxiYWNrIGZvciBSZXF1ZXN0TWFuYWdlci5zZW5kXG4gKlxuICogQG1ldGhvZCBfanNvbnJwY1Jlc3VsdENhbGxiYWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRvIHVzZVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgdGhlIGpzb25ycGMgcGF5bG9hZFxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gcmV0dXJuIGNhbGxiYWNrIG9mIGZvcm0gKGVyciwgcmVzdWx0KVxuICpcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLl9qc29ucnBjUmVzdWx0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmlkICYmIHBheWxvYWQuaWQgIT09IHJlc3VsdC5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihgV3JvbmcgcmVzcG9uc2UgaWQgJHtyZXN1bHQuaWR9IChleHBlY3RlZDogJHtwYXlsb2FkLmlkfSkgaW4gJHtKU09OLnN0cmluZ2lmeShwYXlsb2FkKX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuRXJyb3JSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuICAgIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWFuYWdlcjogUmVxdWVzdE1hbmFnZXIsXG4gICAgQmF0Y2hNYW5hZ2VyOiBCYXRjaE1hbmFnZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/jsonrpc.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/jsonrpc.js ***!
  \**************************************************************************************************/
/***/ (function(module) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/** @file jsonrpc.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n *   Marek Kotewicz <marek@ethdev.com>\n *   Aaron Kumavis <aaron@kumavis.me>\n * @date 2015\n */\n\n// Initialize Jsonrpc as a simple object with utility functions.\nvar Jsonrpc = {\n    messageId: 0\n};\n/**\n * Should be called to valid json create payload object\n *\n * @method toPayload\n * @param {Function} method of jsonrpc call, required\n * @param {Array} params, an array of method params, optional\n * @returns {Object} valid jsonrpc payload object\n */\nJsonrpc.toPayload = function (method, params) {\n    if (!method) {\n        throw new Error('JSONRPC method should be specified for params: \"' + JSON.stringify(params) + '\"!');\n    }\n    // advance message ID\n    Jsonrpc.messageId++;\n    return {\n        jsonrpc: '2.0',\n        id: Jsonrpc.messageId,\n        method: method,\n        params: params || []\n    };\n};\n/**\n * Should be called to check if jsonrpc response is valid\n *\n * @method isValidResponse\n * @param {Object}\n * @returns {Boolean} true if response is valid, otherwise false\n */\nJsonrpc.isValidResponse = function (response) {\n    return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);\n    function validateSingleMessage(message) {\n        return !!message &&\n            !message.error &&\n            message.jsonrpc === '2.0' &&\n            (typeof message.id === 'number' || typeof message.id === 'string') &&\n            message.result !== undefined; // only undefined is not valid json object\n    }\n};\n/**\n * Should be called to create batch payload object\n *\n * @method toBatchPayload\n * @param {Array} messages, an array of objects with method (required) and params (optional) fields\n * @returns {Array} batch payload\n */\nJsonrpc.toBatchPayload = function (messages) {\n    return messages.map(function (message) {\n        return Jsonrpc.toPayload(message.method, message.params);\n    });\n};\nmodule.exports = Jsonrpc;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXJlcXVlc3RtYW5hZ2VyL2xpYi9qc29ucnBjLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1yZXF1ZXN0bWFuYWdlci9saWIvanNvbnJwYy5qcz80ZjFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUganNvbnJwYy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBBYXJvbiBLdW1hdmlzIDxhYXJvbkBrdW1hdmlzLm1lPlxuICogQGRhdGUgMjAxNVxuICovXG5cInVzZSBzdHJpY3RcIjtcbi8vIEluaXRpYWxpemUgSnNvbnJwYyBhcyBhIHNpbXBsZSBvYmplY3Qgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucy5cbnZhciBKc29ucnBjID0ge1xuICAgIG1lc3NhZ2VJZDogMFxufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byB2YWxpZCBqc29uIGNyZWF0ZSBwYXlsb2FkIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2Qgb2YganNvbnJwYyBjYWxsLCByZXF1aXJlZFxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zLCBhbiBhcnJheSBvZiBtZXRob2QgcGFyYW1zLCBvcHRpb25hbFxuICogQHJldHVybnMge09iamVjdH0gdmFsaWQganNvbnJwYyBwYXlsb2FkIG9iamVjdFxuICovXG5Kc29ucnBjLnRvUGF5bG9hZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTlJQQyBtZXRob2Qgc2hvdWxkIGJlIHNwZWNpZmllZCBmb3IgcGFyYW1zOiBcIicgKyBKU09OLnN0cmluZ2lmeShwYXJhbXMpICsgJ1wiIScpO1xuICAgIH1cbiAgICAvLyBhZHZhbmNlIG1lc3NhZ2UgSURcbiAgICBKc29ucnBjLm1lc3NhZ2VJZCsrO1xuICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogSnNvbnJwYy5tZXNzYWdlSWQsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXVxuICAgIH07XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIGpzb25ycGMgcmVzcG9uc2UgaXMgdmFsaWRcbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRSZXNwb25zZVxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiByZXNwb25zZSBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbkpzb25ycGMuaXNWYWxpZFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVzcG9uc2UpID8gcmVzcG9uc2UuZXZlcnkodmFsaWRhdGVTaW5nbGVNZXNzYWdlKSA6IHZhbGlkYXRlU2luZ2xlTWVzc2FnZShyZXNwb25zZSk7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTaW5nbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuICEhbWVzc2FnZSAmJlxuICAgICAgICAgICAgIW1lc3NhZ2UuZXJyb3IgJiZcbiAgICAgICAgICAgIG1lc3NhZ2UuanNvbnJwYyA9PT0gJzIuMCcgJiZcbiAgICAgICAgICAgICh0eXBlb2YgbWVzc2FnZS5pZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG1lc3NhZ2UuaWQgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZDsgLy8gb25seSB1bmRlZmluZWQgaXMgbm90IHZhbGlkIGpzb24gb2JqZWN0XG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgYmF0Y2ggcGF5bG9hZCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHRvQmF0Y2hQYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlcywgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIG1ldGhvZCAocmVxdWlyZWQpIGFuZCBwYXJhbXMgKG9wdGlvbmFsKSBmaWVsZHNcbiAqIEByZXR1cm5zIHtBcnJheX0gYmF0Y2ggcGF5bG9hZFxuICovXG5Kc29ucnBjLnRvQmF0Y2hQYXlsb2FkID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzLm1hcChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gSnNvbnJwYy50b1BheWxvYWQobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2UucGFyYW1zKTtcbiAgICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEpzb25ycGM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/jsonrpc.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js ***!
  \***********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar Subscription = __webpack_require__(/*! ./subscription.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/subscription.js\");\nvar Subscriptions = function Subscriptions(options) {\n    this.name = options.name;\n    this.type = options.type;\n    this.subscriptions = options.subscriptions || {};\n    this.requestManager = null;\n};\nSubscriptions.prototype.setRequestManager = function (rm) {\n    this.requestManager = rm;\n};\nSubscriptions.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    }\n    else {\n        obj[name[0]] = func;\n    }\n};\nSubscriptions.prototype.buildCall = function () {\n    var _this = this;\n    return function () {\n        if (!_this.subscriptions[arguments[0]]) {\n            console.warn('Subscription ' + JSON.stringify(arguments[0]) + ' doesn\\'t exist. Subscribing anyway.');\n        }\n        var subscription = new Subscription({\n            subscription: _this.subscriptions[arguments[0]] || {},\n            requestManager: _this.requestManager,\n            type: _this.type\n        });\n        return subscription.subscribe.apply(subscription, arguments);\n    };\n};\nmodule.exports = {\n    subscriptions: Subscriptions,\n    subscription: Subscription\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXN1YnNjcmlwdGlvbnMvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyx5SEFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1zdWJzY3JpcHRpb25zL2xpYi9pbmRleC5qcz83N2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGluZGV4LmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIFN1YnNjcmlwdGlvbiA9IHJlcXVpcmUoJy4vc3Vic2NyaXB0aW9uLmpzJyk7XG52YXIgU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIFN1YnNjcmlwdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gb3B0aW9ucy5zdWJzY3JpcHRpb25zIHx8IHt9O1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBudWxsO1xufTtcblN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNldFJlcXVlc3RNYW5hZ2VyID0gZnVuY3Rpb24gKHJtKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJtO1xufTtcblN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmF0dGFjaFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBmdW5jID0gdGhpcy5idWlsZENhbGwoKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZS5zcGxpdCgnLicpO1xuICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gb2JqW25hbWVbMF1dIHx8IHt9O1xuICAgICAgICBvYmpbbmFtZVswXV1bbmFtZVsxXV0gPSBmdW5jO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gZnVuYztcbiAgICB9XG59O1xuU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuYnVpbGRDYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5zdWJzY3JpcHRpb25zW2FyZ3VtZW50c1swXV0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU3Vic2NyaXB0aW9uICcgKyBKU09OLnN0cmluZ2lmeShhcmd1bWVudHNbMF0pICsgJyBkb2VzblxcJ3QgZXhpc3QuIFN1YnNjcmliaW5nIGFueXdheS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb246IF90aGlzLnN1YnNjcmlwdGlvbnNbYXJndW1lbnRzWzBdXSB8fCB7fSxcbiAgICAgICAgICAgIHJlcXVlc3RNYW5hZ2VyOiBfdGhpcy5yZXF1ZXN0TWFuYWdlcixcbiAgICAgICAgICAgIHR5cGU6IF90aGlzLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb24uc3Vic2NyaWJlLmFwcGx5KHN1YnNjcmlwdGlvbiwgYXJndW1lbnRzKTtcbiAgICB9O1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbnMsXG4gICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb25cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/subscription.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/subscription.js ***!
  \******************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/node_modules/eventemitter3/index.js\");\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").formatters);\nfunction identity(value) {\n    return value;\n}\nfunction Subscription(options) {\n    EventEmitter.call(this);\n    this.id = null;\n    this.callback = identity;\n    this.arguments = null;\n    this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager\n    };\n}\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nSubscription.prototype._extractCallback = function (args) {\n    if (typeof args[args.length - 1] === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nSubscription.prototype._validateArgs = function (args) {\n    var subscription = this.options.subscription;\n    if (!subscription)\n        subscription = {};\n    if (!subscription.params)\n        subscription.params = 0;\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nSubscription.prototype._formatInput = function (args) {\n    var subscription = this.options.subscription;\n    if (!subscription) {\n        return args;\n    }\n    if (!subscription.inputFormatter) {\n        return args;\n    }\n    var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n        return formatter ? formatter(args[index]) : args[index];\n    });\n    return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\nSubscription.prototype._formatOutput = function (result) {\n    var subscription = this.options.subscription;\n    return (subscription && subscription.outputFormatter && result) ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n    var params = [];\n    this.callback = this._extractCallback(args) || identity;\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift();\n        // replace subscription with given name\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName;\n        }\n    }\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args);\n        this._validateArgs(this.arguments);\n        args = []; // make empty after validation\n    }\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod);\n    params = params.concat(this.arguments);\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n    }\n    return {\n        method: this.options.type + '_subscribe',\n        params: params\n    };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function (callback) {\n    this.options.requestManager.removeSubscription(this.id, callback);\n    this.id = null;\n    this.lastBlock = null;\n    this.removeAllListeners();\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function () {\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments);\n    var payload = this._toPayload(args);\n    if (!payload) {\n        return this;\n    }\n    // throw error, if provider is not set\n    if (!this.options.requestManager.provider) {\n        setTimeout(function () {\n            var err1 = new Error('No provider set.');\n            _this.callback(err1, null, _this);\n            _this.emit('error', err1);\n        }, 0);\n        return this;\n    }\n    // throw error, if provider doesnt support subscriptions\n    if (!this.options.requestManager.provider.on) {\n        setTimeout(function () {\n            var err2 = new Error('The current provider doesn\\'t support subscriptions: ' +\n                _this.options.requestManager.provider.constructor.name);\n            _this.callback(err2, null, _this);\n            _this.emit('error', err2);\n        }, 0);\n        return this;\n    }\n    // Re-subscription only: continue fetching from the last block we received.\n    // a dropped connection may have resulted in gaps in the logs...\n    if (this.lastBlock && !!this.options.params && typeof this.options.params === 'object') {\n        payload.params[1] = this.options.params;\n        payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n    }\n    // if id is there unsubscribe first\n    if (this.id) {\n        this.unsubscribe();\n    }\n    // store the params in the options object\n    this.options.params = payload.params[1];\n    // get past logs, if fromBlock is available\n    if (payload.params[0] === 'logs' && !!payload.params[1] && typeof payload.params[1] === 'object' && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n        // send the subscription request\n        // copy the params to avoid race-condition with deletion below this block\n        var blockParams = Object.assign({}, payload.params[1]);\n        this.options.requestManager.send({\n            method: 'eth_getLogs',\n            params: [blockParams]\n        }, function (err, logs) {\n            if (!err) {\n                logs.forEach(function (log) {\n                    var output = _this._formatOutput(log);\n                    _this.callback(null, output, _this);\n                    _this.emit('data', output);\n                });\n                // TODO subscribe here? after the past logs?\n            }\n            else {\n                setTimeout(function () {\n                    _this.callback(err, null, _this);\n                    _this.emit('error', err);\n                }, 0);\n            }\n        });\n    }\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n    if (typeof payload.params[1] === 'object')\n        delete payload.params[1].fromBlock;\n    this.options.requestManager.send(payload, function (err, result) {\n        if (!err && result) {\n            _this.id = result;\n            _this.method = payload.params[0];\n            _this.emit('connected', result);\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this, function (error, result) {\n                if (!error) {\n                    if (!Array.isArray(result)) {\n                        result = [result];\n                    }\n                    result.forEach(function (resultItem) {\n                        var output = _this._formatOutput(resultItem);\n                        // Track current block (for gaps introduced by dropped connections)\n                        _this.lastBlock = !!output && typeof output === 'object' ? output.blockNumber : null;\n                        if (typeof _this.options.subscription.subscriptionHandler === 'function') {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output);\n                        }\n                        else {\n                            _this.emit('data', output);\n                        }\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        _this.callback(null, output, _this);\n                    });\n                }\n                else {\n                    _this.callback(error, false, _this);\n                    _this.emit('error', error);\n                }\n            });\n        }\n        else {\n            setTimeout(function () {\n                _this.callback(err, false, _this);\n                _this.emit('error', err);\n            }, 0);\n        }\n    });\n    // return an object to cancel the subscription\n    return this;\n};\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\nSubscription.prototype.resubscribe = function () {\n    this.options.requestManager.removeSubscription(this.id); // unsubscribe\n    this.id = null;\n    this.subscribe(this.callback);\n};\nmodule.exports = Subscription;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXN1YnNjcmlwdGlvbnMvbGliL3N1YnNjcmlwdGlvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsYUFBYSwwSUFBbUM7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMscUlBQWU7QUFDMUMsaUJBQWlCLDhJQUF1QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXN1YnNjcmlwdGlvbnMvbGliL3N1YnNjcmlwdGlvbi5qcz8xYjNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIHN1YnNjcmlwdGlvbi5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmVycm9ycztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZm9ybWF0dGVycztcbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gU3Vic2NyaXB0aW9uKG9wdGlvbnMpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrID0gaWRlbnRpdHk7XG4gICAgdGhpcy5hcmd1bWVudHMgPSBudWxsO1xuICAgIHRoaXMubGFzdEJsb2NrID0gbnVsbDsgLy8gXCJmcm9tXCIgYmxvY2sgdHJhY2tlciBmb3IgYmFja2ZpbGxpbmcgZXZlbnRzIG9uIHJlY29ubmVjdGlvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBvcHRpb25zLnN1YnNjcmlwdGlvbixcbiAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICByZXF1ZXN0TWFuYWdlcjogb3B0aW9ucy5yZXF1ZXN0TWFuYWdlclxuICAgIH07XG59XG4vLyBJTkhFUklUXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblN1YnNjcmlwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWJzY3JpcHRpb247XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGV4dHJhY3QgY2FsbGJhY2sgZnJvbSBhcnJheSBvZiBhcmd1bWVudHMuIE1vZGlmaWVzIGlucHV0IHBhcmFtXG4gKlxuICogQG1ldGhvZCBleHRyYWN0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7RnVuY3Rpb258TnVsbH0gY2FsbGJhY2ssIGlmIGV4aXN0c1xuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLl9leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBjb3JyZWN0XG4gKlxuICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIG5vdFxuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLl92YWxpZGF0ZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLm9wdGlvbnMuc3Vic2NyaXB0aW9uO1xuICAgIGlmICghc3Vic2NyaXB0aW9uKVxuICAgICAgICBzdWJzY3JpcHRpb24gPSB7fTtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbi5wYXJhbXMpXG4gICAgICAgIHN1YnNjcmlwdGlvbi5wYXJhbXMgPSAwO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gc3Vic2NyaXB0aW9uLnBhcmFtcykge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZE51bWJlck9mUGFyYW1zKGFyZ3MubGVuZ3RoLCBzdWJzY3JpcHRpb24ucGFyYW1zLCBzdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uTmFtZSk7XG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgaW5wdXQgYXJncyBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0XG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2Zvcm1hdElucHV0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5vcHRpb25zLnN1YnNjcmlwdGlvbjtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgaWYgKCFzdWJzY3JpcHRpb24uaW5wdXRGb3JtYXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZWRBcmdzID0gc3Vic2NyaXB0aW9uLmlucHV0Rm9ybWF0dGVyLm1hcChmdW5jdGlvbiAoZm9ybWF0dGVyLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyID8gZm9ybWF0dGVyKGFyZ3NbaW5kZXhdKSA6IGFyZ3NbaW5kZXhdO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3JtYXR0ZWRBcmdzO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgb3V0cHV0KHJlc3VsdCkgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRcbiAqIEBwYXJhbSByZXN1bHQge09iamVjdH1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLm9wdGlvbnMuc3Vic2NyaXB0aW9uO1xuICAgIHJldHVybiAoc3Vic2NyaXB0aW9uICYmIHN1YnNjcmlwdGlvbi5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzdWx0KSA/IHN1YnNjcmlwdGlvbi5vdXRwdXRGb3JtYXR0ZXIocmVzdWx0KSA6IHJlc3VsdDtcbn07XG4vKipcbiAqIFNob3VsZCBjcmVhdGUgcGF5bG9hZCBmcm9tIGdpdmVuIGlucHV0IGFyZ3NcbiAqXG4gKiBAbWV0aG9kIHRvUGF5bG9hZFxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLl90b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrID0gdGhpcy5fZXh0cmFjdENhbGxiYWNrKGFyZ3MpIHx8IGlkZW50aXR5O1xuICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb25NZXRob2QpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25NZXRob2QgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIC8vIHJlcGxhY2Ugc3Vic2NyaXB0aW9uIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb25OYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbk1ldGhvZCA9IHRoaXMub3B0aW9ucy5zdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYXJndW1lbnRzKSB7XG4gICAgICAgIHRoaXMuYXJndW1lbnRzID0gdGhpcy5fZm9ybWF0SW5wdXQoYXJncyk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQXJncyh0aGlzLmFyZ3VtZW50cyk7XG4gICAgICAgIGFyZ3MgPSBbXTsgLy8gbWFrZSBlbXB0eSBhZnRlciB2YWxpZGF0aW9uXG4gICAgfVxuICAgIC8vIHJlLWFkZCBzdWJzY3JpcHRpb25OYW1lXG4gICAgcGFyYW1zLnB1c2godGhpcy5zdWJzY3JpcHRpb25NZXRob2QpO1xuICAgIHBhcmFtcyA9IHBhcmFtcy5jb25jYXQodGhpcy5hcmd1bWVudHMpO1xuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgYSBjYWxsYmFjayBpcyBhbGxvd2VkIGFzIHBhcmFtZXRlciBvbiBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBzdWJzY3JpcHRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZDogdGhpcy5vcHRpb25zLnR5cGUgKyAnX3N1YnNjcmliZScsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfTtcbn07XG4vKipcbiAqIFVuc3Vic2NyaWJlcyBhbmQgY2xlYXJzIGNhbGxiYWNrc1xuICpcbiAqIEBtZXRob2QgdW5zdWJzY3JpYmVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMub3B0aW9ucy5yZXF1ZXN0TWFuYWdlci5yZW1vdmVTdWJzY3JpcHRpb24odGhpcy5pZCwgY2FsbGJhY2spO1xuICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIHRoaXMubGFzdEJsb2NrID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcbi8qKlxuICogU3Vic2NyaWJlcyBhbmQgd2F0Y2hlcyBmb3IgY2hhbmdlc1xuICpcbiAqIEBtZXRob2Qgc3Vic2NyaWJlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3Vic2NyaXB0aW9uIHRoZSBzdWJzY3JpcHRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9iamVjdCB3aXRoIGFkZHJlc3MgdG9waWNzIGFuZCBmcm9tQmxvY2tcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLl90b1BheWxvYWQoYXJncyk7XG4gICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyB0aHJvdyBlcnJvciwgaWYgcHJvdmlkZXIgaXMgbm90IHNldFxuICAgIGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RNYW5hZ2VyLnByb3ZpZGVyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVycjEgPSBuZXcgRXJyb3IoJ05vIHByb3ZpZGVyIHNldC4nKTtcbiAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrKGVycjEsIG51bGwsIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyMSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gdGhyb3cgZXJyb3IsIGlmIHByb3ZpZGVyIGRvZXNudCBzdXBwb3J0IHN1YnNjcmlwdGlvbnNcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXF1ZXN0TWFuYWdlci5wcm92aWRlci5vbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlcnIyID0gbmV3IEVycm9yKCdUaGUgY3VycmVudCBwcm92aWRlciBkb2VzblxcJ3Qgc3VwcG9ydCBzdWJzY3JpcHRpb25zOiAnICtcbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLnJlcXVlc3RNYW5hZ2VyLnByb3ZpZGVyLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuY2FsbGJhY2soZXJyMiwgbnVsbCwgX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnIyKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBSZS1zdWJzY3JpcHRpb24gb25seTogY29udGludWUgZmV0Y2hpbmcgZnJvbSB0aGUgbGFzdCBibG9jayB3ZSByZWNlaXZlZC5cbiAgICAvLyBhIGRyb3BwZWQgY29ubmVjdGlvbiBtYXkgaGF2ZSByZXN1bHRlZCBpbiBnYXBzIGluIHRoZSBsb2dzLi4uXG4gICAgaWYgKHRoaXMubGFzdEJsb2NrICYmICEhdGhpcy5vcHRpb25zLnBhcmFtcyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcGF5bG9hZC5wYXJhbXNbMV0gPSB0aGlzLm9wdGlvbnMucGFyYW1zO1xuICAgICAgICBwYXlsb2FkLnBhcmFtc1sxXS5mcm9tQmxvY2sgPSBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIodGhpcy5sYXN0QmxvY2sgKyAxKTtcbiAgICB9XG4gICAgLy8gaWYgaWQgaXMgdGhlcmUgdW5zdWJzY3JpYmUgZmlyc3RcbiAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8vIHN0b3JlIHRoZSBwYXJhbXMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgdGhpcy5vcHRpb25zLnBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzFdO1xuICAgIC8vIGdldCBwYXN0IGxvZ3MsIGlmIGZyb21CbG9jayBpcyBhdmFpbGFibGVcbiAgICBpZiAocGF5bG9hZC5wYXJhbXNbMF0gPT09ICdsb2dzJyAmJiAhIXBheWxvYWQucGFyYW1zWzFdICYmIHR5cGVvZiBwYXlsb2FkLnBhcmFtc1sxXSA9PT0gJ29iamVjdCcgJiYgcGF5bG9hZC5wYXJhbXNbMV0uaGFzT3duUHJvcGVydHkoJ2Zyb21CbG9jaycpICYmIGlzRmluaXRlKHBheWxvYWQucGFyYW1zWzFdLmZyb21CbG9jaykpIHtcbiAgICAgICAgLy8gc2VuZCB0aGUgc3Vic2NyaXB0aW9uIHJlcXVlc3RcbiAgICAgICAgLy8gY29weSB0aGUgcGFyYW1zIHRvIGF2b2lkIHJhY2UtY29uZGl0aW9uIHdpdGggZGVsZXRpb24gYmVsb3cgdGhpcyBibG9ja1xuICAgICAgICB2YXIgYmxvY2tQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkLnBhcmFtc1sxXSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZXF1ZXN0TWFuYWdlci5zZW5kKHtcbiAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRMb2dzJyxcbiAgICAgICAgICAgIHBhcmFtczogW2Jsb2NrUGFyYW1zXVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCBsb2dzKSB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaChmdW5jdGlvbiAobG9nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBfdGhpcy5fZm9ybWF0T3V0cHV0KGxvZyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrKG51bGwsIG91dHB1dCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdkYXRhJywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHN1YnNjcmliZSBoZXJlPyBhZnRlciB0aGUgcGFzdCBsb2dzP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrKGVyciwgbnVsbCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc3Vic2NyaXB0aW9uXG4gICAgLy8gVE9ETyBtb3ZlIHRvIHNlcGFyYXRlIGZ1bmN0aW9uPyBzbyB0aGF0IHBhc3QgbG9ncyBjYW4gZ28gZmlyc3Q/XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLnBhcmFtc1sxXSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGRlbGV0ZSBwYXlsb2FkLnBhcmFtc1sxXS5mcm9tQmxvY2s7XG4gICAgdGhpcy5vcHRpb25zLnJlcXVlc3RNYW5hZ2VyLnNlbmQocGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmICghZXJyICYmIHJlc3VsdCkge1xuICAgICAgICAgICAgX3RoaXMuaWQgPSByZXN1bHQ7XG4gICAgICAgICAgICBfdGhpcy5tZXRob2QgPSBwYXlsb2FkLnBhcmFtc1swXTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIHJlc3VsdCk7XG4gICAgICAgICAgICAvLyBjYWxsIGNhbGxiYWNrIG9uIG5vdGlmaWNhdGlvbnNcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMucmVxdWVzdE1hbmFnZXIuYWRkU3Vic2NyaXB0aW9uKF90aGlzLCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gX3RoaXMuX2Zvcm1hdE91dHB1dChyZXN1bHRJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIGN1cnJlbnQgYmxvY2sgKGZvciBnYXBzIGludHJvZHVjZWQgYnkgZHJvcHBlZCBjb25uZWN0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RCbG9jayA9ICEhb3V0cHV0ICYmIHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnID8gb3V0cHV0LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5zdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLnN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb25IYW5kbGVyLmNhbGwoX3RoaXMsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdkYXRhJywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrLCBsYXN0IHNvIHRoYXQgdW5zdWJzY3JpYmUgdGhlcmUgd29uJ3QgYWZmZWN0IHRoZSBlbWl0IGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWxsYmFjayhudWxsLCBvdXRwdXQsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWxsYmFjayhlcnJvciwgZmFsc2UsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWxsYmFjayhlcnIsIGZhbHNlLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyByZXR1cm4gYW4gb2JqZWN0IHRvIGNhbmNlbCB0aGUgc3Vic2NyaXB0aW9uXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBSZXN1YnNjcmliZVxuICpcbiAqIEBtZXRob2QgcmVzdWJzY3JpYmVcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZXN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9wdGlvbnMucmVxdWVzdE1hbmFnZXIucmVtb3ZlU3Vic2NyaXB0aW9uKHRoaXMuaWQpOyAvLyB1bnN1YnNjcmliZVxuICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMuY2FsbGJhY2spO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU3Vic2NyaXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/subscription.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/node_modules/eventemitter3/index.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/node_modules/eventemitter3/index.js ***!
  \**********************************************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLXN1YnNjcmlwdGlvbnMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1zdWJzY3JpcHRpb25zL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzPzliZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/extend.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/extend.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file extend.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar Method = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar extend = function (pckg) {\n    /* jshint maxcomplexity:5 */\n    var ex = function (extension) {\n        var extendedObject;\n        if (extension.property) {\n            if (!pckg[extension.property]) {\n                pckg[extension.property] = {};\n            }\n            extendedObject = pckg[extension.property];\n        }\n        else {\n            extendedObject = pckg;\n        }\n        if (extension.methods) {\n            extension.methods.forEach(function (method) {\n                if (!(method instanceof Method)) {\n                    method = new Method(method);\n                }\n                method.attachToObject(extendedObject);\n                method.setRequestManager(pckg._requestManager);\n            });\n        }\n        return pckg;\n    };\n    ex.formatters = formatters;\n    ex.utils = utils;\n    ex.Method = Method;\n    return ex;\n};\nmodule.exports = extend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlL2xpYi9leHRlbmQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLGlCQUFpQiw4SUFBdUM7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLDBHQUFrQjtBQUN2QyxZQUFZLG1CQUFPLENBQUMsOEZBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS9saWIvZXh0ZW5kLmpzP2M0MDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIGV4dGVuZC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5mb3JtYXR0ZXJzO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJ3dlYjMtY29yZS1tZXRob2QnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAocGNrZykge1xuICAgIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OjUgKi9cbiAgICB2YXIgZXggPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgIHZhciBleHRlbmRlZE9iamVjdDtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKCFwY2tnW2V4dGVuc2lvbi5wcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICBwY2tnW2V4dGVuc2lvbi5wcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZGVkT2JqZWN0ID0gcGNrZ1tleHRlbnNpb24ucHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXh0ZW5kZWRPYmplY3QgPSBwY2tnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbnNpb24ubWV0aG9kcykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWV0aG9kIGluc3RhbmNlb2YgTWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBuZXcgTWV0aG9kKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChleHRlbmRlZE9iamVjdCk7XG4gICAgICAgICAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHBja2cuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwY2tnO1xuICAgIH07XG4gICAgZXguZm9ybWF0dGVycyA9IGZvcm1hdHRlcnM7XG4gICAgZXgudXRpbHMgPSB1dGlscztcbiAgICBleC5NZXRob2QgPSBNZXRob2Q7XG4gICAgcmV0dXJuIGV4O1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/extend.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst requestManager = __webpack_require__(/*! web3-core-requestmanager */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-requestmanager/lib/index.js\");\nconst extend = __webpack_require__(/*! ./extend */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/extend.js\");\nconst packageInit = (pkg, args) => {\n    args = Array.prototype.slice.call(args);\n    if (!pkg) {\n        throw new Error('You need to instantiate using the \"new\" keyword.');\n    }\n    // make property of pkg._provider, which can properly set providers\n    Object.defineProperty(pkg, 'currentProvider', {\n        get: () => {\n            return pkg._provider;\n        },\n        set: (value) => {\n            return pkg.setProvider(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // inherit from parent package or create a new RequestManager\n    if (args[0] && args[0]._requestManager) {\n        pkg._requestManager = args[0]._requestManager;\n    }\n    else {\n        pkg._requestManager = new requestManager.Manager(args[0], args[1]);\n    }\n    // add givenProvider\n    pkg.givenProvider = requestManager.Manager.givenProvider;\n    pkg.providers = requestManager.Manager.providers;\n    pkg._provider = pkg._requestManager.provider;\n    // add SETPROVIDER function (don't overwrite if already existing)\n    if (!pkg.setProvider) {\n        pkg.setProvider = (provider, net) => {\n            pkg._requestManager.setProvider(provider, net);\n            pkg._provider = pkg._requestManager.provider;\n            return true;\n        };\n    }\n    pkg.setRequestManager = (manager) => {\n        pkg._requestManager = manager;\n        pkg._provider = manager.provider;\n    };\n    // attach batch request creation\n    pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);\n    // attach extend function\n    pkg.extend = extend(pkg);\n};\nconst addProviders = (pkg) => {\n    pkg.givenProvider = requestManager.Manager.givenProvider;\n    pkg.providers = requestManager.Manager.providers;\n};\nmodule.exports = {\n    packageInit,\n    addProviders\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1jb3JlL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDBIQUEwQjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsNEZBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS9saWIvaW5kZXguanM/ZmU4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5jb25zdCByZXF1ZXN0TWFuYWdlciA9IHJlcXVpcmUoXCJ3ZWIzLWNvcmUtcmVxdWVzdG1hbmFnZXJcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiLi9leHRlbmRcIik7XG5jb25zdCBwYWNrYWdlSW5pdCA9IChwa2csIGFyZ3MpID0+IHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgaWYgKCFwa2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBpbnN0YW50aWF0ZSB1c2luZyB0aGUgXCJuZXdcIiBrZXl3b3JkLicpO1xuICAgIH1cbiAgICAvLyBtYWtlIHByb3BlcnR5IG9mIHBrZy5fcHJvdmlkZXIsIHdoaWNoIGNhbiBwcm9wZXJseSBzZXQgcHJvdmlkZXJzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBrZywgJ2N1cnJlbnRQcm92aWRlcicsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGtnLl9wcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwa2cuc2V0UHJvdmlkZXIodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBpbmhlcml0IGZyb20gcGFyZW50IHBhY2thZ2Ugb3IgY3JlYXRlIGEgbmV3IFJlcXVlc3RNYW5hZ2VyXG4gICAgaWYgKGFyZ3NbMF0gJiYgYXJnc1swXS5fcmVxdWVzdE1hbmFnZXIpIHtcbiAgICAgICAgcGtnLl9yZXF1ZXN0TWFuYWdlciA9IGFyZ3NbMF0uX3JlcXVlc3RNYW5hZ2VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGtnLl9yZXF1ZXN0TWFuYWdlciA9IG5ldyByZXF1ZXN0TWFuYWdlci5NYW5hZ2VyKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIH1cbiAgICAvLyBhZGQgZ2l2ZW5Qcm92aWRlclxuICAgIHBrZy5naXZlblByb3ZpZGVyID0gcmVxdWVzdE1hbmFnZXIuTWFuYWdlci5naXZlblByb3ZpZGVyO1xuICAgIHBrZy5wcm92aWRlcnMgPSByZXF1ZXN0TWFuYWdlci5NYW5hZ2VyLnByb3ZpZGVycztcbiAgICBwa2cuX3Byb3ZpZGVyID0gcGtnLl9yZXF1ZXN0TWFuYWdlci5wcm92aWRlcjtcbiAgICAvLyBhZGQgU0VUUFJPVklERVIgZnVuY3Rpb24gKGRvbid0IG92ZXJ3cml0ZSBpZiBhbHJlYWR5IGV4aXN0aW5nKVxuICAgIGlmICghcGtnLnNldFByb3ZpZGVyKSB7XG4gICAgICAgIHBrZy5zZXRQcm92aWRlciA9IChwcm92aWRlciwgbmV0KSA9PiB7XG4gICAgICAgICAgICBwa2cuX3JlcXVlc3RNYW5hZ2VyLnNldFByb3ZpZGVyKHByb3ZpZGVyLCBuZXQpO1xuICAgICAgICAgICAgcGtnLl9wcm92aWRlciA9IHBrZy5fcmVxdWVzdE1hbmFnZXIucHJvdmlkZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGtnLnNldFJlcXVlc3RNYW5hZ2VyID0gKG1hbmFnZXIpID0+IHtcbiAgICAgICAgcGtnLl9yZXF1ZXN0TWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgIHBrZy5fcHJvdmlkZXIgPSBtYW5hZ2VyLnByb3ZpZGVyO1xuICAgIH07XG4gICAgLy8gYXR0YWNoIGJhdGNoIHJlcXVlc3QgY3JlYXRpb25cbiAgICBwa2cuQmF0Y2hSZXF1ZXN0ID0gcmVxdWVzdE1hbmFnZXIuQmF0Y2hNYW5hZ2VyLmJpbmQobnVsbCwgcGtnLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgLy8gYXR0YWNoIGV4dGVuZCBmdW5jdGlvblxuICAgIHBrZy5leHRlbmQgPSBleHRlbmQocGtnKTtcbn07XG5jb25zdCBhZGRQcm92aWRlcnMgPSAocGtnKSA9PiB7XG4gICAgcGtnLmdpdmVuUHJvdmlkZXIgPSByZXF1ZXN0TWFuYWdlci5NYW5hZ2VyLmdpdmVuUHJvdmlkZXI7XG4gICAgcGtnLnByb3ZpZGVycyA9IHJlcXVlc3RNYW5hZ2VyLk1hbmFnZXIucHJvdmlkZXJzO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhY2thZ2VJbml0LFxuICAgIGFkZFByb3ZpZGVyc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-abi/lib/index.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-abi/lib/index.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = (__webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\").Buffer);\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar EthersAbiCoder = (__webpack_require__(/*! @ethersproject/abi */ \"../../node_modules/@ethersproject/abi/lib.esm/index.js\").AbiCoder);\nvar ParamType = (__webpack_require__(/*! @ethersproject/abi */ \"../../node_modules/@ethersproject/abi/lib.esm/index.js\").ParamType);\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {\n}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n        let type = types[index];\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i]);\n                    }\n                    else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: \"bytes24\" });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n    return { type: type, name: structName };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            // pad to correct bit width\n            param = utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.');\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = Array.isArray(topics) ? topics : [topics];\n    data = data || '';\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        }\n        else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRkFBd0I7QUFDckMsWUFBWSxtQkFBTyxDQUFDLDhGQUFZO0FBQ2hDLHFCQUFxQixrSEFBc0M7QUFDM0QsZ0JBQWdCLG1IQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsS0FBSztBQUNoQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFlBQVk7QUFDdkI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcz8yNmM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZnJvemVtYW4uZGU+XG4gKiBAZGF0ZSAyMDE4XG4gKi9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgRXRoZXJzQWJpQ29kZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYmknKS5BYmlDb2RlcjtcbnZhciBQYXJhbVR5cGUgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYmknKS5QYXJhbVR5cGU7XG52YXIgZXRoZXJzQWJpQ29kZXIgPSBuZXcgRXRoZXJzQWJpQ29kZXIoZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAoISghIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdCTicpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59KTtcbi8vIHJlc3VsdCBtZXRob2RcbmZ1bmN0aW9uIFJlc3VsdCgpIHtcbn1cbi8qKlxuICogQUJJQ29kZXIgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGFueSB0eXBlXG4gKi9cbnZhciBBQklDb2RlciA9IGZ1bmN0aW9uICgpIHtcbn07XG4vKipcbiAqIEVuY29kZXMgdGhlIGZ1bmN0aW9uIG5hbWUgdG8gaXRzIEFCSSByZXByZXNlbnRhdGlvbiwgd2hpY2ggYXJlIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBzaGEzIG9mIHRoZSBmdW5jdGlvbiBuYW1lIGluY2x1ZGluZyAgdHlwZXMuXG4gKlxuICogQG1ldGhvZCBlbmNvZGVGdW5jdGlvblNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmdW5jdGlvbk5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBmdW5jdGlvbiBuYW1lXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvblNpZ25hdHVyZSA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnb2JqZWN0JyAmJiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2hhMyhmdW5jdGlvbk5hbWUpLnNsaWNlKDAsIDEwKTtcbn07XG4vKipcbiAqIEVuY29kZXMgdGhlIGZ1bmN0aW9uIG5hbWUgdG8gaXRzIEFCSSByZXByZXNlbnRhdGlvbiwgd2hpY2ggYXJlIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBzaGEzIG9mIHRoZSBmdW5jdGlvbiBuYW1lIGluY2x1ZGluZyAgdHlwZXMuXG4gKlxuICogQG1ldGhvZCBlbmNvZGVFdmVudFNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmdW5jdGlvbk5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBmdW5jdGlvbiBuYW1lXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVFdmVudFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnb2JqZWN0JyAmJiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2hhMyhmdW5jdGlvbk5hbWUpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHR5cGVcbiAqIEBwYXJhbSB7YW55fSBwYXJhbVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBwbGFpbiBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1ldGVycyhbdHlwZV0sIFtwYXJhbV0pO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmd8T2JqZWN0Pn0gdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gcGFyYW1zXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGxpc3Qgb2YgcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHlwZXMgPSBzZWxmLm1hcFR5cGVzKHR5cGVzKTtcbiAgICBwYXJhbXMgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpbmRleF07XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlKSB7XG4gICAgICAgICAgICAvLyBXZSBtYXkgZ2V0IGEgbmFtZWQgdHlwZSBvZiBzaGFwZSB7bmFtZSwgdHlwZX1cbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW0gPSBzZWxmLmZvcm1hdFBhcmFtKHR5cGUsIHBhcmFtKTtcbiAgICAgICAgLy8gRm9ybWF0IHBhcmFtcyBmb3IgdHVwbGVzXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZS5pbmNsdWRlcygndHVwbGUnKSkge1xuICAgICAgICAgICAgY29uc3QgY29kZXIgPSBldGhlcnNBYmlDb2Rlci5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZ5UGFyYW1zID0gKGNvZGVyLCBwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rlci5uYW1lID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS5tYXAocCA9PiBtb2RpZnlQYXJhbXMoZXRoZXJzQWJpQ29kZXIuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKGNvZGVyLnR5cGUucmVwbGFjZSgnW10nLCAnJykpKSwgcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2Rlci5jb2RlcnMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5uYW1lID09PSAndHVwbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnlQYXJhbXMoYywgcGFyYW1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1baV0gPSBzZWxmLmZvcm1hdFBhcmFtKGMubmFtZSwgcGFyYW1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW9kaWZ5UGFyYW1zKGNvZGVyLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIHJldHVybiBldGhlcnNBYmlDb2Rlci5lbmNvZGUodHlwZXMsIHBhcmFtcyk7XG59O1xuLyoqXG4gKiBNYXAgdHlwZXMgaWYgc2ltcGxpZmllZCBmb3JtYXQgaXMgdXNlZFxuICpcbiAqIEBtZXRob2QgbWFwVHlwZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGVzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFR5cGVzID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBtYXBwZWRUeXBlcyA9IFtdO1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gUmVtYXAgYGZ1bmN0aW9uYCB0eXBlIHBhcmFtcyB0byBieXRlczI0IHNpbmNlIEV0aGVycyBkb2VzIG5vdFxuICAgICAgICAvLyByZWNvZ25pemUgZm9ybWVyIHR5cGUuIFNvbGlkaXR5IGRvY3Mgc2F5IGBGdW5jdGlvbmAgaXMgYSBieXRlczI0XG4gICAgICAgIC8vIGVuY29kaW5nIHRoZSBjb250cmFjdCBhZGRyZXNzIGZvbGxvd2VkIGJ5IHRoZSBmdW5jdGlvbiBzZWxlY3RvciBoYXNoLlxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZSA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUsIHsgdHlwZTogXCJieXRlczI0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaXNTaW1wbGlmaWVkU3RydWN0Rm9ybWF0KHR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RydWN0TmFtZSA9IE9iamVjdC5rZXlzKHR5cGUpWzBdO1xuICAgICAgICAgICAgbWFwcGVkVHlwZXMucHVzaChPYmplY3QuYXNzaWduKHNlbGYubWFwU3RydWN0TmFtZUFuZFR5cGUoc3RydWN0TmFtZSksIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBzZWxmLm1hcFN0cnVjdFRvQ29kZXJGb3JtYXQodHlwZVtzdHJ1Y3ROYW1lXSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXBwZWRUeXBlcy5wdXNoKHR5cGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXBwZWRUeXBlcztcbn07XG4vKipcbiAqIENoZWNrIGlmIHR5cGUgaXMgc2ltcGxpZmllZCBzdHJ1Y3QgZm9ybWF0XG4gKlxuICogQG1ldGhvZCBpc1NpbXBsaWZpZWRTdHJ1Y3RGb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgT2JqZWN0fSB0eXBlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmlzU2ltcGxpZmllZFN0cnVjdEZvcm1hdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHlwZS5jb21wb25lbnRzID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJztcbn07XG4vKipcbiAqIE1hcHMgdGhlIGNvcnJlY3QgdHVwbGUgdHlwZSBhbmQgbmFtZSB3aGVuIHRoZSBzaW1wbGlmaWVkIGZvcm1hdCBpbiBlbmNvZGUvZGVjb2RlUGFyYW1ldGVyIGlzIHVzZWRcbiAqXG4gKiBAbWV0aG9kIG1hcFN0cnVjdE5hbWVBbmRUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RydWN0TmFtZVxuICogQHJldHVybiB7e3R5cGU6IHN0cmluZywgbmFtZTogKn19XG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5tYXBTdHJ1Y3ROYW1lQW5kVHlwZSA9IGZ1bmN0aW9uIChzdHJ1Y3ROYW1lKSB7XG4gICAgdmFyIHR5cGUgPSAndHVwbGUnO1xuICAgIGlmIChzdHJ1Y3ROYW1lLmluZGV4T2YoJ1tdJykgPiAtMSkge1xuICAgICAgICB0eXBlID0gJ3R1cGxlW10nO1xuICAgICAgICBzdHJ1Y3ROYW1lID0gc3RydWN0TmFtZS5zbGljZSgwLCAtMik7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIG5hbWU6IHN0cnVjdE5hbWUgfTtcbn07XG4vKipcbiAqIE1hcHMgdGhlIHNpbXBsaWZpZWQgZm9ybWF0IGluIHRvIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIEFCSUNvZGVyXG4gKlxuICogQG1ldGhvZCBtYXBTdHJ1Y3RUb0NvZGVyRm9ybWF0XG4gKiBAcGFyYW0ge09iamVjdH0gc3RydWN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFN0cnVjdFRvQ29kZXJGb3JtYXQgPSBmdW5jdGlvbiAoc3RydWN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgT2JqZWN0LmtleXMoc3RydWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChPYmplY3QuYXNzaWduKHNlbGYubWFwU3RydWN0TmFtZUFuZFR5cGUoa2V5KSwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHNlbGYubWFwU3RydWN0VG9Db2RlckZvcm1hdChzdHJ1Y3Rba2V5XSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgdHlwZTogc3RydWN0W2tleV1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59O1xuLyoqXG4gKiBIYW5kbGUgc29tZSBmb3JtYXR0aW5nIG9mIHBhcmFtcyBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkgd2l0aCBFdGhlcnMgVjRcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdFBhcmFtXG4gKiBAcGFyYW0ge1N0cmluZ30gLSB0eXBlXG4gKiBAcGFyYW0ge2FueX0gLSBwYXJhbVxuICogQHJldHVybiB7YW55fSAtIFRoZSBmb3JtYXR0ZWQgcGFyYW1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmZvcm1hdFBhcmFtID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVCeXRlc0FycmF5ID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKilcXFtcXF0kLyk7XG4gICAgY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVOdW1iZXJBcnJheSA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKilcXFtcXF0kLyk7XG4gICAgLy8gRm9ybWF0IEJOIHRvIHN0cmluZ1xuICAgIGlmICh1dGlscy5pc0JOKHBhcmFtKSB8fCB1dGlscy5pc0JpZ051bWJlcihwYXJhbSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgaWYgKHR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXNBcnJheSkgfHwgdHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXJBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLm1hcChwID0+IHRoaXMuZm9ybWF0UGFyYW0odHlwZS5yZXBsYWNlKCdbXScsICcnKSwgcCkpO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgY29ycmVjdCB3aWR0aCBmb3IgdT9pbnRbMC05XSpcbiAgICBsZXQgbWF0Y2ggPSB0eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgIGlmIChzaXplIC8gOCA8IHBhcmFtLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcGFkIHRvIGNvcnJlY3QgYml0IHdpZHRoXG4gICAgICAgICAgICBwYXJhbSA9IHV0aWxzLmxlZnRQYWQocGFyYW0sIHNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZvcm1hdCBjb3JyZWN0IGxlbmd0aCBmb3IgYnl0ZXNbMC05XStcbiAgICBtYXRjaCA9IHR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhcmFtKSkge1xuICAgICAgICAgICAgcGFyYW0gPSB1dGlscy50b0hleChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9ybWF0IHRvIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1heFNpemUgPSBzaXplICogMjtcbiAgICAgICAgICAgIGlmIChwYXJhbS5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgICAgICAgICBtYXhTaXplICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoIDwgbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIHBhZCB0byBjb3JyZWN0IGxlbmd0aFxuICAgICAgICAgICAgICAgIHBhcmFtID0gdXRpbHMucmlnaHRQYWQocGFyYW0sIHNpemUgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb3JtYXQgb2RkLWxlbmd0aCBieXRlcyB0byBldmVuLWxlbmd0aFxuICAgICAgICBpZiAocGFyYW0ubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAnMHgwJyArIHBhcmFtLnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG59O1xuLyoqXG4gKiBFbmNvZGVzIGEgZnVuY3Rpb24gY2FsbCBmcm9tIGl0cyBqc29uIGludGVyZmFjZSBhbmQgcGFyYW1ldGVycy5cbiAqXG4gKiBAbWV0aG9kIGVuY29kZUZ1bmN0aW9uQ2FsbFxuICogQHBhcmFtIHtBcnJheX0ganNvbkludGVyZmFjZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBlbmNvZGVkIEFCSSBmb3IgdGhpcyBmdW5jdGlvbiBjYWxsXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoanNvbkludGVyZmFjZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlRnVuY3Rpb25TaWduYXR1cmUoanNvbkludGVyZmFjZSkgKyB0aGlzLmVuY29kZVBhcmFtZXRlcnMoanNvbkludGVyZmFjZS5pbnB1dHMsIHBhcmFtcykucmVwbGFjZSgnMHgnLCAnJyk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgYnl0ZXMgdG8gcGxhaW4gcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtZXRlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHR5cGUsIGJ5dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1ldGVycyhbdHlwZV0sIGJ5dGVzKVswXTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBsaXN0IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZGVjb2RlUGFyYW1ldGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvdXRwdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gYnl0ZXNcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwbGFpbiBwYXJhbXNcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAob3V0cHV0cywgYnl0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVQYXJhbWV0ZXJzV2l0aChvdXRwdXRzLCBieXRlcywgZmFsc2UpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbWV0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHBhcmFtIHtCb29sZWFufSBsb29zZVxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVyc1dpdGggPSBmdW5jdGlvbiAob3V0cHV0cywgYnl0ZXMsIGxvb3NlKSB7XG4gICAgaWYgKG91dHB1dHMubGVuZ3RoID4gMCAmJiAoIWJ5dGVzIHx8IGJ5dGVzID09PSAnMHgnIHx8IGJ5dGVzID09PSAnMFgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JldHVybmVkIHZhbHVlcyBhcmVuXFwndCB2YWxpZCwgZGlkIGl0IHJ1biBPdXQgb2YgR2FzPyAnICtcbiAgICAgICAgICAgICdZb3UgbWlnaHQgYWxzbyBzZWUgdGhpcyBlcnJvciBpZiB5b3UgYXJlIG5vdCB1c2luZyB0aGUgJyArXG4gICAgICAgICAgICAnY29ycmVjdCBBQkkgZm9yIHRoZSBjb250cmFjdCB5b3UgYXJlIHJldHJpZXZpbmcgZGF0YSBmcm9tLCAnICtcbiAgICAgICAgICAgICdyZXF1ZXN0aW5nIGRhdGEgZnJvbSBhIGJsb2NrIG51bWJlciB0aGF0IGRvZXMgbm90IGV4aXN0LCAnICtcbiAgICAgICAgICAgICdvciBxdWVyeWluZyBhIG5vZGUgd2hpY2ggaXMgbm90IGZ1bGx5IHN5bmNlZC4nKTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGV0aGVyc0FiaUNvZGVyLmRlY29kZSh0aGlzLm1hcFR5cGVzKG91dHB1dHMpLCAnMHgnICsgYnl0ZXMucmVwbGFjZSgvMHgvaSwgJycpLCBsb29zZSk7XG4gICAgdmFyIHJldHVyblZhbHVlID0gbmV3IFJlc3VsdCgpO1xuICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18gPSAwO1xuICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0LCBpKSB7XG4gICAgICAgIHZhciBkZWNvZGVkVmFsdWUgPSByZXNbcmV0dXJuVmFsdWUuX19sZW5ndGhfX107XG4gICAgICAgIGRlY29kZWRWYWx1ZSA9IChkZWNvZGVkVmFsdWUgPT09ICcweCcpID8gbnVsbCA6IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSBkZWNvZGVkVmFsdWU7XG4gICAgICAgIGlmICgodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyB8fCAhIW91dHB1dCAmJiB0eXBlb2Ygb3V0cHV0ID09PSAnb2JqZWN0JykgJiYgb3V0cHV0Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW291dHB1dC5uYW1lXSA9IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbi8qKlxuICogRGVjb2RlcyBldmVudHMgbm9uLSBhbmQgaW5kZXhlZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2QgZGVjb2RlTG9nXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gdG9waWNzXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVMb2cgPSBmdW5jdGlvbiAoaW5wdXRzLCBkYXRhLCB0b3BpY3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRvcGljcyA9IEFycmF5LmlzQXJyYXkodG9waWNzKSA/IHRvcGljcyA6IFt0b3BpY3NdO1xuICAgIGRhdGEgPSBkYXRhIHx8ICcnO1xuICAgIHZhciBub3RJbmRleGVkSW5wdXRzID0gW107XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBbXTtcbiAgICB2YXIgdG9waWNDb3VudCA9IDA7XG4gICAgLy8gVE9ETyBjaGVjayBmb3IgYW5vbnltb3VzIGxvZ3M/XG4gICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIGlmIChpbnB1dC5pbmRleGVkKSB7XG4gICAgICAgICAgICBpbmRleGVkUGFyYW1zW2ldID0gKFsnYm9vbCcsICdpbnQnLCAndWludCcsICdhZGRyZXNzJywgJ2ZpeGVkJywgJ3VmaXhlZCddLmZpbmQoZnVuY3Rpb24gKHN0YXRpY1R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQudHlwZS5pbmRleE9mKHN0YXRpY1R5cGUpICE9PSAtMTtcbiAgICAgICAgICAgIH0pKSA/IF90aGlzLmRlY29kZVBhcmFtZXRlcihpbnB1dC50eXBlLCB0b3BpY3NbdG9waWNDb3VudF0pIDogdG9waWNzW3RvcGljQ291bnRdO1xuICAgICAgICAgICAgdG9waWNDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm90SW5kZXhlZElucHV0c1tpXSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG5vbkluZGV4ZWREYXRhID0gZGF0YTtcbiAgICB2YXIgbm90SW5kZXhlZFBhcmFtcyA9IChub25JbmRleGVkRGF0YSkgPyB0aGlzLmRlY29kZVBhcmFtZXRlcnNXaXRoKG5vdEluZGV4ZWRJbnB1dHMsIG5vbkluZGV4ZWREYXRhLCB0cnVlKSA6IFtdO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IG5ldyBSZXN1bHQoKTtcbiAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fID0gMDtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocmVzLCBpKSB7XG4gICAgICAgIHJldHVyblZhbHVlW2ldID0gKHJlcy50eXBlID09PSAnc3RyaW5nJykgPyAnJyA6IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygbm90SW5kZXhlZFBhcmFtc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW2ldID0gbm90SW5kZXhlZFBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWRQYXJhbXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtpXSA9IGluZGV4ZWRQYXJhbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtyZXMubmFtZV0gPSByZXR1cm5WYWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbnZhciBjb2RlciA9IG5ldyBBQklDb2RlcigpO1xubW9kdWxlLmV4cG9ydHMgPSBjb2RlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-abi/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/lib/index.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")[\"Buffer\"];\n/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file accounts.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar core = __webpack_require__(/*! web3-core */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\");\nvar Method = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\nvar Account = __webpack_require__(/*! eth-lib/lib/account */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/account.js\");\nvar cryp = (typeof __webpack_require__.g === 'undefined') ? __webpack_require__(/*! crypto-browserify */ \"../../node_modules/crypto-browserify/index.js\") : __webpack_require__(/*! crypto */ \"./node_modules/next/dist/compiled/crypto-browserify/index.js\");\nvar scrypt = __webpack_require__(/*! scrypt-js */ \"../../node_modules/scrypt-js/scrypt.js\");\nvar uuid = __webpack_require__(/*! uuid */ \"../../node_modules/@alch/alchemy-web3/node_modules/uuid/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar helpers = __webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\");\nvar { TransactionFactory } = __webpack_require__(/*! @ethereumjs/tx */ \"../../node_modules/@ethereumjs/tx/dist.browser/index.js\");\nvar Common = (__webpack_require__(/*! @ethereumjs/common */ \"../../node_modules/@ethereumjs/common/dist.browser/index.js\")[\"default\"]);\nvar HardForks = (__webpack_require__(/*! @ethereumjs/common */ \"../../node_modules/@ethereumjs/common/dist.browser/index.js\").Hardfork);\nvar ethereumjsUtil = __webpack_require__(/*! ethereumjs-util */ \"../../node_modules/ethereumjs-util/dist.browser/index.js\");\nvar isNot = function (value) {\n    return (typeof value === 'undefined') || value === null;\n};\nvar Accounts = function Accounts() {\n    var _this = this;\n    // sets _requestmanager\n    core.packageInit(this, arguments);\n    // remove unecessary core functions\n    delete this.BatchRequest;\n    delete this.extend;\n    var _ethereumCall = [\n        new Method({\n            name: 'getNetworkId',\n            call: 'net_version',\n            params: 0,\n            outputFormatter: parseInt\n        }),\n        new Method({\n            name: 'getChainId',\n            call: 'eth_chainId',\n            params: 0,\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'getGasPrice',\n            call: 'eth_gasPrice',\n            params: 0\n        }),\n        new Method({\n            name: 'getTransactionCount',\n            call: 'eth_getTransactionCount',\n            params: 2,\n            inputFormatter: [function (address) {\n                    if (utils.isAddress(address)) {\n                        return address;\n                    }\n                    else {\n                        throw new Error('Address ' + address + ' is not a valid address to get the \"transactionCount\".');\n                    }\n                }, function () {\n                    return 'latest';\n                }]\n        }),\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [function (blockNumber) {\n                    return blockNumber ? utils.toHex(blockNumber) : 'latest';\n                }, function () {\n                    return false;\n                }]\n        }),\n    ];\n    // attach methods to this._ethereumCall\n    this._ethereumCall = {};\n    _ethereumCall.forEach((method) => {\n        method.attachToObject(_this._ethereumCall);\n        method.setRequestManager(_this._requestManager);\n    });\n    this.wallet = new Wallet(this);\n};\nAccounts.prototype._addAccountFunctions = function (account) {\n    var _this = this;\n    // add sign functions\n    account.signTransaction = function signTransaction(tx, callback) {\n        return _this.signTransaction(tx, account.privateKey, callback);\n    };\n    account.sign = function sign(data) {\n        return _this.sign(data, account.privateKey);\n    };\n    account.encrypt = function encrypt(password, options) {\n        return _this.encrypt(account.privateKey, password, options);\n    };\n    return account;\n};\nAccounts.prototype.create = function create(entropy) {\n    return this._addAccountFunctions(Account.create(entropy || utils.randomHex(32)));\n};\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(privateKey, ignoreLength) {\n    if (!privateKey.startsWith('0x')) {\n        privateKey = '0x' + privateKey;\n    }\n    // 64 hex characters + hex-prefix\n    if (!ignoreLength && privateKey.length !== 66) {\n        throw new Error(\"Private key must be 32 bytes long\");\n    }\n    return this._addAccountFunctions(Account.fromPrivate(privateKey));\n};\nAccounts.prototype.signTransaction = function signTransaction(tx, privateKey, callback) {\n    var _this = this, error = false, transactionOptions = {}, hasTxSigningOptions = !!(tx && ((tx.chain && tx.hardfork) || tx.common));\n    callback = callback || function () { };\n    if (!tx) {\n        error = new Error('No transaction object given!');\n        callback(error);\n        return Promise.reject(error);\n    }\n    function signed(tx) {\n        const error = _validateTransactionForSigning(tx);\n        if (error) {\n            callback(error);\n            return Promise.reject(error);\n        }\n        try {\n            var transaction = helpers.formatters.inputCallFormatter(Object.assign({}, tx));\n            transaction.data = transaction.data || '0x';\n            transaction.value = transaction.value || '0x';\n            transaction.gasLimit = transaction.gasLimit || transaction.gas;\n            if (transaction.type === '0x1' && transaction.accessList === undefined)\n                transaction.accessList = [];\n            // Because tx has no @ethereumjs/tx signing options we use fetched vals.\n            if (!hasTxSigningOptions) {\n                transactionOptions.common = Common.forCustomChain('mainnet', {\n                    name: 'custom-network',\n                    networkId: transaction.networkId,\n                    chainId: transaction.chainId\n                }, transaction.hardfork || HardForks.London);\n                delete transaction.networkId;\n            }\n            else {\n                if (transaction.common) {\n                    transactionOptions.common = Common.forCustomChain(transaction.common.baseChain || 'mainnet', {\n                        name: transaction.common.customChain.name || 'custom-network',\n                        networkId: transaction.common.customChain.networkId,\n                        chainId: transaction.common.customChain.chainId\n                    }, transaction.common.hardfork || HardForks.London);\n                    delete transaction.common;\n                }\n                if (transaction.chain) {\n                    transactionOptions.chain = transaction.chain;\n                    delete transaction.chain;\n                }\n                if (transaction.hardfork) {\n                    transactionOptions.hardfork = transaction.hardfork;\n                    delete transaction.hardfork;\n                }\n            }\n            if (privateKey.startsWith('0x')) {\n                privateKey = privateKey.substring(2);\n            }\n            var ethTx = TransactionFactory.fromTxData(transaction, transactionOptions);\n            var signedTx = ethTx.sign(Buffer.from(privateKey, 'hex'));\n            var validationErrors = signedTx.validate(true);\n            if (validationErrors.length > 0) {\n                let errorString = 'Signer Error: ';\n                for (const validationError of validationErrors) {\n                    errorString += `${errorString} ${validationError}.`;\n                }\n                throw new Error(errorString);\n            }\n            var rlpEncoded = signedTx.serialize().toString('hex');\n            var rawTransaction = '0x' + rlpEncoded;\n            var transactionHash = utils.keccak256(rawTransaction);\n            var result = {\n                messageHash: '0x' + Buffer.from(signedTx.getMessageToSign(true)).toString('hex'),\n                v: '0x' + signedTx.v.toString('hex'),\n                r: '0x' + signedTx.r.toString('hex'),\n                s: '0x' + signedTx.s.toString('hex'),\n                rawTransaction: rawTransaction,\n                transactionHash: transactionHash\n            };\n            callback(null, result);\n            return result;\n        }\n        catch (e) {\n            callback(e);\n            return Promise.reject(e);\n        }\n    }\n    tx.type = _handleTxType(tx);\n    // Resolve immediately if nonce, chainId, price and signing options are provided\n    if (tx.nonce !== undefined &&\n        tx.chainId !== undefined &&\n        (tx.gasPrice !== undefined ||\n            (tx.maxFeePerGas !== undefined &&\n                tx.maxPriorityFeePerGas !== undefined)) &&\n        hasTxSigningOptions) {\n        return Promise.resolve(signed(tx));\n    }\n    // Otherwise, get the missing info from the Ethereum Node\n    return Promise.all([\n        isNot(tx.chainId) ? _this._ethereumCall.getChainId() : tx.chainId,\n        isNot(tx.nonce) ? _this._ethereumCall.getTransactionCount(_this.privateKeyToAccount(privateKey).address) : tx.nonce,\n        isNot(hasTxSigningOptions) ? _this._ethereumCall.getNetworkId() : 1,\n        _handleTxPricing(_this, tx)\n    ]).then(function (args) {\n        if (isNot(args[0]) || isNot(args[1]) || isNot(args[2]) || isNot(args[3])) {\n            throw new Error('One of the values \"chainId\", \"networkId\", \"gasPrice\", or \"nonce\" couldn\\'t be fetched: ' + JSON.stringify(args));\n        }\n        return signed({\n            ...tx,\n            chainId: args[0],\n            nonce: args[1],\n            networkId: args[2],\n            ...args[3] // Will either be gasPrice or maxFeePerGas and maxPriorityFeePerGas\n        });\n    });\n};\nfunction _validateTransactionForSigning(tx) {\n    if (tx.common && (tx.chain && tx.hardfork)) {\n        return new Error('Please provide the @ethereumjs/common object or the chain and hardfork property but not all together.');\n    }\n    if ((tx.chain && !tx.hardfork) || (tx.hardfork && !tx.chain)) {\n        return new Error('When specifying chain and hardfork, both values must be defined. ' +\n            'Received \"chain\": ' + tx.chain + ', \"hardfork\": ' + tx.hardfork);\n    }\n    if ((!tx.gas && !tx.gasLimit) &&\n        (!tx.maxPriorityFeePerGas && !tx.maxFeePerGas)) {\n        return new Error('\"gas\" is missing');\n    }\n    if (tx.gas && tx.gasPrice) {\n        if (tx.gas < 0 || tx.gasPrice < 0) {\n            return new Error('Gas or gasPrice is lower than 0');\n        }\n    }\n    else {\n        if (tx.maxPriorityFeePerGas < 0 || tx.maxFeePerGas < 0) {\n            return new Error('maxPriorityFeePerGas or maxFeePerGas is lower than 0');\n        }\n    }\n    if (tx.nonce < 0 || tx.chainId < 0) {\n        return new Error('Nonce or chainId is lower than 0');\n    }\n    return;\n}\nfunction _handleTxType(tx) {\n    // Taken from https://github.com/ethers-io/ethers.js/blob/2a7ce0e72a1e0c9469e10392b0329e75e341cf18/packages/abstract-signer/src.ts/index.ts#L215\n    const hasEip1559 = (tx.maxFeePerGas !== undefined || tx.maxPriorityFeePerGas !== undefined);\n    let txType;\n    if (tx.type !== undefined) {\n        txType = utils.toHex(tx.type);\n    }\n    else if (tx.type === undefined && hasEip1559) {\n        txType = '0x2';\n    }\n    if (tx.gasPrice !== undefined && (txType === '0x2' || hasEip1559))\n        throw Error(\"eip-1559 transactions don't support gasPrice\");\n    if ((txType === '0x1' || txType === '0x0') && hasEip1559)\n        throw Error(\"pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas\");\n    if (hasEip1559 ||\n        ((tx.common && tx.common.hardfork && tx.common.hardfork.toLowerCase() === HardForks.London) ||\n            (tx.hardfork && tx.hardfork.toLowerCase() === HardForks.London))) {\n        txType = '0x2';\n    }\n    else if (tx.accessList ||\n        ((tx.common && tx.common.hardfork && tx.common.hardfork.toLowerCase() === HardForks.Berlin) ||\n            (tx.hardfork && tx.hardfork.toLowerCase() === HardForks.Berlin))) {\n        txType = '0x1';\n    }\n    return txType;\n}\nfunction _handleTxPricing(_this, tx) {\n    return new Promise((resolve, reject) => {\n        try {\n            if ((tx.type === undefined || tx.type < '0x2')\n                && tx.gasPrice !== undefined) {\n                // Legacy transaction, return provided gasPrice\n                resolve({ gasPrice: tx.gasPrice });\n            }\n            else {\n                Promise.all([\n                    _this._ethereumCall.getBlockByNumber(),\n                    _this._ethereumCall.getGasPrice()\n                ]).then(responses => {\n                    const [block, gasPrice] = responses;\n                    if ((tx.type === '0x2') &&\n                        block && block.baseFeePerGas) {\n                        // The network supports EIP-1559\n                        // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                        let maxPriorityFeePerGas, maxFeePerGas;\n                        if (tx.gasPrice) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            maxPriorityFeePerGas = tx.gasPrice;\n                            maxFeePerGas = tx.gasPrice;\n                            delete tx.gasPrice;\n                        }\n                        else {\n                            maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n                            maxFeePerGas = tx.maxFeePerGas ||\n                                utils.toHex(utils.toBN(block.baseFeePerGas)\n                                    .mul(utils.toBN(2))\n                                    .add(utils.toBN(maxPriorityFeePerGas)));\n                        }\n                        resolve({ maxFeePerGas, maxPriorityFeePerGas });\n                    }\n                    else {\n                        if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\n                            throw Error(\"Network doesn't support eip-1559\");\n                        resolve({ gasPrice });\n                    }\n                });\n            }\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/* jshint ignore:start */\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx, txOptions = {}) {\n    // Rely on EthereumJs/tx to determine the type of transaction\n    const data = Buffer.from(rawTx.slice(2), \"hex\");\n    const tx = TransactionFactory.fromSerializedData(data);\n    //update checksum\n    return utils.toChecksumAddress(tx.getSenderAddress().toString(\"hex\"));\n};\n/* jshint ignore:end */\nAccounts.prototype.hashMessage = function hashMessage(data) {\n    var messageHex = utils.isHexStrict(data) ? data : utils.utf8ToHex(data);\n    var messageBytes = utils.hexToBytes(messageHex);\n    var messageBuffer = Buffer.from(messageBytes);\n    var preamble = '\\x19Ethereum Signed Message:\\n' + messageBytes.length;\n    var preambleBuffer = Buffer.from(preamble);\n    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n    return ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(ethMessage));\n};\nAccounts.prototype.sign = function sign(data, privateKey) {\n    if (!privateKey.startsWith('0x')) {\n        privateKey = '0x' + privateKey;\n    }\n    // 64 hex characters + hex-prefix\n    if (privateKey.length !== 66) {\n        throw new Error(\"Private key must be 32 bytes long\");\n    }\n    var hash = this.hashMessage(data);\n    var signature = Account.sign(hash, privateKey);\n    var vrs = Account.decodeSignature(signature);\n    return {\n        message: data,\n        messageHash: hash,\n        v: vrs[0],\n        r: vrs[1],\n        s: vrs[2],\n        signature: signature\n    };\n};\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n    var args = [].slice.apply(arguments);\n    if (!!message && typeof message === 'object') {\n        return this.recover(message.messageHash, Account.encodeSignature([message.v, message.r, message.s]), true);\n    }\n    if (!preFixed) {\n        message = this.hashMessage(message);\n    }\n    if (args.length >= 4) {\n        preFixed = args.slice(-1)[0];\n        preFixed = typeof preFixed === 'boolean' ? !!preFixed : false;\n        return this.recover(message, Account.encodeSignature(args.slice(1, 4)), preFixed); // v, r, s\n    }\n    return Account.recover(message, signature);\n};\n// Taken from https://github.com/ethereumjs/ethereumjs-wallet\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n    /* jshint maxcomplexity: 10 */\n    if (!(typeof password === 'string')) {\n        throw new Error('No password given.');\n    }\n    var json = (!!v3Keystore && typeof v3Keystore === 'object') ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n    if (json.version !== 3) {\n        throw new Error('Not a valid V3 wallet');\n    }\n    var derivedKey;\n    var kdfparams;\n    if (json.crypto.kdf === 'scrypt') {\n        kdfparams = json.crypto.kdfparams;\n        // FIXME: support progress reporting callback\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    }\n    else if (json.crypto.kdf === 'pbkdf2') {\n        kdfparams = json.crypto.kdfparams;\n        if (kdfparams.prf !== 'hmac-sha256') {\n            throw new Error('Unsupported parameters to PBKDF2');\n        }\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    }\n    else {\n        throw new Error('Unsupported key derivation scheme');\n    }\n    var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n    var mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    if (mac !== json.crypto.mac) {\n        throw new Error('Key derivation failed - possibly wrong password');\n    }\n    var decipher = cryp.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));\n    var seed = '0x' + Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex');\n    return this.privateKeyToAccount(seed, true);\n};\nAccounts.prototype.encrypt = function (privateKey, password, options) {\n    /* jshint maxcomplexity: 20 */\n    var account = this.privateKeyToAccount(privateKey, true);\n    options = options || {};\n    var salt = options.salt || cryp.randomBytes(32);\n    var iv = options.iv || cryp.randomBytes(16);\n    var derivedKey;\n    var kdf = options.kdf || 'scrypt';\n    var kdfparams = {\n        dklen: options.dklen || 32,\n        salt: salt.toString('hex')\n    };\n    if (kdf === 'pbkdf2') {\n        kdfparams.c = options.c || 262144;\n        kdfparams.prf = 'hmac-sha256';\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    }\n    else if (kdf === 'scrypt') {\n        // FIXME: support progress reporting callback\n        kdfparams.n = options.n || 8192; // 2048 4096 8192 16384\n        kdfparams.r = options.r || 8;\n        kdfparams.p = options.p || 1;\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    }\n    else {\n        throw new Error('Unsupported kdf');\n    }\n    var cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n    if (!cipher) {\n        throw new Error('Unsupported cipher');\n    }\n    var ciphertext = Buffer.from([\n        ...cipher.update(Buffer.from(account.privateKey.replace('0x', ''), 'hex')),\n        ...cipher.final()\n    ]);\n    var mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    return {\n        version: 3,\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\n        address: account.address.toLowerCase().replace('0x', ''),\n        crypto: {\n            ciphertext: ciphertext.toString('hex'),\n            cipherparams: {\n                iv: iv.toString('hex')\n            },\n            cipher: options.cipher || 'aes-128-ctr',\n            kdf: kdf,\n            kdfparams: kdfparams,\n            mac: mac.toString('hex')\n        }\n    };\n};\n// Note: this is trying to follow closely the specs on\n// http://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html\nfunction Wallet(accounts) {\n    this._accounts = accounts;\n    this.length = 0;\n    this.defaultKeyName = 'web3js_wallet';\n}\nWallet.prototype._findSafeIndex = function (pointer) {\n    pointer = pointer || 0;\n    if (this.hasOwnProperty(pointer)) {\n        return this._findSafeIndex(pointer + 1);\n    }\n    else {\n        return pointer;\n    }\n};\nWallet.prototype._currentIndexes = function () {\n    var keys = Object.keys(this);\n    var indexes = keys\n        .map(function (key) {\n        return parseInt(key);\n    })\n        .filter(function (n) {\n        return (n < 9e20);\n    });\n    return indexes;\n};\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n    for (var i = 0; i < numberOfAccounts; ++i) {\n        this.add(this._accounts.create(entropy).privateKey);\n    }\n    return this;\n};\nWallet.prototype.add = function (account) {\n    if (typeof account === 'string') {\n        account = this._accounts.privateKeyToAccount(account);\n    }\n    if (!this[account.address]) {\n        account = this._accounts.privateKeyToAccount(account.privateKey);\n        account.index = this._findSafeIndex();\n        this[account.index] = account;\n        this[account.address] = account;\n        this[account.address.toLowerCase()] = account;\n        this.length++;\n        return account;\n    }\n    else {\n        return this[account.address];\n    }\n};\nWallet.prototype.remove = function (addressOrIndex) {\n    var account = this[addressOrIndex];\n    if (account && account.address) {\n        // address\n        this[account.address].privateKey = null;\n        delete this[account.address];\n        // address lowercase\n        this[account.address.toLowerCase()].privateKey = null;\n        delete this[account.address.toLowerCase()];\n        // index\n        this[account.index].privateKey = null;\n        delete this[account.index];\n        this.length--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nWallet.prototype.clear = function () {\n    var _this = this;\n    var indexes = this._currentIndexes();\n    indexes.forEach(function (index) {\n        _this.remove(index);\n    });\n    return this;\n};\nWallet.prototype.encrypt = function (password, options) {\n    var _this = this;\n    var indexes = this._currentIndexes();\n    var accounts = indexes.map(function (index) {\n        return _this[index].encrypt(password, options);\n    });\n    return accounts;\n};\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n    var _this = this;\n    encryptedWallet.forEach(function (keystore) {\n        var account = _this._accounts.decrypt(keystore, password);\n        if (account) {\n            _this.add(account);\n        }\n        else {\n            throw new Error('Couldn\\'t decrypt accounts. Password wrong?');\n        }\n    });\n    return this;\n};\nWallet.prototype.save = function (password, keyName) {\n    localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n    return true;\n};\nWallet.prototype.load = function (password, keyName) {\n    var keystore = localStorage.getItem(keyName || this.defaultKeyName);\n    if (keystore) {\n        try {\n            keystore = JSON.parse(keystore);\n        }\n        catch (e) {\n        }\n    }\n    return this.decrypt(keystore || [], password);\n};\nif (!storageAvailable('localStorage')) {\n    delete Wallet.prototype.save;\n    delete Wallet.prototype.load;\n}\n/**\n * Checks whether a storage type is available or not\n * For more info on how this works, please refer to MDN documentation\n * https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Feature-detecting_localStorage\n *\n * @method storageAvailable\n * @param {String} type the type of storage ('localStorage', 'sessionStorage')\n * @returns {Boolean} a boolean indicating whether the specified storage is available or not\n */\nfunction storageAvailable(type) {\n    var storage;\n    try {\n        storage = window[type];\n        var x = '__storage_test__';\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    }\n    catch (e) {\n        return e && (\n        // everything except Firefox\n        e.code === 22 ||\n            // Firefox\n            e.code === 1014 ||\n            // test name field too, because code might not be present\n            // everything except Firefox\n            e.name === 'QuotaExceededError' ||\n            // Firefox\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n            // acknowledge QuotaExceededError only if there's something already stored\n            (storage && storage.length !== 0);\n    }\n}\nmodule.exports = Accounts;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLDRGQUFXO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQywwR0FBa0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFJQUFxQjtBQUMzQyxtQkFBbUIscUJBQU0sb0JBQW9CLG1CQUFPLENBQUMsd0VBQW1CLElBQUksbUJBQU8sQ0FBQyw0RUFBUTtBQUM1RixhQUFhLG1CQUFPLENBQUMseURBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLDhFQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyw4RkFBWTtBQUNoQyxjQUFjLG1CQUFPLENBQUMsNEdBQW1CO0FBQ3pDLE1BQU0scUJBQXFCLEVBQUUsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDckQsYUFBYSx5SEFBcUM7QUFDbEQsZ0JBQWdCLHVIQUFzQztBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWEsRUFBRSxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNLGlCQUFpQixNQUFNO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNLGlCQUFpQixNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0IseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLE1BQU07QUFDNUYsc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNLGlCQUFpQixNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsdUNBQXVDLE1BQU0saUJBQWlCLE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLDhDQUE4QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbGliL2luZGV4LmpzPzg5MzciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIGFjY291bnRzLmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViMy1jb3JlJyk7XG52YXIgTWV0aG9kID0gcmVxdWlyZSgnd2ViMy1jb3JlLW1ldGhvZCcpO1xudmFyIEFjY291bnQgPSByZXF1aXJlKCdldGgtbGliL2xpYi9hY2NvdW50Jyk7XG52YXIgY3J5cCA9ICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCdjcnlwdG8tYnJvd3NlcmlmeScpIDogcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgc2NyeXB0ID0gcmVxdWlyZSgnc2NyeXB0LWpzJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKTtcbnZhciB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKTtcbnZhciBDb21tb24gPSByZXF1aXJlKCdAZXRoZXJldW1qcy9jb21tb24nKS5kZWZhdWx0O1xudmFyIEhhcmRGb3JrcyA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL2NvbW1vbicpLkhhcmRmb3JrO1xudmFyIGV0aGVyZXVtanNVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG52YXIgaXNOb3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHx8IHZhbHVlID09PSBudWxsO1xufTtcbnZhciBBY2NvdW50cyA9IGZ1bmN0aW9uIEFjY291bnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gc2V0cyBfcmVxdWVzdG1hbmFnZXJcbiAgICBjb3JlLnBhY2thZ2VJbml0KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gcmVtb3ZlIHVuZWNlc3NhcnkgY29yZSBmdW5jdGlvbnNcbiAgICBkZWxldGUgdGhpcy5CYXRjaFJlcXVlc3Q7XG4gICAgZGVsZXRlIHRoaXMuZXh0ZW5kO1xuICAgIHZhciBfZXRoZXJldW1DYWxsID0gW1xuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXROZXR3b3JrSWQnLFxuICAgICAgICAgICAgY2FsbDogJ25ldF92ZXJzaW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogcGFyc2VJbnRcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldENoYWluSWQnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMuaGV4VG9OdW1iZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEdhc1ByaWNlJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgcGFyYW1zOiAwXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Z1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0FkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzICcgKyBhZGRyZXNzICsgJyBpcyBub3QgYSB2YWxpZCBhZGRyZXNzIHRvIGdldCB0aGUgXCJ0cmFuc2FjdGlvbkNvdW50XCIuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbGF0ZXN0JztcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyID8gdXRpbHMudG9IZXgoYmxvY2tOdW1iZXIpIDogJ2xhdGVzdCc7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfSksXG4gICAgXTtcbiAgICAvLyBhdHRhY2ggbWV0aG9kcyB0byB0aGlzLl9ldGhlcmV1bUNhbGxcbiAgICB0aGlzLl9ldGhlcmV1bUNhbGwgPSB7fTtcbiAgICBfZXRoZXJldW1DYWxsLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3QoX3RoaXMuX2V0aGVyZXVtQ2FsbCk7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihfdGhpcy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuICAgIHRoaXMud2FsbGV0ID0gbmV3IFdhbGxldCh0aGlzKTtcbn07XG5BY2NvdW50cy5wcm90b3R5cGUuX2FkZEFjY291bnRGdW5jdGlvbnMgPSBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gYWRkIHNpZ24gZnVuY3Rpb25zXG4gICAgYWNjb3VudC5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24odHgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zaWduVHJhbnNhY3Rpb24odHgsIGFjY291bnQucHJpdmF0ZUtleSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgYWNjb3VudC5zaWduID0gZnVuY3Rpb24gc2lnbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zaWduKGRhdGEsIGFjY291bnQucHJpdmF0ZUtleSk7XG4gICAgfTtcbiAgICBhY2NvdW50LmVuY3J5cHQgPSBmdW5jdGlvbiBlbmNyeXB0KHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5lbmNyeXB0KGFjY291bnQucHJpdmF0ZUtleSwgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIGFjY291bnQ7XG59O1xuQWNjb3VudHMucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShlbnRyb3B5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZEFjY291bnRGdW5jdGlvbnMoQWNjb3VudC5jcmVhdGUoZW50cm9weSB8fCB1dGlscy5yYW5kb21IZXgoMzIpKSk7XG59O1xuQWNjb3VudHMucHJvdG90eXBlLnByaXZhdGVLZXlUb0FjY291bnQgPSBmdW5jdGlvbiBwcml2YXRlS2V5VG9BY2NvdW50KHByaXZhdGVLZXksIGlnbm9yZUxlbmd0aCkge1xuICAgIGlmICghcHJpdmF0ZUtleS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHByaXZhdGVLZXkgPSAnMHgnICsgcHJpdmF0ZUtleTtcbiAgICB9XG4gICAgLy8gNjQgaGV4IGNoYXJhY3RlcnMgKyBoZXgtcHJlZml4XG4gICAgaWYgKCFpZ25vcmVMZW5ndGggJiYgcHJpdmF0ZUtleS5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaXZhdGUga2V5IG11c3QgYmUgMzIgYnl0ZXMgbG9uZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZEFjY291bnRGdW5jdGlvbnMoQWNjb3VudC5mcm9tUHJpdmF0ZShwcml2YXRlS2V5KSk7XG59O1xuQWNjb3VudHMucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbih0eCwgcHJpdmF0ZUtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCBlcnJvciA9IGZhbHNlLCB0cmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgaGFzVHhTaWduaW5nT3B0aW9ucyA9ICEhKHR4ICYmICgodHguY2hhaW4gJiYgdHguaGFyZGZvcmspIHx8IHR4LmNvbW1vbikpO1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICAgIGlmICghdHgpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIHRyYW5zYWN0aW9uIG9iamVjdCBnaXZlbiEnKTtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWduZWQodHgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBfdmFsaWRhdGVUcmFuc2FjdGlvbkZvclNpZ25pbmcodHgpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGhlbHBlcnMuZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXIoT2JqZWN0LmFzc2lnbih7fSwgdHgpKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSB0cmFuc2FjdGlvbi5kYXRhIHx8ICcweCc7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi52YWx1ZSA9IHRyYW5zYWN0aW9uLnZhbHVlIHx8ICcweCc7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IHRyYW5zYWN0aW9uLmdhcztcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSAnMHgxJyAmJiB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0eCBoYXMgbm8gQGV0aGVyZXVtanMvdHggc2lnbmluZyBvcHRpb25zIHdlIHVzZSBmZXRjaGVkIHZhbHMuXG4gICAgICAgICAgICBpZiAoIWhhc1R4U2lnbmluZ09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk9wdGlvbnMuY29tbW9uID0gQ29tbW9uLmZvckN1c3RvbUNoYWluKCdtYWlubmV0Jywge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY3VzdG9tLW5ldHdvcmsnLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IHRyYW5zYWN0aW9uLm5ldHdvcmtJZCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogdHJhbnNhY3Rpb24uY2hhaW5JZFxuICAgICAgICAgICAgICAgIH0sIHRyYW5zYWN0aW9uLmhhcmRmb3JrIHx8IEhhcmRGb3Jrcy5Mb25kb24pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi5uZXR3b3JrSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uY29tbW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uT3B0aW9ucy5jb21tb24gPSBDb21tb24uZm9yQ3VzdG9tQ2hhaW4odHJhbnNhY3Rpb24uY29tbW9uLmJhc2VDaGFpbiB8fCAnbWFpbm5ldCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRyYW5zYWN0aW9uLmNvbW1vbi5jdXN0b21DaGFpbi5uYW1lIHx8ICdjdXN0b20tbmV0d29yaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IHRyYW5zYWN0aW9uLmNvbW1vbi5jdXN0b21DaGFpbi5uZXR3b3JrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0cmFuc2FjdGlvbi5jb21tb24uY3VzdG9tQ2hhaW4uY2hhaW5JZFxuICAgICAgICAgICAgICAgICAgICB9LCB0cmFuc2FjdGlvbi5jb21tb24uaGFyZGZvcmsgfHwgSGFyZEZvcmtzLkxvbmRvbik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi5jb21tb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbikge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk9wdGlvbnMuY2hhaW4gPSB0cmFuc2FjdGlvbi5jaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uLmNoYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uaGFyZGZvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25PcHRpb25zLmhhcmRmb3JrID0gdHJhbnNhY3Rpb24uaGFyZGZvcms7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi5oYXJkZm9yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpdmF0ZUtleS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXkuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV0aFR4ID0gVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgc2lnbmVkVHggPSBldGhUeC5zaWduKEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksICdoZXgnKSk7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGlvbkVycm9ycyA9IHNpZ25lZFR4LnZhbGlkYXRlKHRydWUpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBlcnJvclN0cmluZyA9ICdTaWduZXIgRXJyb3I6ICc7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWxpZGF0aW9uRXJyb3Igb2YgdmFsaWRhdGlvbkVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvclN0cmluZyArPSBgJHtlcnJvclN0cmluZ30gJHt2YWxpZGF0aW9uRXJyb3J9LmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmxwRW5jb2RlZCA9IHNpZ25lZFR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIHZhciByYXdUcmFuc2FjdGlvbiA9ICcweCcgKyBybHBFbmNvZGVkO1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uSGFzaCA9IHV0aWxzLmtlY2NhazI1NihyYXdUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYXNoOiAnMHgnICsgQnVmZmVyLmZyb20oc2lnbmVkVHguZ2V0TWVzc2FnZVRvU2lnbih0cnVlKSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIHY6ICcweCcgKyBzaWduZWRUeC52LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICByOiAnMHgnICsgc2lnbmVkVHguci50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgczogJzB4JyArIHNpZ25lZFR4LnMudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIHJhd1RyYW5zYWN0aW9uOiByYXdUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0eC50eXBlID0gX2hhbmRsZVR4VHlwZSh0eCk7XG4gICAgLy8gUmVzb2x2ZSBpbW1lZGlhdGVseSBpZiBub25jZSwgY2hhaW5JZCwgcHJpY2UgYW5kIHNpZ25pbmcgb3B0aW9ucyBhcmUgcHJvdmlkZWRcbiAgICBpZiAodHgubm9uY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eC5jaGFpbklkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKHR4Lmdhc1ByaWNlICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICh0eC5tYXhGZWVQZXJHYXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9PSB1bmRlZmluZWQpKSAmJlxuICAgICAgICBoYXNUeFNpZ25pbmdPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lnbmVkKHR4KSk7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZ2V0IHRoZSBtaXNzaW5nIGluZm8gZnJvbSB0aGUgRXRoZXJldW0gTm9kZVxuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGlzTm90KHR4LmNoYWluSWQpID8gX3RoaXMuX2V0aGVyZXVtQ2FsbC5nZXRDaGFpbklkKCkgOiB0eC5jaGFpbklkLFxuICAgICAgICBpc05vdCh0eC5ub25jZSkgPyBfdGhpcy5fZXRoZXJldW1DYWxsLmdldFRyYW5zYWN0aW9uQ291bnQoX3RoaXMucHJpdmF0ZUtleVRvQWNjb3VudChwcml2YXRlS2V5KS5hZGRyZXNzKSA6IHR4Lm5vbmNlLFxuICAgICAgICBpc05vdChoYXNUeFNpZ25pbmdPcHRpb25zKSA/IF90aGlzLl9ldGhlcmV1bUNhbGwuZ2V0TmV0d29ya0lkKCkgOiAxLFxuICAgICAgICBfaGFuZGxlVHhQcmljaW5nKF90aGlzLCB0eClcbiAgICBdKS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGlmIChpc05vdChhcmdzWzBdKSB8fCBpc05vdChhcmdzWzFdKSB8fCBpc05vdChhcmdzWzJdKSB8fCBpc05vdChhcmdzWzNdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb2YgdGhlIHZhbHVlcyBcImNoYWluSWRcIiwgXCJuZXR3b3JrSWRcIiwgXCJnYXNQcmljZVwiLCBvciBcIm5vbmNlXCIgY291bGRuXFwndCBiZSBmZXRjaGVkOiAnICsgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduZWQoe1xuICAgICAgICAgICAgLi4udHgsXG4gICAgICAgICAgICBjaGFpbklkOiBhcmdzWzBdLFxuICAgICAgICAgICAgbm9uY2U6IGFyZ3NbMV0sXG4gICAgICAgICAgICBuZXR3b3JrSWQ6IGFyZ3NbMl0sXG4gICAgICAgICAgICAuLi5hcmdzWzNdIC8vIFdpbGwgZWl0aGVyIGJlIGdhc1ByaWNlIG9yIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gX3ZhbGlkYXRlVHJhbnNhY3Rpb25Gb3JTaWduaW5nKHR4KSB7XG4gICAgaWYgKHR4LmNvbW1vbiAmJiAodHguY2hhaW4gJiYgdHguaGFyZGZvcmspKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIHRoZSBAZXRoZXJldW1qcy9jb21tb24gb2JqZWN0IG9yIHRoZSBjaGFpbiBhbmQgaGFyZGZvcmsgcHJvcGVydHkgYnV0IG5vdCBhbGwgdG9nZXRoZXIuJyk7XG4gICAgfVxuICAgIGlmICgodHguY2hhaW4gJiYgIXR4LmhhcmRmb3JrKSB8fCAodHguaGFyZGZvcmsgJiYgIXR4LmNoYWluKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdXaGVuIHNwZWNpZnlpbmcgY2hhaW4gYW5kIGhhcmRmb3JrLCBib3RoIHZhbHVlcyBtdXN0IGJlIGRlZmluZWQuICcgK1xuICAgICAgICAgICAgJ1JlY2VpdmVkIFwiY2hhaW5cIjogJyArIHR4LmNoYWluICsgJywgXCJoYXJkZm9ya1wiOiAnICsgdHguaGFyZGZvcmspO1xuICAgIH1cbiAgICBpZiAoKCF0eC5nYXMgJiYgIXR4Lmdhc0xpbWl0KSAmJlxuICAgICAgICAoIXR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICYmICF0eC5tYXhGZWVQZXJHYXMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1wiZ2FzXCIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAodHguZ2FzICYmIHR4Lmdhc1ByaWNlKSB7XG4gICAgICAgIGlmICh0eC5nYXMgPCAwIHx8IHR4Lmdhc1ByaWNlIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignR2FzIG9yIGdhc1ByaWNlIGlzIGxvd2VyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPCAwIHx8IHR4Lm1heEZlZVBlckdhcyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ21heFByaW9yaXR5RmVlUGVyR2FzIG9yIG1heEZlZVBlckdhcyBpcyBsb3dlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHgubm9uY2UgPCAwIHx8IHR4LmNoYWluSWQgPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ05vbmNlIG9yIGNoYWluSWQgaXMgbG93ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIF9oYW5kbGVUeFR5cGUodHgpIHtcbiAgICAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcnMtaW8vZXRoZXJzLmpzL2Jsb2IvMmE3Y2UwZTcyYTFlMGM5NDY5ZTEwMzkyYjAzMjllNzVlMzQxY2YxOC9wYWNrYWdlcy9hYnN0cmFjdC1zaWduZXIvc3JjLnRzL2luZGV4LnRzI0wyMTVcbiAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHR4Lm1heEZlZVBlckdhcyAhPT0gdW5kZWZpbmVkIHx8IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9PSB1bmRlZmluZWQpO1xuICAgIGxldCB0eFR5cGU7XG4gICAgaWYgKHR4LnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eFR5cGUgPSB1dGlscy50b0hleCh0eC50eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHgudHlwZSA9PT0gdW5kZWZpbmVkICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgdHhUeXBlID0gJzB4Mic7XG4gICAgfVxuICAgIGlmICh0eC5nYXNQcmljZSAhPT0gdW5kZWZpbmVkICYmICh0eFR5cGUgPT09ICcweDInIHx8IGhhc0VpcDE1NTkpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImVpcC0xNTU5IHRyYW5zYWN0aW9ucyBkb24ndCBzdXBwb3J0IGdhc1ByaWNlXCIpO1xuICAgIGlmICgodHhUeXBlID09PSAnMHgxJyB8fCB0eFR5cGUgPT09ICcweDAnKSAmJiBoYXNFaXAxNTU5KVxuICAgICAgICB0aHJvdyBFcnJvcihcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkb24ndCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiKTtcbiAgICBpZiAoaGFzRWlwMTU1OSB8fFxuICAgICAgICAoKHR4LmNvbW1vbiAmJiB0eC5jb21tb24uaGFyZGZvcmsgJiYgdHguY29tbW9uLmhhcmRmb3JrLnRvTG93ZXJDYXNlKCkgPT09IEhhcmRGb3Jrcy5Mb25kb24pIHx8XG4gICAgICAgICAgICAodHguaGFyZGZvcmsgJiYgdHguaGFyZGZvcmsudG9Mb3dlckNhc2UoKSA9PT0gSGFyZEZvcmtzLkxvbmRvbikpKSB7XG4gICAgICAgIHR4VHlwZSA9ICcweDInO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eC5hY2Nlc3NMaXN0IHx8XG4gICAgICAgICgodHguY29tbW9uICYmIHR4LmNvbW1vbi5oYXJkZm9yayAmJiB0eC5jb21tb24uaGFyZGZvcmsudG9Mb3dlckNhc2UoKSA9PT0gSGFyZEZvcmtzLkJlcmxpbikgfHxcbiAgICAgICAgICAgICh0eC5oYXJkZm9yayAmJiB0eC5oYXJkZm9yay50b0xvd2VyQ2FzZSgpID09PSBIYXJkRm9ya3MuQmVybGluKSkpIHtcbiAgICAgICAgdHhUeXBlID0gJzB4MSc7XG4gICAgfVxuICAgIHJldHVybiB0eFR5cGU7XG59XG5mdW5jdGlvbiBfaGFuZGxlVHhQcmljaW5nKF90aGlzLCB0eCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKHR4LnR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eC50eXBlIDwgJzB4MicpXG4gICAgICAgICAgICAgICAgJiYgdHguZ2FzUHJpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSB0cmFuc2FjdGlvbiwgcmV0dXJuIHByb3ZpZGVkIGdhc1ByaWNlXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGdhc1ByaWNlOiB0eC5nYXNQcmljZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V0aGVyZXVtQ2FsbC5nZXRCbG9ja0J5TnVtYmVyKCksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9ldGhlcmV1bUNhbGwuZ2V0R2FzUHJpY2UoKVxuICAgICAgICAgICAgICAgIF0pLnRoZW4ocmVzcG9uc2VzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2Jsb2NrLCBnYXNQcmljZV0gPSByZXNwb25zZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHgudHlwZSA9PT0gJzB4MicpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJzLWlvL2V0aGVycy5qcy9ibG9iL2JhNjg1NGJkZDVhOTEyZmU4NzNkNWRhNDk0Y2I1YzYyYzE5MGFkZGUvcGFja2FnZXMvYWJzdHJhY3QtcHJvdmlkZXIvc3JjLnRzL2luZGV4LnRzI0wyMzBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgJzB4OTUwMkY5MDAnOyAvLyAyLjUgR3dlaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy50b0hleCh1dGlscy50b0JOKGJsb2NrLmJhc2VGZWVQZXJHYXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubXVsKHV0aWxzLnRvQk4oMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHV0aWxzLnRvQk4obWF4UHJpb3JpdHlGZWVQZXJHYXMpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCB0eC5tYXhGZWVQZXJHYXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBlaXAtMTU1OVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBnYXNQcmljZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuQWNjb3VudHMucHJvdG90eXBlLnJlY292ZXJUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHJlY292ZXJUcmFuc2FjdGlvbihyYXdUeCwgdHhPcHRpb25zID0ge30pIHtcbiAgICAvLyBSZWx5IG9uIEV0aGVyZXVtSnMvdHggdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKHJhd1R4LnNsaWNlKDIpLCBcImhleFwiKTtcbiAgICBjb25zdCB0eCA9IFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tU2VyaWFsaXplZERhdGEoZGF0YSk7XG4gICAgLy91cGRhdGUgY2hlY2tzdW1cbiAgICByZXR1cm4gdXRpbHMudG9DaGVja3N1bUFkZHJlc3ModHguZ2V0U2VuZGVyQWRkcmVzcygpLnRvU3RyaW5nKFwiaGV4XCIpKTtcbn07XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuQWNjb3VudHMucHJvdG90eXBlLmhhc2hNZXNzYWdlID0gZnVuY3Rpb24gaGFzaE1lc3NhZ2UoZGF0YSkge1xuICAgIHZhciBtZXNzYWdlSGV4ID0gdXRpbHMuaXNIZXhTdHJpY3QoZGF0YSkgPyBkYXRhIDogdXRpbHMudXRmOFRvSGV4KGRhdGEpO1xuICAgIHZhciBtZXNzYWdlQnl0ZXMgPSB1dGlscy5oZXhUb0J5dGVzKG1lc3NhZ2VIZXgpO1xuICAgIHZhciBtZXNzYWdlQnVmZmVyID0gQnVmZmVyLmZyb20obWVzc2FnZUJ5dGVzKTtcbiAgICB2YXIgcHJlYW1ibGUgPSAnXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4nICsgbWVzc2FnZUJ5dGVzLmxlbmd0aDtcbiAgICB2YXIgcHJlYW1ibGVCdWZmZXIgPSBCdWZmZXIuZnJvbShwcmVhbWJsZSk7XG4gICAgdmFyIGV0aE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFtwcmVhbWJsZUJ1ZmZlciwgbWVzc2FnZUJ1ZmZlcl0pO1xuICAgIHJldHVybiBldGhlcmV1bWpzVXRpbC5idWZmZXJUb0hleChldGhlcmV1bWpzVXRpbC5rZWNjYWsyNTYoZXRoTWVzc2FnZSkpO1xufTtcbkFjY291bnRzLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihkYXRhLCBwcml2YXRlS2V5KSB7XG4gICAgaWYgKCFwcml2YXRlS2V5LnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcHJpdmF0ZUtleSA9ICcweCcgKyBwcml2YXRlS2V5O1xuICAgIH1cbiAgICAvLyA2NCBoZXggY2hhcmFjdGVycyArIGhleC1wcmVmaXhcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaXZhdGUga2V5IG11c3QgYmUgMzIgYnl0ZXMgbG9uZ1wiKTtcbiAgICB9XG4gICAgdmFyIGhhc2ggPSB0aGlzLmhhc2hNZXNzYWdlKGRhdGEpO1xuICAgIHZhciBzaWduYXR1cmUgPSBBY2NvdW50LnNpZ24oaGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgdmFyIHZycyA9IEFjY291bnQuZGVjb2RlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogZGF0YSxcbiAgICAgICAgbWVzc2FnZUhhc2g6IGhhc2gsXG4gICAgICAgIHY6IHZyc1swXSxcbiAgICAgICAgcjogdnJzWzFdLFxuICAgICAgICBzOiB2cnNbMl0sXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgfTtcbn07XG5BY2NvdW50cy5wcm90b3R5cGUucmVjb3ZlciA9IGZ1bmN0aW9uIHJlY292ZXIobWVzc2FnZSwgc2lnbmF0dXJlLCBwcmVGaXhlZCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcbiAgICBpZiAoISFtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyKG1lc3NhZ2UubWVzc2FnZUhhc2gsIEFjY291bnQuZW5jb2RlU2lnbmF0dXJlKFttZXNzYWdlLnYsIG1lc3NhZ2UuciwgbWVzc2FnZS5zXSksIHRydWUpO1xuICAgIH1cbiAgICBpZiAoIXByZUZpeGVkKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPj0gNCkge1xuICAgICAgICBwcmVGaXhlZCA9IGFyZ3Muc2xpY2UoLTEpWzBdO1xuICAgICAgICBwcmVGaXhlZCA9IHR5cGVvZiBwcmVGaXhlZCA9PT0gJ2Jvb2xlYW4nID8gISFwcmVGaXhlZCA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyKG1lc3NhZ2UsIEFjY291bnQuZW5jb2RlU2lnbmF0dXJlKGFyZ3Muc2xpY2UoMSwgNCkpLCBwcmVGaXhlZCk7IC8vIHYsIHIsIHNcbiAgICB9XG4gICAgcmV0dXJuIEFjY291bnQucmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUpO1xufTtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvZXRoZXJldW1qcy13YWxsZXRcbkFjY291bnRzLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKHYzS2V5c3RvcmUsIHBhc3N3b3JkLCBub25TdHJpY3QpIHtcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgICBpZiAoISh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhc3N3b3JkIGdpdmVuLicpO1xuICAgIH1cbiAgICB2YXIganNvbiA9ICghIXYzS2V5c3RvcmUgJiYgdHlwZW9mIHYzS2V5c3RvcmUgPT09ICdvYmplY3QnKSA/IHYzS2V5c3RvcmUgOiBKU09OLnBhcnNlKG5vblN0cmljdCA/IHYzS2V5c3RvcmUudG9Mb3dlckNhc2UoKSA6IHYzS2V5c3RvcmUpO1xuICAgIGlmIChqc29uLnZlcnNpb24gIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBWMyB3YWxsZXQnKTtcbiAgICB9XG4gICAgdmFyIGRlcml2ZWRLZXk7XG4gICAgdmFyIGtkZnBhcmFtcztcbiAgICBpZiAoanNvbi5jcnlwdG8ua2RmID09PSAnc2NyeXB0Jykge1xuICAgICAgICBrZGZwYXJhbXMgPSBqc29uLmNyeXB0by5rZGZwYXJhbXM7XG4gICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IHByb2dyZXNzIHJlcG9ydGluZyBjYWxsYmFja1xuICAgICAgICBkZXJpdmVkS2V5ID0gc2NyeXB0LnN5bmNTY3J5cHQoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBCdWZmZXIuZnJvbShrZGZwYXJhbXMuc2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMubiwga2RmcGFyYW1zLnIsIGtkZnBhcmFtcy5wLCBrZGZwYXJhbXMuZGtsZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChqc29uLmNyeXB0by5rZGYgPT09ICdwYmtkZjInKSB7XG4gICAgICAgIGtkZnBhcmFtcyA9IGpzb24uY3J5cHRvLmtkZnBhcmFtcztcbiAgICAgICAgaWYgKGtkZnBhcmFtcy5wcmYgIT09ICdobWFjLXNoYTI1NicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcGFyYW1ldGVycyB0byBQQktERjInKTtcbiAgICAgICAgfVxuICAgICAgICBkZXJpdmVkS2V5ID0gY3J5cC5wYmtkZjJTeW5jKEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oa2RmcGFyYW1zLnNhbHQsICdoZXgnKSwga2RmcGFyYW1zLmMsIGtkZnBhcmFtcy5ka2xlbiwgJ3NoYTI1NicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBzY2hlbWUnKTtcbiAgICB9XG4gICAgdmFyIGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShqc29uLmNyeXB0by5jaXBoZXJ0ZXh0LCAnaGV4Jyk7XG4gICAgdmFyIG1hYyA9IHV0aWxzLnNoYTMoQnVmZmVyLmZyb20oWy4uLmRlcml2ZWRLZXkuc2xpY2UoMTYsIDMyKSwgLi4uY2lwaGVydGV4dF0pKS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICBpZiAobWFjICE9PSBqc29uLmNyeXB0by5tYWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZGVyaXZhdGlvbiBmYWlsZWQgLSBwb3NzaWJseSB3cm9uZyBwYXNzd29yZCcpO1xuICAgIH1cbiAgICB2YXIgZGVjaXBoZXIgPSBjcnlwLmNyZWF0ZURlY2lwaGVyaXYoanNvbi5jcnlwdG8uY2lwaGVyLCBkZXJpdmVkS2V5LnNsaWNlKDAsIDE2KSwgQnVmZmVyLmZyb20oanNvbi5jcnlwdG8uY2lwaGVycGFyYW1zLml2LCAnaGV4JykpO1xuICAgIHZhciBzZWVkID0gJzB4JyArIEJ1ZmZlci5mcm9tKFsuLi5kZWNpcGhlci51cGRhdGUoY2lwaGVydGV4dCksIC4uLmRlY2lwaGVyLmZpbmFsKCldKS50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIHRoaXMucHJpdmF0ZUtleVRvQWNjb3VudChzZWVkLCB0cnVlKTtcbn07XG5BY2NvdW50cy5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAyMCAqL1xuICAgIHZhciBhY2NvdW50ID0gdGhpcy5wcml2YXRlS2V5VG9BY2NvdW50KHByaXZhdGVLZXksIHRydWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzYWx0ID0gb3B0aW9ucy5zYWx0IHx8IGNyeXAucmFuZG9tQnl0ZXMoMzIpO1xuICAgIHZhciBpdiA9IG9wdGlvbnMuaXYgfHwgY3J5cC5yYW5kb21CeXRlcygxNik7XG4gICAgdmFyIGRlcml2ZWRLZXk7XG4gICAgdmFyIGtkZiA9IG9wdGlvbnMua2RmIHx8ICdzY3J5cHQnO1xuICAgIHZhciBrZGZwYXJhbXMgPSB7XG4gICAgICAgIGRrbGVuOiBvcHRpb25zLmRrbGVuIHx8IDMyLFxuICAgICAgICBzYWx0OiBzYWx0LnRvU3RyaW5nKCdoZXgnKVxuICAgIH07XG4gICAgaWYgKGtkZiA9PT0gJ3Bia2RmMicpIHtcbiAgICAgICAga2RmcGFyYW1zLmMgPSBvcHRpb25zLmMgfHwgMjYyMTQ0O1xuICAgICAgICBrZGZwYXJhbXMucHJmID0gJ2htYWMtc2hhMjU2JztcbiAgICAgICAgZGVyaXZlZEtleSA9IGNyeXAucGJrZGYyU3luYyhCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGtkZnBhcmFtcy5zYWx0LCAnaGV4JyksIGtkZnBhcmFtcy5jLCBrZGZwYXJhbXMuZGtsZW4sICdzaGEyNTYnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2RmID09PSAnc2NyeXB0Jykge1xuICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBwcm9ncmVzcyByZXBvcnRpbmcgY2FsbGJhY2tcbiAgICAgICAga2RmcGFyYW1zLm4gPSBvcHRpb25zLm4gfHwgODE5MjsgLy8gMjA0OCA0MDk2IDgxOTIgMTYzODRcbiAgICAgICAga2RmcGFyYW1zLnIgPSBvcHRpb25zLnIgfHwgODtcbiAgICAgICAga2RmcGFyYW1zLnAgPSBvcHRpb25zLnAgfHwgMTtcbiAgICAgICAgZGVyaXZlZEtleSA9IHNjcnlwdC5zeW5jU2NyeXB0KEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oa2RmcGFyYW1zLnNhbHQsICdoZXgnKSwga2RmcGFyYW1zLm4sIGtkZnBhcmFtcy5yLCBrZGZwYXJhbXMucCwga2RmcGFyYW1zLmRrbGVuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2RmJyk7XG4gICAgfVxuICAgIHZhciBjaXBoZXIgPSBjcnlwLmNyZWF0ZUNpcGhlcml2KG9wdGlvbnMuY2lwaGVyIHx8ICdhZXMtMTI4LWN0cicsIGRlcml2ZWRLZXkuc2xpY2UoMCwgMTYpLCBpdik7XG4gICAgaWYgKCFjaXBoZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjaXBoZXInKTtcbiAgICB9XG4gICAgdmFyIGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShbXG4gICAgICAgIC4uLmNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oYWNjb3VudC5wcml2YXRlS2V5LnJlcGxhY2UoJzB4JywgJycpLCAnaGV4JykpLFxuICAgICAgICAuLi5jaXBoZXIuZmluYWwoKVxuICAgIF0pO1xuICAgIHZhciBtYWMgPSB1dGlscy5zaGEzKEJ1ZmZlci5mcm9tKFsuLi5kZXJpdmVkS2V5LnNsaWNlKDE2LCAzMiksIC4uLmNpcGhlcnRleHRdKSkucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogMyxcbiAgICAgICAgaWQ6IHV1aWQudjQoeyByYW5kb206IG9wdGlvbnMudXVpZCB8fCBjcnlwLnJhbmRvbUJ5dGVzKDE2KSB9KSxcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnMHgnLCAnJyksXG4gICAgICAgIGNyeXB0bzoge1xuICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dC50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICBjaXBoZXJwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBpdjogaXYudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lwaGVyOiBvcHRpb25zLmNpcGhlciB8fCAnYWVzLTEyOC1jdHInLFxuICAgICAgICAgICAga2RmOiBrZGYsXG4gICAgICAgICAgICBrZGZwYXJhbXM6IGtkZnBhcmFtcyxcbiAgICAgICAgICAgIG1hYzogbWFjLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyBOb3RlOiB0aGlzIGlzIHRyeWluZyB0byBmb2xsb3cgY2xvc2VseSB0aGUgc3BlY3Mgb25cbi8vIGh0dHA6Ly93ZWIzanMucmVhZHRoZWRvY3MuaW8vZW4vMS4wL3dlYjMtZXRoLWFjY291bnRzLmh0bWxcbmZ1bmN0aW9uIFdhbGxldChhY2NvdW50cykge1xuICAgIHRoaXMuX2FjY291bnRzID0gYWNjb3VudHM7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGVmYXVsdEtleU5hbWUgPSAnd2ViM2pzX3dhbGxldCc7XG59XG5XYWxsZXQucHJvdG90eXBlLl9maW5kU2FmZUluZGV4ID0gZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgICBwb2ludGVyID0gcG9pbnRlciB8fCAwO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHBvaW50ZXIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kU2FmZUluZGV4KHBvaW50ZXIgKyAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwb2ludGVyO1xuICAgIH1cbn07XG5XYWxsZXQucHJvdG90eXBlLl9jdXJyZW50SW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIHZhciBpbmRleGVzID0ga2V5c1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGtleSk7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gKG4gPCA5ZTIwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW5kZXhlcztcbn07XG5XYWxsZXQucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChudW1iZXJPZkFjY291bnRzLCBlbnRyb3B5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkFjY291bnRzOyArK2kpIHtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5fYWNjb3VudHMuY3JlYXRlKGVudHJvcHkpLnByaXZhdGVLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5XYWxsZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgaWYgKHR5cGVvZiBhY2NvdW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2NvdW50ID0gdGhpcy5fYWNjb3VudHMucHJpdmF0ZUtleVRvQWNjb3VudChhY2NvdW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzW2FjY291bnQuYWRkcmVzc10pIHtcbiAgICAgICAgYWNjb3VudCA9IHRoaXMuX2FjY291bnRzLnByaXZhdGVLZXlUb0FjY291bnQoYWNjb3VudC5wcml2YXRlS2V5KTtcbiAgICAgICAgYWNjb3VudC5pbmRleCA9IHRoaXMuX2ZpbmRTYWZlSW5kZXgoKTtcbiAgICAgICAgdGhpc1thY2NvdW50LmluZGV4XSA9IGFjY291bnQ7XG4gICAgICAgIHRoaXNbYWNjb3VudC5hZGRyZXNzXSA9IGFjY291bnQ7XG4gICAgICAgIHRoaXNbYWNjb3VudC5hZGRyZXNzLnRvTG93ZXJDYXNlKCldID0gYWNjb3VudDtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgcmV0dXJuIGFjY291bnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpc1thY2NvdW50LmFkZHJlc3NdO1xuICAgIH1cbn07XG5XYWxsZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JJbmRleCkge1xuICAgIHZhciBhY2NvdW50ID0gdGhpc1thZGRyZXNzT3JJbmRleF07XG4gICAgaWYgKGFjY291bnQgJiYgYWNjb3VudC5hZGRyZXNzKSB7XG4gICAgICAgIC8vIGFkZHJlc3NcbiAgICAgICAgdGhpc1thY2NvdW50LmFkZHJlc3NdLnByaXZhdGVLZXkgPSBudWxsO1xuICAgICAgICBkZWxldGUgdGhpc1thY2NvdW50LmFkZHJlc3NdO1xuICAgICAgICAvLyBhZGRyZXNzIGxvd2VyY2FzZVxuICAgICAgICB0aGlzW2FjY291bnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXS5wcml2YXRlS2V5ID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHRoaXNbYWNjb3VudC5hZGRyZXNzLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvLyBpbmRleFxuICAgICAgICB0aGlzW2FjY291bnQuaW5kZXhdLnByaXZhdGVLZXkgPSBudWxsO1xuICAgICAgICBkZWxldGUgdGhpc1thY2NvdW50LmluZGV4XTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbldhbGxldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgaW5kZXhlcyA9IHRoaXMuX2N1cnJlbnRJbmRleGVzKCk7XG4gICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUoaW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcbldhbGxldC5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGluZGV4ZXMgPSB0aGlzLl9jdXJyZW50SW5kZXhlcygpO1xuICAgIHZhciBhY2NvdW50cyA9IGluZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gX3RoaXNbaW5kZXhdLmVuY3J5cHQocGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2NvdW50cztcbn07XG5XYWxsZXQucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoZW5jcnlwdGVkV2FsbGV0LCBwYXNzd29yZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZW5jcnlwdGVkV2FsbGV0LmZvckVhY2goZnVuY3Rpb24gKGtleXN0b3JlKSB7XG4gICAgICAgIHZhciBhY2NvdW50ID0gX3RoaXMuX2FjY291bnRzLmRlY3J5cHQoa2V5c3RvcmUsIHBhc3N3b3JkKTtcbiAgICAgICAgaWYgKGFjY291bnQpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZChhY2NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBkZWNyeXB0IGFjY291bnRzLiBQYXNzd29yZCB3cm9uZz8nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcbldhbGxldC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5TmFtZSkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleU5hbWUgfHwgdGhpcy5kZWZhdWx0S2V5TmFtZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5lbmNyeXB0KHBhc3N3b3JkKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbldhbGxldC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5TmFtZSkge1xuICAgIHZhciBrZXlzdG9yZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleU5hbWUgfHwgdGhpcy5kZWZhdWx0S2V5TmFtZSk7XG4gICAgaWYgKGtleXN0b3JlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXlzdG9yZSA9IEpTT04ucGFyc2Uoa2V5c3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdChrZXlzdG9yZSB8fCBbXSwgcGFzc3dvcmQpO1xufTtcbmlmICghc3RvcmFnZUF2YWlsYWJsZSgnbG9jYWxTdG9yYWdlJykpIHtcbiAgICBkZWxldGUgV2FsbGV0LnByb3RvdHlwZS5zYXZlO1xuICAgIGRlbGV0ZSBXYWxsZXQucHJvdG90eXBlLmxvYWQ7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgc3RvcmFnZSB0eXBlIGlzIGF2YWlsYWJsZSBvciBub3RcbiAqIEZvciBtb3JlIGluZm8gb24gaG93IHRoaXMgd29ya3MsIHBsZWFzZSByZWZlciB0byBNRE4gZG9jdW1lbnRhdGlvblxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9TdG9yYWdlX0FQSS9Vc2luZ190aGVfV2ViX1N0b3JhZ2VfQVBJI0ZlYXR1cmUtZGV0ZWN0aW5nX2xvY2FsU3RvcmFnZVxuICpcbiAqIEBtZXRob2Qgc3RvcmFnZUF2YWlsYWJsZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2Ygc3RvcmFnZSAoJ2xvY2FsU3RvcmFnZScsICdzZXNzaW9uU3RvcmFnZScpXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIHN0b3JhZ2UgaXMgYXZhaWxhYmxlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHtcbiAgICB2YXIgc3RvcmFnZTtcbiAgICB0cnkge1xuICAgICAgICBzdG9yYWdlID0gd2luZG93W3R5cGVdO1xuICAgICAgICB2YXIgeCA9ICdfX3N0b3JhZ2VfdGVzdF9fJztcbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZSAmJiAoXG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IEZpcmVmb3hcbiAgICAgICAgZS5jb2RlID09PSAyMiB8fFxuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgZS5jb2RlID09PSAxMDE0IHx8XG4gICAgICAgICAgICAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IEZpcmVmb3hcbiAgICAgICAgICAgIGUubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicgfHxcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGUubmFtZSA9PT0gJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJykgJiZcbiAgICAgICAgICAgIC8vIGFja25vd2xlZGdlIFF1b3RhRXhjZWVkZWRFcnJvciBvbmx5IGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGFscmVhZHkgc3RvcmVkXG4gICAgICAgICAgICAoc3RvcmFnZSAmJiBzdG9yYWdlLmxlbmd0aCAhPT0gMCk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBBY2NvdW50cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/account.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/account.js ***!
  \****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")[\"Buffer\"];\nconst Bytes = __webpack_require__(/*! ./bytes */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/bytes.js\");\nconst Nat = __webpack_require__(/*! ./nat */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/nat.js\");\nconst elliptic = __webpack_require__(/*! elliptic */ \"../../node_modules/elliptic/lib/elliptic.js\");\nconst rlp = __webpack_require__(/*! ./rlp */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/rlp.js\");\nconst secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\nconst { keccak256, keccak256s } = __webpack_require__(/*! ./hash */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/hash.js\");\n\nconst create = entropy => {\n  const innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  const middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  const outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\n\nconst toChecksum = address => {\n  const addressHash = keccak256s(address.slice(2));\n  let checksumAddress = \"0x\";\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  return checksumAddress;\n};\n\nconst fromPrivate = privateKey => {\n  const buffer = new Buffer(privateKey.slice(2), \"hex\");\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  const publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\n\nconst encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v]);\n\nconst decodeSignature = hex => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), { canonical: true });\n  return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n};\n\nconst sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nconst recover = (hash, signature) => {\n  const vals = decodeSignature(signature);\n  const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n  const ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n  const publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\n\nmodule.exports = {\n  create,\n  toChecksum,\n  fromPrivate,\n  sign,\n  makeSigner,\n  recover,\n  encodeSignature,\n  decodeSignature\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL2FjY291bnQuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLGNBQWMsbUJBQU8sQ0FBQyx1SEFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsbUhBQU87QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVU7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLG1IQUFPO0FBQzNCLGdEQUFnRDtBQUNoRCxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMscUhBQVE7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaURBQWlELE1BQU0sdUNBQXVDLE1BQU0sMEJBQTBCLGlCQUFpQjtBQUMvSTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrREFBa0QsTUFBTSxpRUFBaUU7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL2FjY291bnQuanM/YWUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBCeXRlcyA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgTmF0ID0gcmVxdWlyZShcIi4vbmF0XCIpO1xuY29uc3QgZWxsaXB0aWMgPSByZXF1aXJlKFwiZWxsaXB0aWNcIik7XG5jb25zdCBybHAgPSByZXF1aXJlKFwiLi9ybHBcIik7XG5jb25zdCBzZWNwMjU2azEgPSBuZXcgZWxsaXB0aWMuZWMoXCJzZWNwMjU2azFcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmNvbnN0IHsga2VjY2FrMjU2LCBrZWNjYWsyNTZzIH0gPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuXG5jb25zdCBjcmVhdGUgPSBlbnRyb3B5ID0+IHtcbiAgY29uc3QgaW5uZXJIZXggPSBrZWNjYWsyNTYoQnl0ZXMuY29uY2F0KEJ5dGVzLnJhbmRvbSgzMiksIGVudHJvcHkgfHwgQnl0ZXMucmFuZG9tKDMyKSkpO1xuICBjb25zdCBtaWRkbGVIZXggPSBCeXRlcy5jb25jYXQoQnl0ZXMuY29uY2F0KEJ5dGVzLnJhbmRvbSgzMiksIGlubmVySGV4KSwgQnl0ZXMucmFuZG9tKDMyKSk7XG4gIGNvbnN0IG91dGVySGV4ID0ga2VjY2FrMjU2KG1pZGRsZUhleCk7XG4gIHJldHVybiBmcm9tUHJpdmF0ZShvdXRlckhleCk7XG59O1xuXG5jb25zdCB0b0NoZWNrc3VtID0gYWRkcmVzcyA9PiB7XG4gIGNvbnN0IGFkZHJlc3NIYXNoID0ga2VjY2FrMjU2cyhhZGRyZXNzLnNsaWNlKDIpKTtcbiAgbGV0IGNoZWNrc3VtQWRkcmVzcyA9IFwiMHhcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKSBjaGVja3N1bUFkZHJlc3MgKz0gcGFyc2VJbnQoYWRkcmVzc0hhc2hbaSArIDJdLCAxNikgPiA3ID8gYWRkcmVzc1tpICsgMl0udG9VcHBlckNhc2UoKSA6IGFkZHJlc3NbaSArIDJdO1xuICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzO1xufTtcblxuY29uc3QgZnJvbVByaXZhdGUgPSBwcml2YXRlS2V5ID0+IHtcbiAgY29uc3QgYnVmZmVyID0gbmV3IEJ1ZmZlcihwcml2YXRlS2V5LnNsaWNlKDIpLCBcImhleFwiKTtcbiAgY29uc3QgZWNLZXkgPSBzZWNwMjU2azEua2V5RnJvbVByaXZhdGUoYnVmZmVyKTtcbiAgY29uc3QgcHVibGljS2V5ID0gXCIweFwiICsgZWNLZXkuZ2V0UHVibGljKGZhbHNlLCAnaGV4Jykuc2xpY2UoMik7XG4gIGNvbnN0IHB1YmxpY0hhc2ggPSBrZWNjYWsyNTYocHVibGljS2V5KTtcbiAgY29uc3QgYWRkcmVzcyA9IHRvQ2hlY2tzdW0oXCIweFwiICsgcHVibGljSGFzaC5zbGljZSgtNDApKTtcbiAgcmV0dXJuIHtcbiAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlcbiAgfTtcbn07XG5cbmNvbnN0IGVuY29kZVNpZ25hdHVyZSA9IChbdiwgciwgc10pID0+IEJ5dGVzLmZsYXR0ZW4oW3IsIHMsIHZdKTtcblxuY29uc3QgZGVjb2RlU2lnbmF0dXJlID0gaGV4ID0+IFtCeXRlcy5zbGljZSg2NCwgQnl0ZXMubGVuZ3RoKGhleCksIGhleCksIEJ5dGVzLnNsaWNlKDAsIDMyLCBoZXgpLCBCeXRlcy5zbGljZSgzMiwgNjQsIGhleCldO1xuXG5jb25zdCBtYWtlU2lnbmVyID0gYWRkVG9WID0+IChoYXNoLCBwcml2YXRlS2V5KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5rZXlGcm9tUHJpdmF0ZShuZXcgQnVmZmVyKHByaXZhdGVLZXkuc2xpY2UoMiksIFwiaGV4XCIpKS5zaWduKG5ldyBCdWZmZXIoaGFzaC5zbGljZSgyKSwgXCJoZXhcIiksIHsgY2Fub25pY2FsOiB0cnVlIH0pO1xuICByZXR1cm4gZW5jb2RlU2lnbmF0dXJlKFtOYXQuZnJvbVN0cmluZyhCeXRlcy5mcm9tTnVtYmVyKGFkZFRvViArIHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtKSksIEJ5dGVzLnBhZCgzMiwgQnl0ZXMuZnJvbU5hdChcIjB4XCIgKyBzaWduYXR1cmUuci50b1N0cmluZygxNikpKSwgQnl0ZXMucGFkKDMyLCBCeXRlcy5mcm9tTmF0KFwiMHhcIiArIHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSkpXSk7XG59O1xuXG5jb25zdCBzaWduID0gbWFrZVNpZ25lcigyNyk7IC8vIHY9Mjd8MjggaW5zdGVhZCBvZiAwfDEuLi5cblxuY29uc3QgcmVjb3ZlciA9IChoYXNoLCBzaWduYXR1cmUpID0+IHtcbiAgY29uc3QgdmFscyA9IGRlY29kZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICBjb25zdCB2cnMgPSB7IHY6IEJ5dGVzLnRvTnVtYmVyKHZhbHNbMF0pLCByOiB2YWxzWzFdLnNsaWNlKDIpLCBzOiB2YWxzWzJdLnNsaWNlKDIpIH07XG4gIGNvbnN0IGVjUHVibGljS2V5ID0gc2VjcDI1NmsxLnJlY292ZXJQdWJLZXkobmV3IEJ1ZmZlcihoYXNoLnNsaWNlKDIpLCBcImhleFwiKSwgdnJzLCB2cnMudiA8IDIgPyB2cnMudiA6IDEgLSB2cnMudiAlIDIpOyAvLyBiZWNhdXNlIG9kZCB2YWxzIG1lYW4gdj0wLi4uIHNhZGx5IHRoYXQgbWVhbnMgdj0wIG1lYW5zIHY9MS4uLiBJIGhhdGUgdGhhdFxuICBjb25zdCBwdWJsaWNLZXkgPSBcIjB4XCIgKyBlY1B1YmxpY0tleS5lbmNvZGUoXCJoZXhcIiwgZmFsc2UpLnNsaWNlKDIpO1xuICBjb25zdCBwdWJsaWNIYXNoID0ga2VjY2FrMjU2KHB1YmxpY0tleSk7XG4gIGNvbnN0IGFkZHJlc3MgPSB0b0NoZWNrc3VtKFwiMHhcIiArIHB1YmxpY0hhc2guc2xpY2UoLTQwKSk7XG4gIHJldHVybiBhZGRyZXNzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZSxcbiAgdG9DaGVja3N1bSxcbiAgZnJvbVByaXZhdGUsXG4gIHNpZ24sXG4gIG1ha2VTaWduZXIsXG4gIHJlY292ZXIsXG4gIGVuY29kZVNpZ25hdHVyZSxcbiAgZGVjb2RlU2lnbmF0dXJlXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/account.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/array.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/array.js ***!
  \**************************************************************************************************************/
/***/ (function(module) {

eval("const generate = (num, fn) => {\n  let a = [];\n  for (var i = 0; i < num; ++i) a.push(fn(i));\n  return a;\n};\n\nconst replicate = (num, val) => generate(num, () => val);\n\nconst concat = (a, b) => a.concat(b);\n\nconst flatten = a => {\n  let r = [];\n  for (let j = 0, J = a.length; j < J; ++j) for (let i = 0, I = a[j].length; i < I; ++i) r.push(a[j][i]);\n  return r;\n};\n\nconst chunksOf = (n, a) => {\n  let b = [];\n  for (let i = 0, l = a.length; i < l; i += n) b.push(a.slice(i, i + n));\n  return b;\n};\n\nmodule.exports = {\n  generate,\n  replicate,\n  concat,\n  flatten,\n  chunksOf\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL2FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTyxzQ0FBc0MsT0FBTztBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1hY2NvdW50cy9ub2RlX21vZHVsZXMvZXRoLWxpYi9saWIvYXJyYXkuanM/NDI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBnZW5lcmF0ZSA9IChudW0sIGZuKSA9PiB7XG4gIGxldCBhID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpIGEucHVzaChmbihpKSk7XG4gIHJldHVybiBhO1xufTtcblxuY29uc3QgcmVwbGljYXRlID0gKG51bSwgdmFsKSA9PiBnZW5lcmF0ZShudW0sICgpID0+IHZhbCk7XG5cbmNvbnN0IGNvbmNhdCA9IChhLCBiKSA9PiBhLmNvbmNhdChiKTtcblxuY29uc3QgZmxhdHRlbiA9IGEgPT4ge1xuICBsZXQgciA9IFtdO1xuICBmb3IgKGxldCBqID0gMCwgSiA9IGEubGVuZ3RoOyBqIDwgSjsgKytqKSBmb3IgKGxldCBpID0gMCwgSSA9IGFbal0ubGVuZ3RoOyBpIDwgSTsgKytpKSByLnB1c2goYVtqXVtpXSk7XG4gIHJldHVybiByO1xufTtcblxuY29uc3QgY2h1bmtzT2YgPSAobiwgYSkgPT4ge1xuICBsZXQgYiA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSArPSBuKSBiLnB1c2goYS5zbGljZShpLCBpICsgbikpO1xuICByZXR1cm4gYjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZW5lcmF0ZSxcbiAgcmVwbGljYXRlLFxuICBjb25jYXQsXG4gIGZsYXR0ZW4sXG4gIGNodW5rc09mXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/array.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/bytes.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/bytes.js ***!
  \**************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const A = __webpack_require__(/*! ./array.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/array.js\");\n\nconst at = (bytes, index) => parseInt(bytes.slice(index * 2 + 2, index * 2 + 4), 16);\n\nconst random = bytes => {\n  let rnd;\n  if (typeof window !== \"undefined\" && window.crypto && window.crypto.getRandomValues) rnd = window.crypto.getRandomValues(new Uint8Array(bytes));else if (true) rnd = (__webpack_require__(/*! crypto */ \"./node_modules/next/dist/compiled/crypto-browserify/index.js\").randomBytes)(bytes);else {}\n  let hex = \"0x\";\n  for (let i = 0; i < bytes; ++i) hex += (\"00\" + rnd[i].toString(16)).slice(-2);\n  return hex;\n};\n\nconst length = a => (a.length - 2) / 2;\n\nconst flatten = a => \"0x\" + a.reduce((r, s) => r + s.slice(2), \"\");\n\nconst slice = (i, j, bs) => \"0x\" + bs.slice(i * 2 + 2, j * 2 + 2);\n\nconst reverse = hex => {\n  let rev = \"0x\";\n  for (let i = 0, l = length(hex); i < l; ++i) {\n    rev += hex.slice((l - i) * 2, (l - i + 1) * 2);\n  }\n  return rev;\n};\n\nconst pad = (l, hex) => hex.length === l * 2 + 2 ? hex : pad(l, \"0x\" + \"0\" + hex.slice(2));\n\nconst padRight = (l, hex) => hex.length === l * 2 + 2 ? hex : padRight(l, hex + \"0\");\n\nconst toArray = hex => {\n  let arr = [];\n  for (let i = 2, l = hex.length; i < l; i += 2) arr.push(parseInt(hex.slice(i, i + 2), 16));\n  return arr;\n};\n\nconst fromArray = arr => {\n  let hex = \"0x\";\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    let b = arr[i];\n    hex += (b < 16 ? \"0\" : \"\") + b.toString(16);\n  }\n  return hex;\n};\n\nconst toUint8Array = hex => new Uint8Array(toArray(hex));\n\nconst fromUint8Array = arr => fromArray([].slice.call(arr, 0));\n\nconst fromNumber = num => {\n  let hex = num.toString(16);\n  return hex.length % 2 === 0 ? \"0x\" + hex : \"0x0\" + hex;\n};\n\nconst toNumber = hex => parseInt(hex.slice(2), 16);\n\nconst concat = (a, b) => a.concat(b.slice(2));\n\nconst fromNat = bn => bn === \"0x0\" ? \"0x\" : bn.length % 2 === 0 ? bn : \"0x0\" + bn.slice(2);\n\nconst toNat = bn => bn[2] === \"0\" ? \"0x\" + bn.slice(3) : bn;\n\nconst fromAscii = ascii => {\n  let hex = \"0x\";\n  for (let i = 0; i < ascii.length; ++i) hex += (\"00\" + ascii.charCodeAt(i).toString(16)).slice(-2);\n  return hex;\n};\n\nconst toAscii = hex => {\n  let ascii = \"\";\n  for (let i = 2; i < hex.length; i += 2) ascii += String.fromCharCode(parseInt(hex.slice(i, i + 2), 16));\n  return ascii;\n};\n\n// From https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\nconst fromString = s => {\n  const makeByte = uint8 => {\n    const b = uint8.toString(16);\n    return b.length < 2 ? \"0\" + b : b;\n  };\n  let bytes = \"0x\";\n  for (let ci = 0; ci != s.length; ci++) {\n    let c = s.charCodeAt(ci);\n    if (c < 128) {\n      bytes += makeByte(c);\n      continue;\n    }\n    if (c < 2048) {\n      bytes += makeByte(c >> 6 | 192);\n    } else {\n      if (c > 0xd7ff && c < 0xdc00) {\n        if (++ci == s.length) return null;\n        let c2 = s.charCodeAt(ci);\n        if (c2 < 0xdc00 || c2 > 0xdfff) return null;\n        c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n        bytes += makeByte(c >> 18 | 240);\n        bytes += makeByte(c >> 12 & 63 | 128);\n      } else {\n        // c <= 0xffff\n        bytes += makeByte(c >> 12 | 224);\n      }\n      bytes += makeByte(c >> 6 & 63 | 128);\n    }\n    bytes += makeByte(c & 63 | 128);\n  }\n  return bytes;\n};\n\nconst toString = bytes => {\n  let s = '';\n  let i = 0;\n  let l = length(bytes);\n  while (i < l) {\n    let c = at(bytes, i++);\n    if (c > 127) {\n      if (c > 191 && c < 224) {\n        if (i >= l) return null;\n        c = (c & 31) << 6 | at(bytes, i) & 63;\n      } else if (c > 223 && c < 240) {\n        if (i + 1 >= l) return null;\n        c = (c & 15) << 12 | (at(bytes, i) & 63) << 6 | at(bytes, ++i) & 63;\n      } else if (c > 239 && c < 248) {\n        if (i + 2 >= l) return null;\n        c = (c & 7) << 18 | (at(bytes, i) & 63) << 12 | (at(bytes, ++i) & 63) << 6 | at(bytes, ++i) & 63;\n      } else return null;\n      ++i;\n    }\n    if (c <= 0xffff) s += String.fromCharCode(c);else if (c <= 0x10ffff) {\n      c -= 0x10000;\n      s += String.fromCharCode(c >> 10 | 0xd800);\n      s += String.fromCharCode(c & 0x3FF | 0xdc00);\n    } else return null;\n  }\n  return s;\n};\n\nmodule.exports = {\n  random,\n  length,\n  concat,\n  flatten,\n  slice,\n  reverse,\n  pad,\n  padRight,\n  fromAscii,\n  toAscii,\n  fromString,\n  toString,\n  fromNumber,\n  toNumber,\n  fromNat,\n  toNat,\n  fromArray,\n  toArray,\n  fromUint8Array,\n  toUint8Array\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL2J5dGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQywwSEFBWTs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBLGtKQUFrSixTQUFTLElBQThCLFFBQVEsK0dBQWtDLFFBQVEsS0FBSyxFQUEyQztBQUMzUjtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWFjY291bnRzL25vZGVfbW9kdWxlcy9ldGgtbGliL2xpYi9ieXRlcy5qcz85YjI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEEgPSByZXF1aXJlKFwiLi9hcnJheS5qc1wiKTtcblxuY29uc3QgYXQgPSAoYnl0ZXMsIGluZGV4KSA9PiBwYXJzZUludChieXRlcy5zbGljZShpbmRleCAqIDIgKyAyLCBpbmRleCAqIDIgKyA0KSwgMTYpO1xuXG5jb25zdCByYW5kb20gPSBieXRlcyA9PiB7XG4gIGxldCBybmQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHJuZCA9IHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7ZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHJuZCA9IHJlcXVpcmUoXCJjXCIgKyBcInJ5cHRvXCIpLnJhbmRvbUJ5dGVzKGJ5dGVzKTtlbHNlIHRocm93IFwiU2FmZSByYW5kb20gbnVtYmVycyBub3QgYXZhaWxhYmxlLlwiO1xuICBsZXQgaGV4ID0gXCIweFwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzOyArK2kpIGhleCArPSAoXCIwMFwiICsgcm5kW2ldLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICByZXR1cm4gaGV4O1xufTtcblxuY29uc3QgbGVuZ3RoID0gYSA9PiAoYS5sZW5ndGggLSAyKSAvIDI7XG5cbmNvbnN0IGZsYXR0ZW4gPSBhID0+IFwiMHhcIiArIGEucmVkdWNlKChyLCBzKSA9PiByICsgcy5zbGljZSgyKSwgXCJcIik7XG5cbmNvbnN0IHNsaWNlID0gKGksIGosIGJzKSA9PiBcIjB4XCIgKyBicy5zbGljZShpICogMiArIDIsIGogKiAyICsgMik7XG5cbmNvbnN0IHJldmVyc2UgPSBoZXggPT4ge1xuICBsZXQgcmV2ID0gXCIweFwiO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGxlbmd0aChoZXgpOyBpIDwgbDsgKytpKSB7XG4gICAgcmV2ICs9IGhleC5zbGljZSgobCAtIGkpICogMiwgKGwgLSBpICsgMSkgKiAyKTtcbiAgfVxuICByZXR1cm4gcmV2O1xufTtcblxuY29uc3QgcGFkID0gKGwsIGhleCkgPT4gaGV4Lmxlbmd0aCA9PT0gbCAqIDIgKyAyID8gaGV4IDogcGFkKGwsIFwiMHhcIiArIFwiMFwiICsgaGV4LnNsaWNlKDIpKTtcblxuY29uc3QgcGFkUmlnaHQgPSAobCwgaGV4KSA9PiBoZXgubGVuZ3RoID09PSBsICogMiArIDIgPyBoZXggOiBwYWRSaWdodChsLCBoZXggKyBcIjBcIik7XG5cbmNvbnN0IHRvQXJyYXkgPSBoZXggPT4ge1xuICBsZXQgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSAyLCBsID0gaGV4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMikgYXJyLnB1c2gocGFyc2VJbnQoaGV4LnNsaWNlKGksIGkgKyAyKSwgMTYpKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbmNvbnN0IGZyb21BcnJheSA9IGFyciA9PiB7XG4gIGxldCBoZXggPSBcIjB4XCI7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGxldCBiID0gYXJyW2ldO1xuICAgIGhleCArPSAoYiA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGIudG9TdHJpbmcoMTYpO1xuICB9XG4gIHJldHVybiBoZXg7XG59O1xuXG5jb25zdCB0b1VpbnQ4QXJyYXkgPSBoZXggPT4gbmV3IFVpbnQ4QXJyYXkodG9BcnJheShoZXgpKTtcblxuY29uc3QgZnJvbVVpbnQ4QXJyYXkgPSBhcnIgPT4gZnJvbUFycmF5KFtdLnNsaWNlLmNhbGwoYXJyLCAwKSk7XG5cbmNvbnN0IGZyb21OdW1iZXIgPSBudW0gPT4ge1xuICBsZXQgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggJSAyID09PSAwID8gXCIweFwiICsgaGV4IDogXCIweDBcIiArIGhleDtcbn07XG5cbmNvbnN0IHRvTnVtYmVyID0gaGV4ID0+IHBhcnNlSW50KGhleC5zbGljZSgyKSwgMTYpO1xuXG5jb25zdCBjb25jYXQgPSAoYSwgYikgPT4gYS5jb25jYXQoYi5zbGljZSgyKSk7XG5cbmNvbnN0IGZyb21OYXQgPSBibiA9PiBibiA9PT0gXCIweDBcIiA/IFwiMHhcIiA6IGJuLmxlbmd0aCAlIDIgPT09IDAgPyBibiA6IFwiMHgwXCIgKyBibi5zbGljZSgyKTtcblxuY29uc3QgdG9OYXQgPSBibiA9PiBiblsyXSA9PT0gXCIwXCIgPyBcIjB4XCIgKyBibi5zbGljZSgzKSA6IGJuO1xuXG5jb25zdCBmcm9tQXNjaWkgPSBhc2NpaSA9PiB7XG4gIGxldCBoZXggPSBcIjB4XCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXNjaWkubGVuZ3RoOyArK2kpIGhleCArPSAoXCIwMFwiICsgYXNjaWkuY2hhckNvZGVBdChpKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgcmV0dXJuIGhleDtcbn07XG5cbmNvbnN0IHRvQXNjaWkgPSBoZXggPT4ge1xuICBsZXQgYXNjaWkgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMjsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikgYXNjaWkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXguc2xpY2UoaSwgaSArIDIpLCAxNikpO1xuICByZXR1cm4gYXNjaWk7XG59O1xuXG4vLyBGcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3Bhc2NhbGRla2xvZS82MjU0NjEwM2ExNTc2ODAzZGFkZTkyNjljY2Y3NjMzMFxuY29uc3QgZnJvbVN0cmluZyA9IHMgPT4ge1xuICBjb25zdCBtYWtlQnl0ZSA9IHVpbnQ4ID0+IHtcbiAgICBjb25zdCBiID0gdWludDgudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBiLmxlbmd0aCA8IDIgPyBcIjBcIiArIGIgOiBiO1xuICB9O1xuICBsZXQgYnl0ZXMgPSBcIjB4XCI7XG4gIGZvciAobGV0IGNpID0gMDsgY2kgIT0gcy5sZW5ndGg7IGNpKyspIHtcbiAgICBsZXQgYyA9IHMuY2hhckNvZGVBdChjaSk7XG4gICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgIGJ5dGVzICs9IG1ha2VCeXRlKGMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjIDwgMjA0OCkge1xuICAgICAgYnl0ZXMgKz0gbWFrZUJ5dGUoYyA+PiA2IHwgMTkyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMgPiAweGQ3ZmYgJiYgYyA8IDB4ZGMwMCkge1xuICAgICAgICBpZiAoKytjaSA9PSBzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBjMiA9IHMuY2hhckNvZGVBdChjaSk7XG4gICAgICAgIGlmIChjMiA8IDB4ZGMwMCB8fCBjMiA+IDB4ZGZmZikgcmV0dXJuIG51bGw7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICBieXRlcyArPSBtYWtlQnl0ZShjID4+IDE4IHwgMjQwKTtcbiAgICAgICAgYnl0ZXMgKz0gbWFrZUJ5dGUoYyA+PiAxMiAmIDYzIHwgMTI4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGMgPD0gMHhmZmZmXG4gICAgICAgIGJ5dGVzICs9IG1ha2VCeXRlKGMgPj4gMTIgfCAyMjQpO1xuICAgICAgfVxuICAgICAgYnl0ZXMgKz0gbWFrZUJ5dGUoYyA+PiA2ICYgNjMgfCAxMjgpO1xuICAgIH1cbiAgICBieXRlcyArPSBtYWtlQnl0ZShjICYgNjMgfCAxMjgpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn07XG5cbmNvbnN0IHRvU3RyaW5nID0gYnl0ZXMgPT4ge1xuICBsZXQgcyA9ICcnO1xuICBsZXQgaSA9IDA7XG4gIGxldCBsID0gbGVuZ3RoKGJ5dGVzKTtcbiAgd2hpbGUgKGkgPCBsKSB7XG4gICAgbGV0IGMgPSBhdChieXRlcywgaSsrKTtcbiAgICBpZiAoYyA+IDEyNykge1xuICAgICAgaWYgKGMgPiAxOTEgJiYgYyA8IDIyNCkge1xuICAgICAgICBpZiAoaSA+PSBsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgYyA9IChjICYgMzEpIDw8IDYgfCBhdChieXRlcywgaSkgJiA2MztcbiAgICAgIH0gZWxzZSBpZiAoYyA+IDIyMyAmJiBjIDwgMjQwKSB7XG4gICAgICAgIGlmIChpICsgMSA+PSBsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgYyA9IChjICYgMTUpIDw8IDEyIHwgKGF0KGJ5dGVzLCBpKSAmIDYzKSA8PCA2IHwgYXQoYnl0ZXMsICsraSkgJiA2MztcbiAgICAgIH0gZWxzZSBpZiAoYyA+IDIzOSAmJiBjIDwgMjQ4KSB7XG4gICAgICAgIGlmIChpICsgMiA+PSBsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgYyA9IChjICYgNykgPDwgMTggfCAoYXQoYnl0ZXMsIGkpICYgNjMpIDw8IDEyIHwgKGF0KGJ5dGVzLCArK2kpICYgNjMpIDw8IDYgfCBhdChieXRlcywgKytpKSAmIDYzO1xuICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgKytpO1xuICAgIH1cbiAgICBpZiAoYyA8PSAweGZmZmYpIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtlbHNlIGlmIChjIDw9IDB4MTBmZmZmKSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyA+PiAxMCB8IDB4ZDgwMCk7XG4gICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyAmIDB4M0ZGIHwgMHhkYzAwKTtcbiAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmFuZG9tLFxuICBsZW5ndGgsXG4gIGNvbmNhdCxcbiAgZmxhdHRlbixcbiAgc2xpY2UsXG4gIHJldmVyc2UsXG4gIHBhZCxcbiAgcGFkUmlnaHQsXG4gIGZyb21Bc2NpaSxcbiAgdG9Bc2NpaSxcbiAgZnJvbVN0cmluZyxcbiAgdG9TdHJpbmcsXG4gIGZyb21OdW1iZXIsXG4gIHRvTnVtYmVyLFxuICBmcm9tTmF0LFxuICB0b05hdCxcbiAgZnJvbUFycmF5LFxuICB0b0FycmF5LFxuICBmcm9tVWludDhBcnJheSxcbiAgdG9VaW50OEFycmF5XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/bytes.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/hash.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/hash.js ***!
  \*************************************************************************************************************/
/***/ (function(module) {

eval("// This was ported from https://github.com/emn178/js-sha3, with some minor\n// modifications and pruning. It is licensed under MIT:\n//\n// Copyright 2015-2016 Chen, Yi-Cyuan\n//  \n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst HEX_CHARS = '0123456789abcdef'.split('');\nconst KECCAK_PADDING = [1, 256, 65536, 16777216];\nconst SHIFT = [0, 8, 16, 24];\nconst RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n\nconst Keccak = bits => ({\n  blocks: [],\n  reset: true,\n  block: 0,\n  start: 0,\n  blockCount: 1600 - (bits << 1) >> 5,\n  outputBlocks: bits >> 5,\n  s: (s => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n});\n\nconst update = (state, message) => {\n  var length = message.length,\n      blocks = state.blocks,\n      byteCount = state.blockCount << 2,\n      blockCount = state.blockCount,\n      outputBlocks = state.outputBlocks,\n      s = state.s,\n      index = 0,\n      i,\n      code;\n\n  // update\n  while (index < length) {\n    if (state.reset) {\n      state.reset = false;\n      blocks[0] = state.block;\n      for (i = 1; i < blockCount + 1; ++i) {\n        blocks[i] = 0;\n      }\n    }\n    if (typeof message !== \"string\") {\n      for (i = state.start; index < length && i < byteCount; ++index) {\n        blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n      }\n    } else {\n      for (i = state.start; index < length && i < byteCount; ++index) {\n        code = message.charCodeAt(index);\n        if (code < 0x80) {\n          blocks[i >> 2] |= code << SHIFT[i++ & 3];\n        } else if (code < 0x800) {\n          blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];\n          blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n        } else if (code < 0xd800 || code >= 0xe000) {\n          blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];\n          blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n          blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n        } else {\n          code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);\n          blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];\n          blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];\n          blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n          blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n        }\n      }\n    }\n    state.lastByteIndex = i;\n    if (i >= byteCount) {\n      state.start = i - byteCount;\n      state.block = blocks[blockCount];\n      for (i = 0; i < blockCount; ++i) {\n        s[i] ^= blocks[i];\n      }\n      f(s);\n      state.reset = true;\n    } else {\n      state.start = i;\n    }\n  }\n\n  // finalize\n  i = state.lastByteIndex;\n  blocks[i >> 2] |= KECCAK_PADDING[i & 3];\n  if (state.lastByteIndex === byteCount) {\n    blocks[0] = blocks[blockCount];\n    for (i = 1; i < blockCount + 1; ++i) {\n      blocks[i] = 0;\n    }\n  }\n  blocks[blockCount - 1] |= 0x80000000;\n  for (i = 0; i < blockCount; ++i) {\n    s[i] ^= blocks[i];\n  }\n  f(s);\n\n  // toString\n  var hex = '',\n      i = 0,\n      j = 0,\n      block;\n  while (j < outputBlocks) {\n    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n      block = s[i];\n      hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];\n    }\n    if (j % blockCount === 0) {\n      f(s);\n      i = 0;\n    }\n  }\n  return \"0x\" + hex;\n};\n\nconst f = s => {\n  var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n\n  for (n = 0; n < 48; n += 2) {\n    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n\n    h = c8 ^ (c2 << 1 | c3 >>> 31);\n    l = c9 ^ (c3 << 1 | c2 >>> 31);\n    s[0] ^= h;\n    s[1] ^= l;\n    s[10] ^= h;\n    s[11] ^= l;\n    s[20] ^= h;\n    s[21] ^= l;\n    s[30] ^= h;\n    s[31] ^= l;\n    s[40] ^= h;\n    s[41] ^= l;\n    h = c0 ^ (c4 << 1 | c5 >>> 31);\n    l = c1 ^ (c5 << 1 | c4 >>> 31);\n    s[2] ^= h;\n    s[3] ^= l;\n    s[12] ^= h;\n    s[13] ^= l;\n    s[22] ^= h;\n    s[23] ^= l;\n    s[32] ^= h;\n    s[33] ^= l;\n    s[42] ^= h;\n    s[43] ^= l;\n    h = c2 ^ (c6 << 1 | c7 >>> 31);\n    l = c3 ^ (c7 << 1 | c6 >>> 31);\n    s[4] ^= h;\n    s[5] ^= l;\n    s[14] ^= h;\n    s[15] ^= l;\n    s[24] ^= h;\n    s[25] ^= l;\n    s[34] ^= h;\n    s[35] ^= l;\n    s[44] ^= h;\n    s[45] ^= l;\n    h = c4 ^ (c8 << 1 | c9 >>> 31);\n    l = c5 ^ (c9 << 1 | c8 >>> 31);\n    s[6] ^= h;\n    s[7] ^= l;\n    s[16] ^= h;\n    s[17] ^= l;\n    s[26] ^= h;\n    s[27] ^= l;\n    s[36] ^= h;\n    s[37] ^= l;\n    s[46] ^= h;\n    s[47] ^= l;\n    h = c6 ^ (c0 << 1 | c1 >>> 31);\n    l = c7 ^ (c1 << 1 | c0 >>> 31);\n    s[8] ^= h;\n    s[9] ^= l;\n    s[18] ^= h;\n    s[19] ^= l;\n    s[28] ^= h;\n    s[29] ^= l;\n    s[38] ^= h;\n    s[39] ^= l;\n    s[48] ^= h;\n    s[49] ^= l;\n\n    b0 = s[0];\n    b1 = s[1];\n    b32 = s[11] << 4 | s[10] >>> 28;\n    b33 = s[10] << 4 | s[11] >>> 28;\n    b14 = s[20] << 3 | s[21] >>> 29;\n    b15 = s[21] << 3 | s[20] >>> 29;\n    b46 = s[31] << 9 | s[30] >>> 23;\n    b47 = s[30] << 9 | s[31] >>> 23;\n    b28 = s[40] << 18 | s[41] >>> 14;\n    b29 = s[41] << 18 | s[40] >>> 14;\n    b20 = s[2] << 1 | s[3] >>> 31;\n    b21 = s[3] << 1 | s[2] >>> 31;\n    b2 = s[13] << 12 | s[12] >>> 20;\n    b3 = s[12] << 12 | s[13] >>> 20;\n    b34 = s[22] << 10 | s[23] >>> 22;\n    b35 = s[23] << 10 | s[22] >>> 22;\n    b16 = s[33] << 13 | s[32] >>> 19;\n    b17 = s[32] << 13 | s[33] >>> 19;\n    b48 = s[42] << 2 | s[43] >>> 30;\n    b49 = s[43] << 2 | s[42] >>> 30;\n    b40 = s[5] << 30 | s[4] >>> 2;\n    b41 = s[4] << 30 | s[5] >>> 2;\n    b22 = s[14] << 6 | s[15] >>> 26;\n    b23 = s[15] << 6 | s[14] >>> 26;\n    b4 = s[25] << 11 | s[24] >>> 21;\n    b5 = s[24] << 11 | s[25] >>> 21;\n    b36 = s[34] << 15 | s[35] >>> 17;\n    b37 = s[35] << 15 | s[34] >>> 17;\n    b18 = s[45] << 29 | s[44] >>> 3;\n    b19 = s[44] << 29 | s[45] >>> 3;\n    b10 = s[6] << 28 | s[7] >>> 4;\n    b11 = s[7] << 28 | s[6] >>> 4;\n    b42 = s[17] << 23 | s[16] >>> 9;\n    b43 = s[16] << 23 | s[17] >>> 9;\n    b24 = s[26] << 25 | s[27] >>> 7;\n    b25 = s[27] << 25 | s[26] >>> 7;\n    b6 = s[36] << 21 | s[37] >>> 11;\n    b7 = s[37] << 21 | s[36] >>> 11;\n    b38 = s[47] << 24 | s[46] >>> 8;\n    b39 = s[46] << 24 | s[47] >>> 8;\n    b30 = s[8] << 27 | s[9] >>> 5;\n    b31 = s[9] << 27 | s[8] >>> 5;\n    b12 = s[18] << 20 | s[19] >>> 12;\n    b13 = s[19] << 20 | s[18] >>> 12;\n    b44 = s[29] << 7 | s[28] >>> 25;\n    b45 = s[28] << 7 | s[29] >>> 25;\n    b26 = s[38] << 8 | s[39] >>> 24;\n    b27 = s[39] << 8 | s[38] >>> 24;\n    b8 = s[48] << 14 | s[49] >>> 18;\n    b9 = s[49] << 14 | s[48] >>> 18;\n\n    s[0] = b0 ^ ~b2 & b4;\n    s[1] = b1 ^ ~b3 & b5;\n    s[10] = b10 ^ ~b12 & b14;\n    s[11] = b11 ^ ~b13 & b15;\n    s[20] = b20 ^ ~b22 & b24;\n    s[21] = b21 ^ ~b23 & b25;\n    s[30] = b30 ^ ~b32 & b34;\n    s[31] = b31 ^ ~b33 & b35;\n    s[40] = b40 ^ ~b42 & b44;\n    s[41] = b41 ^ ~b43 & b45;\n    s[2] = b2 ^ ~b4 & b6;\n    s[3] = b3 ^ ~b5 & b7;\n    s[12] = b12 ^ ~b14 & b16;\n    s[13] = b13 ^ ~b15 & b17;\n    s[22] = b22 ^ ~b24 & b26;\n    s[23] = b23 ^ ~b25 & b27;\n    s[32] = b32 ^ ~b34 & b36;\n    s[33] = b33 ^ ~b35 & b37;\n    s[42] = b42 ^ ~b44 & b46;\n    s[43] = b43 ^ ~b45 & b47;\n    s[4] = b4 ^ ~b6 & b8;\n    s[5] = b5 ^ ~b7 & b9;\n    s[14] = b14 ^ ~b16 & b18;\n    s[15] = b15 ^ ~b17 & b19;\n    s[24] = b24 ^ ~b26 & b28;\n    s[25] = b25 ^ ~b27 & b29;\n    s[34] = b34 ^ ~b36 & b38;\n    s[35] = b35 ^ ~b37 & b39;\n    s[44] = b44 ^ ~b46 & b48;\n    s[45] = b45 ^ ~b47 & b49;\n    s[6] = b6 ^ ~b8 & b0;\n    s[7] = b7 ^ ~b9 & b1;\n    s[16] = b16 ^ ~b18 & b10;\n    s[17] = b17 ^ ~b19 & b11;\n    s[26] = b26 ^ ~b28 & b20;\n    s[27] = b27 ^ ~b29 & b21;\n    s[36] = b36 ^ ~b38 & b30;\n    s[37] = b37 ^ ~b39 & b31;\n    s[46] = b46 ^ ~b48 & b40;\n    s[47] = b47 ^ ~b49 & b41;\n    s[8] = b8 ^ ~b0 & b2;\n    s[9] = b9 ^ ~b1 & b3;\n    s[18] = b18 ^ ~b10 & b12;\n    s[19] = b19 ^ ~b11 & b13;\n    s[28] = b28 ^ ~b20 & b22;\n    s[29] = b29 ^ ~b21 & b23;\n    s[38] = b38 ^ ~b30 & b32;\n    s[39] = b39 ^ ~b31 & b33;\n    s[48] = b48 ^ ~b40 & b42;\n    s[49] = b49 ^ ~b41 & b43;\n\n    s[0] ^= RC[n];\n    s[1] ^= RC[n + 1];\n  }\n};\n\nconst keccak = bits => str => {\n  var msg;\n  if (str.slice(0, 2) === \"0x\") {\n    msg = [];\n    for (var i = 2, l = str.length; i < l; i += 2) msg.push(parseInt(str.slice(i, i + 2), 16));\n  } else {\n    msg = str;\n  }\n  return update(Keccak(bits, bits), msg);\n};\n\nmodule.exports = {\n  keccak256: keccak(256),\n  keccak512: keccak(512),\n  keccak256s: keccak(256),\n  keccak512s: keccak(512)\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL2hhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1hY2NvdW50cy9ub2RlX21vZHVsZXMvZXRoLWxpYi9saWIvaGFzaC5qcz8yMjNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgd2FzIHBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhMywgd2l0aCBzb21lIG1pbm9yXG4vLyBtb2RpZmljYXRpb25zIGFuZCBwcnVuaW5nLiBJdCBpcyBsaWNlbnNlZCB1bmRlciBNSVQ6XG4vL1xuLy8gQ29weXJpZ2h0IDIwMTUtMjAxNiBDaGVuLCBZaS1DeXVhblxuLy8gIFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4vLyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbi8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuLy8gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuLy8gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuY29uc3QgSEVYX0NIQVJTID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKTtcbmNvbnN0IEtFQ0NBS19QQURESU5HID0gWzEsIDI1NiwgNjU1MzYsIDE2Nzc3MjE2XTtcbmNvbnN0IFNISUZUID0gWzAsIDgsIDE2LCAyNF07XG5jb25zdCBSQyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsIDIxNDc0ODM2NTgsIDAsIDIxNDc1MTY1NTUsIDAsIDEzOSwgMjE0NzQ4MzY0OCwgMzI5MDUsIDIxNDc0ODM2NDgsIDMyNzcxLCAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xuXG5jb25zdCBLZWNjYWsgPSBiaXRzID0+ICh7XG4gIGJsb2NrczogW10sXG4gIHJlc2V0OiB0cnVlLFxuICBibG9jazogMCxcbiAgc3RhcnQ6IDAsXG4gIGJsb2NrQ291bnQ6IDE2MDAgLSAoYml0cyA8PCAxKSA+PiA1LFxuICBvdXRwdXRCbG9ja3M6IGJpdHMgPj4gNSxcbiAgczogKHMgPT4gW10uY29uY2F0KHMsIHMsIHMsIHMsIHMpKShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pXG59KTtcblxuY29uc3QgdXBkYXRlID0gKHN0YXRlLCBtZXNzYWdlKSA9PiB7XG4gIHZhciBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIGJsb2NrcyA9IHN0YXRlLmJsb2NrcyxcbiAgICAgIGJ5dGVDb3VudCA9IHN0YXRlLmJsb2NrQ291bnQgPDwgMixcbiAgICAgIGJsb2NrQ291bnQgPSBzdGF0ZS5ibG9ja0NvdW50LFxuICAgICAgb3V0cHV0QmxvY2tzID0gc3RhdGUub3V0cHV0QmxvY2tzLFxuICAgICAgcyA9IHN0YXRlLnMsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpLFxuICAgICAgY29kZTtcblxuICAvLyB1cGRhdGVcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHN0YXRlLnJlc2V0KSB7XG4gICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgYmxvY2tzWzBdID0gc3RhdGUuYmxvY2s7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvciAoaSA9IHN0YXRlLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XG4gICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSBzdGF0ZS5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICBjb2RlID0gbWVzc2FnZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IGNvZGUgPj4gNikgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCBjb2RlICYgMHgzZikgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgY29kZSA+PiAxMikgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCBjb2RlID4+IDYgJiAweDNmKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IGNvZGUgJiAweDNmKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoY29kZSAmIDB4M2ZmKSA8PCAxMCB8IG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKTtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IGNvZGUgPj4gMTgpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgY29kZSA+PiAxMiAmIDB4M2YpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgY29kZSA+PiA2ICYgMHgzZikgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCBjb2RlICYgMHgzZikgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XG4gICAgICBzdGF0ZS5zdGFydCA9IGkgLSBieXRlQ291bnQ7XG4gICAgICBzdGF0ZS5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgICB9XG4gICAgICBmKHMpO1xuICAgICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5zdGFydCA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gZmluYWxpemVcbiAgaSA9IHN0YXRlLmxhc3RCeXRlSW5kZXg7XG4gIGJsb2Nrc1tpID4+IDJdIHw9IEtFQ0NBS19QQURESU5HW2kgJiAzXTtcbiAgaWYgKHN0YXRlLmxhc3RCeXRlSW5kZXggPT09IGJ5dGVDb3VudCkge1xuICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgYmxvY2tzW2ldID0gMDtcbiAgICB9XG4gIH1cbiAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xuICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgc1tpXSBePSBibG9ja3NbaV07XG4gIH1cbiAgZihzKTtcblxuICAvLyB0b1N0cmluZ1xuICB2YXIgaGV4ID0gJycsXG4gICAgICBpID0gMCxcbiAgICAgIGogPSAwLFxuICAgICAgYmxvY2s7XG4gIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbYmxvY2sgPj4gNCAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgPj4gMTIgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayA+PiA4ICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgPj4gMjAgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayA+PiAxNiAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrID4+IDI4ICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgPj4gMjQgJiAweDBGXTtcbiAgICB9XG4gICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICBmKHMpO1xuICAgICAgaSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuXG5jb25zdCBmID0gcyA9PiB7XG4gIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSwgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjYsIGI3LCBiOCwgYjksIGIxMCwgYjExLCBiMTIsIGIxMywgYjE0LCBiMTUsIGIxNiwgYjE3LCBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcblxuICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikge1xuICAgIGMwID0gc1swXSBeIHNbMTBdIF4gc1syMF0gXiBzWzMwXSBeIHNbNDBdO1xuICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xuICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xuICAgIGMzID0gc1szXSBeIHNbMTNdIF4gc1syM10gXiBzWzMzXSBeIHNbNDNdO1xuICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xuICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xuICAgIGM2ID0gc1s2XSBeIHNbMTZdIF4gc1syNl0gXiBzWzM2XSBeIHNbNDZdO1xuICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xuICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xuICAgIGM5ID0gc1s5XSBeIHNbMTldIF4gc1syOV0gXiBzWzM5XSBeIHNbNDldO1xuXG4gICAgaCA9IGM4IF4gKGMyIDw8IDEgfCBjMyA+Pj4gMzEpO1xuICAgIGwgPSBjOSBeIChjMyA8PCAxIHwgYzIgPj4+IDMxKTtcbiAgICBzWzBdIF49IGg7XG4gICAgc1sxXSBePSBsO1xuICAgIHNbMTBdIF49IGg7XG4gICAgc1sxMV0gXj0gbDtcbiAgICBzWzIwXSBePSBoO1xuICAgIHNbMjFdIF49IGw7XG4gICAgc1szMF0gXj0gaDtcbiAgICBzWzMxXSBePSBsO1xuICAgIHNbNDBdIF49IGg7XG4gICAgc1s0MV0gXj0gbDtcbiAgICBoID0gYzAgXiAoYzQgPDwgMSB8IGM1ID4+PiAzMSk7XG4gICAgbCA9IGMxIF4gKGM1IDw8IDEgfCBjNCA+Pj4gMzEpO1xuICAgIHNbMl0gXj0gaDtcbiAgICBzWzNdIF49IGw7XG4gICAgc1sxMl0gXj0gaDtcbiAgICBzWzEzXSBePSBsO1xuICAgIHNbMjJdIF49IGg7XG4gICAgc1syM10gXj0gbDtcbiAgICBzWzMyXSBePSBoO1xuICAgIHNbMzNdIF49IGw7XG4gICAgc1s0Ml0gXj0gaDtcbiAgICBzWzQzXSBePSBsO1xuICAgIGggPSBjMiBeIChjNiA8PCAxIHwgYzcgPj4+IDMxKTtcbiAgICBsID0gYzMgXiAoYzcgPDwgMSB8IGM2ID4+PiAzMSk7XG4gICAgc1s0XSBePSBoO1xuICAgIHNbNV0gXj0gbDtcbiAgICBzWzE0XSBePSBoO1xuICAgIHNbMTVdIF49IGw7XG4gICAgc1syNF0gXj0gaDtcbiAgICBzWzI1XSBePSBsO1xuICAgIHNbMzRdIF49IGg7XG4gICAgc1szNV0gXj0gbDtcbiAgICBzWzQ0XSBePSBoO1xuICAgIHNbNDVdIF49IGw7XG4gICAgaCA9IGM0IF4gKGM4IDw8IDEgfCBjOSA+Pj4gMzEpO1xuICAgIGwgPSBjNSBeIChjOSA8PCAxIHwgYzggPj4+IDMxKTtcbiAgICBzWzZdIF49IGg7XG4gICAgc1s3XSBePSBsO1xuICAgIHNbMTZdIF49IGg7XG4gICAgc1sxN10gXj0gbDtcbiAgICBzWzI2XSBePSBoO1xuICAgIHNbMjddIF49IGw7XG4gICAgc1szNl0gXj0gaDtcbiAgICBzWzM3XSBePSBsO1xuICAgIHNbNDZdIF49IGg7XG4gICAgc1s0N10gXj0gbDtcbiAgICBoID0gYzYgXiAoYzAgPDwgMSB8IGMxID4+PiAzMSk7XG4gICAgbCA9IGM3IF4gKGMxIDw8IDEgfCBjMCA+Pj4gMzEpO1xuICAgIHNbOF0gXj0gaDtcbiAgICBzWzldIF49IGw7XG4gICAgc1sxOF0gXj0gaDtcbiAgICBzWzE5XSBePSBsO1xuICAgIHNbMjhdIF49IGg7XG4gICAgc1syOV0gXj0gbDtcbiAgICBzWzM4XSBePSBoO1xuICAgIHNbMzldIF49IGw7XG4gICAgc1s0OF0gXj0gaDtcbiAgICBzWzQ5XSBePSBsO1xuXG4gICAgYjAgPSBzWzBdO1xuICAgIGIxID0gc1sxXTtcbiAgICBiMzIgPSBzWzExXSA8PCA0IHwgc1sxMF0gPj4+IDI4O1xuICAgIGIzMyA9IHNbMTBdIDw8IDQgfCBzWzExXSA+Pj4gMjg7XG4gICAgYjE0ID0gc1syMF0gPDwgMyB8IHNbMjFdID4+PiAyOTtcbiAgICBiMTUgPSBzWzIxXSA8PCAzIHwgc1syMF0gPj4+IDI5O1xuICAgIGI0NiA9IHNbMzFdIDw8IDkgfCBzWzMwXSA+Pj4gMjM7XG4gICAgYjQ3ID0gc1szMF0gPDwgOSB8IHNbMzFdID4+PiAyMztcbiAgICBiMjggPSBzWzQwXSA8PCAxOCB8IHNbNDFdID4+PiAxNDtcbiAgICBiMjkgPSBzWzQxXSA8PCAxOCB8IHNbNDBdID4+PiAxNDtcbiAgICBiMjAgPSBzWzJdIDw8IDEgfCBzWzNdID4+PiAzMTtcbiAgICBiMjEgPSBzWzNdIDw8IDEgfCBzWzJdID4+PiAzMTtcbiAgICBiMiA9IHNbMTNdIDw8IDEyIHwgc1sxMl0gPj4+IDIwO1xuICAgIGIzID0gc1sxMl0gPDwgMTIgfCBzWzEzXSA+Pj4gMjA7XG4gICAgYjM0ID0gc1syMl0gPDwgMTAgfCBzWzIzXSA+Pj4gMjI7XG4gICAgYjM1ID0gc1syM10gPDwgMTAgfCBzWzIyXSA+Pj4gMjI7XG4gICAgYjE2ID0gc1szM10gPDwgMTMgfCBzWzMyXSA+Pj4gMTk7XG4gICAgYjE3ID0gc1szMl0gPDwgMTMgfCBzWzMzXSA+Pj4gMTk7XG4gICAgYjQ4ID0gc1s0Ml0gPDwgMiB8IHNbNDNdID4+PiAzMDtcbiAgICBiNDkgPSBzWzQzXSA8PCAyIHwgc1s0Ml0gPj4+IDMwO1xuICAgIGI0MCA9IHNbNV0gPDwgMzAgfCBzWzRdID4+PiAyO1xuICAgIGI0MSA9IHNbNF0gPDwgMzAgfCBzWzVdID4+PiAyO1xuICAgIGIyMiA9IHNbMTRdIDw8IDYgfCBzWzE1XSA+Pj4gMjY7XG4gICAgYjIzID0gc1sxNV0gPDwgNiB8IHNbMTRdID4+PiAyNjtcbiAgICBiNCA9IHNbMjVdIDw8IDExIHwgc1syNF0gPj4+IDIxO1xuICAgIGI1ID0gc1syNF0gPDwgMTEgfCBzWzI1XSA+Pj4gMjE7XG4gICAgYjM2ID0gc1szNF0gPDwgMTUgfCBzWzM1XSA+Pj4gMTc7XG4gICAgYjM3ID0gc1szNV0gPDwgMTUgfCBzWzM0XSA+Pj4gMTc7XG4gICAgYjE4ID0gc1s0NV0gPDwgMjkgfCBzWzQ0XSA+Pj4gMztcbiAgICBiMTkgPSBzWzQ0XSA8PCAyOSB8IHNbNDVdID4+PiAzO1xuICAgIGIxMCA9IHNbNl0gPDwgMjggfCBzWzddID4+PiA0O1xuICAgIGIxMSA9IHNbN10gPDwgMjggfCBzWzZdID4+PiA0O1xuICAgIGI0MiA9IHNbMTddIDw8IDIzIHwgc1sxNl0gPj4+IDk7XG4gICAgYjQzID0gc1sxNl0gPDwgMjMgfCBzWzE3XSA+Pj4gOTtcbiAgICBiMjQgPSBzWzI2XSA8PCAyNSB8IHNbMjddID4+PiA3O1xuICAgIGIyNSA9IHNbMjddIDw8IDI1IHwgc1syNl0gPj4+IDc7XG4gICAgYjYgPSBzWzM2XSA8PCAyMSB8IHNbMzddID4+PiAxMTtcbiAgICBiNyA9IHNbMzddIDw8IDIxIHwgc1szNl0gPj4+IDExO1xuICAgIGIzOCA9IHNbNDddIDw8IDI0IHwgc1s0Nl0gPj4+IDg7XG4gICAgYjM5ID0gc1s0Nl0gPDwgMjQgfCBzWzQ3XSA+Pj4gODtcbiAgICBiMzAgPSBzWzhdIDw8IDI3IHwgc1s5XSA+Pj4gNTtcbiAgICBiMzEgPSBzWzldIDw8IDI3IHwgc1s4XSA+Pj4gNTtcbiAgICBiMTIgPSBzWzE4XSA8PCAyMCB8IHNbMTldID4+PiAxMjtcbiAgICBiMTMgPSBzWzE5XSA8PCAyMCB8IHNbMThdID4+PiAxMjtcbiAgICBiNDQgPSBzWzI5XSA8PCA3IHwgc1syOF0gPj4+IDI1O1xuICAgIGI0NSA9IHNbMjhdIDw8IDcgfCBzWzI5XSA+Pj4gMjU7XG4gICAgYjI2ID0gc1szOF0gPDwgOCB8IHNbMzldID4+PiAyNDtcbiAgICBiMjcgPSBzWzM5XSA8PCA4IHwgc1szOF0gPj4+IDI0O1xuICAgIGI4ID0gc1s0OF0gPDwgMTQgfCBzWzQ5XSA+Pj4gMTg7XG4gICAgYjkgPSBzWzQ5XSA8PCAxNCB8IHNbNDhdID4+PiAxODtcblxuICAgIHNbMF0gPSBiMCBeIH5iMiAmIGI0O1xuICAgIHNbMV0gPSBiMSBeIH5iMyAmIGI1O1xuICAgIHNbMTBdID0gYjEwIF4gfmIxMiAmIGIxNDtcbiAgICBzWzExXSA9IGIxMSBeIH5iMTMgJiBiMTU7XG4gICAgc1syMF0gPSBiMjAgXiB+YjIyICYgYjI0O1xuICAgIHNbMjFdID0gYjIxIF4gfmIyMyAmIGIyNTtcbiAgICBzWzMwXSA9IGIzMCBeIH5iMzIgJiBiMzQ7XG4gICAgc1szMV0gPSBiMzEgXiB+YjMzICYgYjM1O1xuICAgIHNbNDBdID0gYjQwIF4gfmI0MiAmIGI0NDtcbiAgICBzWzQxXSA9IGI0MSBeIH5iNDMgJiBiNDU7XG4gICAgc1syXSA9IGIyIF4gfmI0ICYgYjY7XG4gICAgc1szXSA9IGIzIF4gfmI1ICYgYjc7XG4gICAgc1sxMl0gPSBiMTIgXiB+YjE0ICYgYjE2O1xuICAgIHNbMTNdID0gYjEzIF4gfmIxNSAmIGIxNztcbiAgICBzWzIyXSA9IGIyMiBeIH5iMjQgJiBiMjY7XG4gICAgc1syM10gPSBiMjMgXiB+YjI1ICYgYjI3O1xuICAgIHNbMzJdID0gYjMyIF4gfmIzNCAmIGIzNjtcbiAgICBzWzMzXSA9IGIzMyBeIH5iMzUgJiBiMzc7XG4gICAgc1s0Ml0gPSBiNDIgXiB+YjQ0ICYgYjQ2O1xuICAgIHNbNDNdID0gYjQzIF4gfmI0NSAmIGI0NztcbiAgICBzWzRdID0gYjQgXiB+YjYgJiBiODtcbiAgICBzWzVdID0gYjUgXiB+YjcgJiBiOTtcbiAgICBzWzE0XSA9IGIxNCBeIH5iMTYgJiBiMTg7XG4gICAgc1sxNV0gPSBiMTUgXiB+YjE3ICYgYjE5O1xuICAgIHNbMjRdID0gYjI0IF4gfmIyNiAmIGIyODtcbiAgICBzWzI1XSA9IGIyNSBeIH5iMjcgJiBiMjk7XG4gICAgc1szNF0gPSBiMzQgXiB+YjM2ICYgYjM4O1xuICAgIHNbMzVdID0gYjM1IF4gfmIzNyAmIGIzOTtcbiAgICBzWzQ0XSA9IGI0NCBeIH5iNDYgJiBiNDg7XG4gICAgc1s0NV0gPSBiNDUgXiB+YjQ3ICYgYjQ5O1xuICAgIHNbNl0gPSBiNiBeIH5iOCAmIGIwO1xuICAgIHNbN10gPSBiNyBeIH5iOSAmIGIxO1xuICAgIHNbMTZdID0gYjE2IF4gfmIxOCAmIGIxMDtcbiAgICBzWzE3XSA9IGIxNyBeIH5iMTkgJiBiMTE7XG4gICAgc1syNl0gPSBiMjYgXiB+YjI4ICYgYjIwO1xuICAgIHNbMjddID0gYjI3IF4gfmIyOSAmIGIyMTtcbiAgICBzWzM2XSA9IGIzNiBeIH5iMzggJiBiMzA7XG4gICAgc1szN10gPSBiMzcgXiB+YjM5ICYgYjMxO1xuICAgIHNbNDZdID0gYjQ2IF4gfmI0OCAmIGI0MDtcbiAgICBzWzQ3XSA9IGI0NyBeIH5iNDkgJiBiNDE7XG4gICAgc1s4XSA9IGI4IF4gfmIwICYgYjI7XG4gICAgc1s5XSA9IGI5IF4gfmIxICYgYjM7XG4gICAgc1sxOF0gPSBiMTggXiB+YjEwICYgYjEyO1xuICAgIHNbMTldID0gYjE5IF4gfmIxMSAmIGIxMztcbiAgICBzWzI4XSA9IGIyOCBeIH5iMjAgJiBiMjI7XG4gICAgc1syOV0gPSBiMjkgXiB+YjIxICYgYjIzO1xuICAgIHNbMzhdID0gYjM4IF4gfmIzMCAmIGIzMjtcbiAgICBzWzM5XSA9IGIzOSBeIH5iMzEgJiBiMzM7XG4gICAgc1s0OF0gPSBiNDggXiB+YjQwICYgYjQyO1xuICAgIHNbNDldID0gYjQ5IF4gfmI0MSAmIGI0MztcblxuICAgIHNbMF0gXj0gUkNbbl07XG4gICAgc1sxXSBePSBSQ1tuICsgMV07XG4gIH1cbn07XG5cbmNvbnN0IGtlY2NhayA9IGJpdHMgPT4gc3RyID0+IHtcbiAgdmFyIG1zZztcbiAgaWYgKHN0ci5zbGljZSgwLCAyKSA9PT0gXCIweFwiKSB7XG4gICAgbXNnID0gW107XG4gICAgZm9yICh2YXIgaSA9IDIsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSBtc2cucHVzaChwYXJzZUludChzdHIuc2xpY2UoaSwgaSArIDIpLCAxNikpO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IHN0cjtcbiAgfVxuICByZXR1cm4gdXBkYXRlKEtlY2NhayhiaXRzLCBiaXRzKSwgbXNnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZWNjYWsyNTY6IGtlY2NhaygyNTYpLFxuICBrZWNjYWs1MTI6IGtlY2Nhayg1MTIpLFxuICBrZWNjYWsyNTZzOiBrZWNjYWsoMjU2KSxcbiAga2VjY2FrNTEyczoga2VjY2FrKDUxMilcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/hash.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/nat.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/nat.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const BN = __webpack_require__(/*! bn.js */ \"../../node_modules/bn.js/lib/bn.js\");\nconst Bytes = __webpack_require__(/*! ./bytes */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/bytes.js\");\n\nconst fromBN = bn => \"0x\" + bn.toString(\"hex\");\n\nconst toBN = str => new BN(str.slice(2), 16);\n\nconst fromString = str => {\n  const bn = \"0x\" + (str.slice(0, 2) === \"0x\" ? new BN(str.slice(2), 16) : new BN(str, 10)).toString(\"hex\");\n  return bn === \"0x0\" ? \"0x\" : bn;\n};\n\nconst toEther = wei => toNumber(div(wei, fromString(\"10000000000\"))) / 100000000;\n\nconst fromEther = eth => mul(fromNumber(Math.floor(eth * 100000000)), fromString(\"10000000000\"));\n\nconst toString = a => toBN(a).toString(10);\n\nconst fromNumber = a => typeof a === \"string\" ? /^0x/.test(a) ? a : \"0x\" + a : \"0x\" + new BN(a).toString(\"hex\");\n\nconst toNumber = a => toBN(a).toNumber();\n\nconst toUint256 = a => Bytes.pad(32, a);\n\nconst bin = method => (a, b) => fromBN(toBN(a)[method](toBN(b)));\n\nconst add = bin(\"add\");\nconst mul = bin(\"mul\");\nconst div = bin(\"div\");\nconst sub = bin(\"sub\");\n\nmodule.exports = {\n  toString,\n  fromString,\n  toNumber,\n  fromNumber,\n  toEther,\n  fromEther,\n  toUint256,\n  add,\n  mul,\n  div,\n  sub\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL25hdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsaURBQU87QUFDMUIsY0FBYyxtQkFBTyxDQUFDLHVIQUFTOztBQUUvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL25hdC5qcz82NGUyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xuY29uc3QgQnl0ZXMgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcblxuY29uc3QgZnJvbUJOID0gYm4gPT4gXCIweFwiICsgYm4udG9TdHJpbmcoXCJoZXhcIik7XG5cbmNvbnN0IHRvQk4gPSBzdHIgPT4gbmV3IEJOKHN0ci5zbGljZSgyKSwgMTYpO1xuXG5jb25zdCBmcm9tU3RyaW5nID0gc3RyID0+IHtcbiAgY29uc3QgYm4gPSBcIjB4XCIgKyAoc3RyLnNsaWNlKDAsIDIpID09PSBcIjB4XCIgPyBuZXcgQk4oc3RyLnNsaWNlKDIpLCAxNikgOiBuZXcgQk4oc3RyLCAxMCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICByZXR1cm4gYm4gPT09IFwiMHgwXCIgPyBcIjB4XCIgOiBibjtcbn07XG5cbmNvbnN0IHRvRXRoZXIgPSB3ZWkgPT4gdG9OdW1iZXIoZGl2KHdlaSwgZnJvbVN0cmluZyhcIjEwMDAwMDAwMDAwXCIpKSkgLyAxMDAwMDAwMDA7XG5cbmNvbnN0IGZyb21FdGhlciA9IGV0aCA9PiBtdWwoZnJvbU51bWJlcihNYXRoLmZsb29yKGV0aCAqIDEwMDAwMDAwMCkpLCBmcm9tU3RyaW5nKFwiMTAwMDAwMDAwMDBcIikpO1xuXG5jb25zdCB0b1N0cmluZyA9IGEgPT4gdG9CTihhKS50b1N0cmluZygxMCk7XG5cbmNvbnN0IGZyb21OdW1iZXIgPSBhID0+IHR5cGVvZiBhID09PSBcInN0cmluZ1wiID8gL14weC8udGVzdChhKSA/IGEgOiBcIjB4XCIgKyBhIDogXCIweFwiICsgbmV3IEJOKGEpLnRvU3RyaW5nKFwiaGV4XCIpO1xuXG5jb25zdCB0b051bWJlciA9IGEgPT4gdG9CTihhKS50b051bWJlcigpO1xuXG5jb25zdCB0b1VpbnQyNTYgPSBhID0+IEJ5dGVzLnBhZCgzMiwgYSk7XG5cbmNvbnN0IGJpbiA9IG1ldGhvZCA9PiAoYSwgYikgPT4gZnJvbUJOKHRvQk4oYSlbbWV0aG9kXSh0b0JOKGIpKSk7XG5cbmNvbnN0IGFkZCA9IGJpbihcImFkZFwiKTtcbmNvbnN0IG11bCA9IGJpbihcIm11bFwiKTtcbmNvbnN0IGRpdiA9IGJpbihcImRpdlwiKTtcbmNvbnN0IHN1YiA9IGJpbihcInN1YlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRvU3RyaW5nLFxuICBmcm9tU3RyaW5nLFxuICB0b051bWJlcixcbiAgZnJvbU51bWJlcixcbiAgdG9FdGhlcixcbiAgZnJvbUV0aGVyLFxuICB0b1VpbnQyNTYsXG4gIGFkZCxcbiAgbXVsLFxuICBkaXYsXG4gIHN1YlxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/nat.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/rlp.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/rlp.js ***!
  \************************************************************************************************************/
/***/ (function(module) {

eval("// The RLP format\n// Serialization and deserialization for the BytesTree type, under the following grammar:\n// | First byte | Meaning                                                                    |\n// | ---------- | -------------------------------------------------------------------------- |\n// | 0   to 127 | HEX(leaf)                                                                  |\n// | 128 to 183 | HEX(length_of_leaf + 128) + HEX(leaf)                                      |\n// | 184 to 191 | HEX(length_of_length_of_leaf + 128 + 55) + HEX(length_of_leaf) + HEX(leaf) |\n// | 192 to 247 | HEX(length_of_node + 192) + HEX(node)                                      |\n// | 248 to 255 | HEX(length_of_length_of_node + 128 + 55) + HEX(length_of_node) + HEX(node) |\n\nconst encode = tree => {\n  const padEven = str => str.length % 2 === 0 ? str : \"0\" + str;\n\n  const uint = num => padEven(num.toString(16));\n\n  const length = (len, add) => len < 56 ? uint(add + len) : uint(add + uint(len).length / 2 + 55) + uint(len);\n\n  const dataTree = tree => {\n    if (typeof tree === \"string\") {\n      const hex = tree.slice(2);\n      const pre = hex.length != 2 || hex >= \"80\" ? length(hex.length / 2, 128) : \"\";\n      return pre + hex;\n    } else {\n      const hex = tree.map(dataTree).join(\"\");\n      const pre = length(hex.length / 2, 192);\n      return pre + hex;\n    }\n  };\n\n  return \"0x\" + dataTree(tree);\n};\n\nconst decode = hex => {\n  let i = 2;\n\n  const parseTree = () => {\n    if (i >= hex.length) throw \"\";\n    const head = hex.slice(i, i + 2);\n    return head < \"80\" ? (i += 2, \"0x\" + head) : head < \"c0\" ? parseHex() : parseList();\n  };\n\n  const parseLength = () => {\n    const len = parseInt(hex.slice(i, i += 2), 16) % 64;\n    return len < 56 ? len : parseInt(hex.slice(i, i += (len - 55) * 2), 16);\n  };\n\n  const parseHex = () => {\n    const len = parseLength();\n    return \"0x\" + hex.slice(i, i += len * 2);\n  };\n\n  const parseList = () => {\n    const lim = parseLength() * 2 + i;\n    let list = [];\n    while (i < lim) list.push(parseTree());\n    return list;\n  };\n\n  try {\n    return parseTree();\n  } catch (e) {\n    return [];\n  }\n};\n\nmodule.exports = { encode, decode };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL3JscC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbm9kZV9tb2R1bGVzL2V0aC1saWIvbGliL3JscC5qcz85OTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZSBSTFAgZm9ybWF0XG4vLyBTZXJpYWxpemF0aW9uIGFuZCBkZXNlcmlhbGl6YXRpb24gZm9yIHRoZSBCeXRlc1RyZWUgdHlwZSwgdW5kZXIgdGhlIGZvbGxvd2luZyBncmFtbWFyOlxuLy8gfCBGaXJzdCBieXRlIHwgTWVhbmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfCAtLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuLy8gfCAwICAgdG8gMTI3IHwgSEVYKGxlYWYpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfCAxMjggdG8gMTgzIHwgSEVYKGxlbmd0aF9vZl9sZWFmICsgMTI4KSArIEhFWChsZWFmKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfCAxODQgdG8gMTkxIHwgSEVYKGxlbmd0aF9vZl9sZW5ndGhfb2ZfbGVhZiArIDEyOCArIDU1KSArIEhFWChsZW5ndGhfb2ZfbGVhZikgKyBIRVgobGVhZikgfFxuLy8gfCAxOTIgdG8gMjQ3IHwgSEVYKGxlbmd0aF9vZl9ub2RlICsgMTkyKSArIEhFWChub2RlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfCAyNDggdG8gMjU1IHwgSEVYKGxlbmd0aF9vZl9sZW5ndGhfb2Zfbm9kZSArIDEyOCArIDU1KSArIEhFWChsZW5ndGhfb2Zfbm9kZSkgKyBIRVgobm9kZSkgfFxuXG5jb25zdCBlbmNvZGUgPSB0cmVlID0+IHtcbiAgY29uc3QgcGFkRXZlbiA9IHN0ciA9PiBzdHIubGVuZ3RoICUgMiA9PT0gMCA/IHN0ciA6IFwiMFwiICsgc3RyO1xuXG4gIGNvbnN0IHVpbnQgPSBudW0gPT4gcGFkRXZlbihudW0udG9TdHJpbmcoMTYpKTtcblxuICBjb25zdCBsZW5ndGggPSAobGVuLCBhZGQpID0+IGxlbiA8IDU2ID8gdWludChhZGQgKyBsZW4pIDogdWludChhZGQgKyB1aW50KGxlbikubGVuZ3RoIC8gMiArIDU1KSArIHVpbnQobGVuKTtcblxuICBjb25zdCBkYXRhVHJlZSA9IHRyZWUgPT4ge1xuICAgIGlmICh0eXBlb2YgdHJlZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgaGV4ID0gdHJlZS5zbGljZSgyKTtcbiAgICAgIGNvbnN0IHByZSA9IGhleC5sZW5ndGggIT0gMiB8fCBoZXggPj0gXCI4MFwiID8gbGVuZ3RoKGhleC5sZW5ndGggLyAyLCAxMjgpIDogXCJcIjtcbiAgICAgIHJldHVybiBwcmUgKyBoZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhleCA9IHRyZWUubWFwKGRhdGFUcmVlKS5qb2luKFwiXCIpO1xuICAgICAgY29uc3QgcHJlID0gbGVuZ3RoKGhleC5sZW5ndGggLyAyLCAxOTIpO1xuICAgICAgcmV0dXJuIHByZSArIGhleDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFwiMHhcIiArIGRhdGFUcmVlKHRyZWUpO1xufTtcblxuY29uc3QgZGVjb2RlID0gaGV4ID0+IHtcbiAgbGV0IGkgPSAyO1xuXG4gIGNvbnN0IHBhcnNlVHJlZSA9ICgpID0+IHtcbiAgICBpZiAoaSA+PSBoZXgubGVuZ3RoKSB0aHJvdyBcIlwiO1xuICAgIGNvbnN0IGhlYWQgPSBoZXguc2xpY2UoaSwgaSArIDIpO1xuICAgIHJldHVybiBoZWFkIDwgXCI4MFwiID8gKGkgKz0gMiwgXCIweFwiICsgaGVhZCkgOiBoZWFkIDwgXCJjMFwiID8gcGFyc2VIZXgoKSA6IHBhcnNlTGlzdCgpO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlTGVuZ3RoID0gKCkgPT4ge1xuICAgIGNvbnN0IGxlbiA9IHBhcnNlSW50KGhleC5zbGljZShpLCBpICs9IDIpLCAxNikgJSA2NDtcbiAgICByZXR1cm4gbGVuIDwgNTYgPyBsZW4gOiBwYXJzZUludChoZXguc2xpY2UoaSwgaSArPSAobGVuIC0gNTUpICogMiksIDE2KTtcbiAgfTtcblxuICBjb25zdCBwYXJzZUhleCA9ICgpID0+IHtcbiAgICBjb25zdCBsZW4gPSBwYXJzZUxlbmd0aCgpO1xuICAgIHJldHVybiBcIjB4XCIgKyBoZXguc2xpY2UoaSwgaSArPSBsZW4gKiAyKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZUxpc3QgPSAoKSA9PiB7XG4gICAgY29uc3QgbGltID0gcGFyc2VMZW5ndGgoKSAqIDIgKyBpO1xuICAgIGxldCBsaXN0ID0gW107XG4gICAgd2hpbGUgKGkgPCBsaW0pIGxpc3QucHVzaChwYXJzZVRyZWUoKSk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gcGFyc2VUcmVlKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBlbmNvZGUsIGRlY29kZSB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/rlp.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-contract/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-contract/lib/index.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file contract.js\n *\n * To initialize a contract use:\n *\n *  var Contract = require('web3-eth-contract');\n *  Contract.setProvider('ws://localhost:8546');\n *  var contract = new Contract(abi, address, ...);\n *\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar core = __webpack_require__(/*! web3-core */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\");\nvar Method = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar Subscription = (__webpack_require__(/*! web3-core-subscriptions */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js\").subscription);\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar promiEvent = __webpack_require__(/*! web3-core-promievent */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/lib/index.js\");\nvar abi = __webpack_require__(/*! web3-eth-abi */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-abi/lib/index.js\");\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\nvar Contract = function Contract(jsonInterface, address, options) {\n    var _this = this, args = Array.prototype.slice.call(arguments);\n    if (!(this instanceof Contract)) {\n        throw new Error('Please use the \"new\" keyword to instantiate a web3.eth.Contract() object!');\n    }\n    this.setProvider = function () {\n        core.packageInit(_this, arguments);\n        _this.clearSubscriptions = _this._requestManager.clearSubscriptions;\n    };\n    // sets _requestmanager\n    core.packageInit(this, [this.constructor]);\n    this.clearSubscriptions = this._requestManager.clearSubscriptions;\n    if (!jsonInterface || !(Array.isArray(jsonInterface))) {\n        throw errors.ContractMissingABIError();\n    }\n    // create the options object\n    this.options = {};\n    var lastArg = args[args.length - 1];\n    if (!!lastArg && typeof lastArg === 'object' && !Array.isArray(lastArg)) {\n        options = lastArg;\n        this.options = { ...this.options, ...this._getOrSetDefaultOptions(options) };\n        if (!!address && typeof address === 'object') {\n            address = null;\n        }\n    }\n    // set address\n    Object.defineProperty(this.options, 'address', {\n        set: function (value) {\n            if (value) {\n                _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n            }\n        },\n        get: function () {\n            return _this._address;\n        },\n        enumerable: true\n    });\n    // add method and event signatures, when the jsonInterface gets set\n    Object.defineProperty(this.options, 'jsonInterface', {\n        set: function (value) {\n            _this.methods = {};\n            _this.events = {};\n            _this._jsonInterface = value.map(function (method) {\n                var func, funcName;\n                // make constant and payable backwards compatible\n                method.constant = (method.stateMutability === \"view\" || method.stateMutability === \"pure\" || method.constant);\n                method.payable = (method.stateMutability === \"payable\" || method.payable);\n                if (method.name) {\n                    funcName = utils._jsonInterfaceMethodToString(method);\n                }\n                // function\n                if (method.type === 'function') {\n                    method.signature = abi.encodeFunctionSignature(funcName);\n                    func = _this._createTxObject.bind({\n                        method: method,\n                        parent: _this\n                    });\n                    // add method only if not one already exists\n                    if (!_this.methods[method.name]) {\n                        _this.methods[method.name] = func;\n                    }\n                    else {\n                        var cascadeFunc = _this._createTxObject.bind({\n                            method: method,\n                            parent: _this,\n                            nextMethod: _this.methods[method.name]\n                        });\n                        _this.methods[method.name] = cascadeFunc;\n                    }\n                    // definitely add the method based on its signature\n                    _this.methods[method.signature] = func;\n                    // add method by name\n                    _this.methods[funcName] = func;\n                    // event\n                }\n                else if (method.type === 'event') {\n                    method.signature = abi.encodeEventSignature(funcName);\n                    var event = _this._on.bind(_this, method.signature);\n                    // add method only if not already exists\n                    if (!_this.events[method.name] || _this.events[method.name].name === 'bound ')\n                        _this.events[method.name] = event;\n                    // definitely add the method based on its signature\n                    _this.events[method.signature] = event;\n                    // add event by name\n                    _this.events[funcName] = event;\n                }\n                return method;\n            });\n            // add allEvents\n            _this.events.allEvents = _this._on.bind(_this, 'allevents');\n            return _this._jsonInterface;\n        },\n        get: function () {\n            return _this._jsonInterface;\n        },\n        enumerable: true\n    });\n    // get default account from the Class\n    var defaultAccount = this.constructor.defaultAccount;\n    var defaultBlock = this.constructor.defaultBlock || 'latest';\n    Object.defineProperty(this, 'handleRevert', {\n        get: function () {\n            if (_this.options.handleRevert === false || _this.options.handleRevert === true) {\n                return _this.options.handleRevert;\n            }\n            return this.constructor.handleRevert;\n        },\n        set: function (val) {\n            _this.options.handleRevert = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultCommon', {\n        get: function () {\n            return _this.options.common || this.constructor.defaultCommon;\n        },\n        set: function (val) {\n            _this.options.common = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultHardfork', {\n        get: function () {\n            return _this.options.hardfork || this.constructor.defaultHardfork;\n        },\n        set: function (val) {\n            _this.options.hardfork = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultChain', {\n        get: function () {\n            return _this.options.chain || this.constructor.defaultChain;\n        },\n        set: function (val) {\n            _this.options.chain = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionPollingTimeout', {\n        get: function () {\n            if (_this.options.transactionPollingTimeout === 0) {\n                return _this.options.transactionPollingTimeout;\n            }\n            return _this.options.transactionPollingTimeout || this.constructor.transactionPollingTimeout;\n        },\n        set: function (val) {\n            _this.options.transactionPollingTimeout = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionConfirmationBlocks', {\n        get: function () {\n            if (_this.options.transactionConfirmationBlocks === 0) {\n                return _this.options.transactionConfirmationBlocks;\n            }\n            return _this.options.transactionConfirmationBlocks || this.constructor.transactionConfirmationBlocks;\n        },\n        set: function (val) {\n            _this.options.transactionConfirmationBlocks = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionBlockTimeout', {\n        get: function () {\n            if (_this.options.transactionBlockTimeout === 0) {\n                return _this.options.transactionBlockTimeout;\n            }\n            return _this.options.transactionBlockTimeout || this.constructor.transactionBlockTimeout;\n        },\n        set: function (val) {\n            _this.options.transactionBlockTimeout = val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultAccount', {\n        get: function () {\n            return defaultAccount;\n        },\n        set: function (val) {\n            if (val) {\n                defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n            }\n            return val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultBlock', {\n        get: function () {\n            return defaultBlock;\n        },\n        set: function (val) {\n            defaultBlock = val;\n            return val;\n        },\n        enumerable: true\n    });\n    // properties\n    this.methods = {};\n    this.events = {};\n    this._address = null;\n    this._jsonInterface = [];\n    // set getter/setter properties\n    this.options.address = address;\n    this.options.jsonInterface = jsonInterface;\n};\n/**\n * Sets the new provider, creates a new requestManager, registers the \"data\" listener on the provider and sets the\n * accounts module for the Contract class.\n *\n * @method setProvider\n *\n * @param {string|provider} provider\n * @param {Accounts} accounts\n *\n * @returns void\n */\nContract.setProvider = function (provider, accounts) {\n    // Contract.currentProvider = provider;\n    core.packageInit(this, [provider]);\n    this._ethAccounts = accounts;\n};\n/**\n * Get the callback and modify the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\nContract.prototype._getCallback = function getCallback(args) {\n    if (args && !!args[args.length - 1] && typeof args[args.length - 1] === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\nContract.prototype._checkListener = function (type, event) {\n    if (event === type) {\n        throw errors.ContractReservedEventError(type);\n    }\n};\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n    var gasPrice = options.gasPrice ? String(options.gasPrice) : null;\n    var from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null;\n    options.data = options.data || this.options.data;\n    options.from = from || this.options.from;\n    options.gasPrice = gasPrice || this.options.gasPrice;\n    options.gas = options.gas || options.gasLimit || this.options.gas;\n    // TODO replace with only gasLimit?\n    delete options.gasLimit;\n    return options;\n};\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\nContract.prototype._encodeEventABI = function (event, options) {\n    options = options || {};\n    var filter = options.filter || {}, result = {};\n    ['fromBlock', 'toBlock'].filter(function (f) {\n        return options[f] !== undefined;\n    }).forEach(function (f) {\n        result[f] = formatters.inputBlockNumberFormatter(options[f]);\n    });\n    // use given topics\n    if (Array.isArray(options.topics)) {\n        result.topics = options.topics;\n        // create topics based on filter\n    }\n    else {\n        result.topics = [];\n        // add event signature\n        if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n            result.topics.push(event.signature);\n        }\n        // add event topics (indexed arguments)\n        if (event.name !== 'ALLEVENTS') {\n            var indexedTopics = event.inputs.filter(function (i) {\n                return i.indexed === true;\n            }).map(function (i) {\n                var value = filter[i.name];\n                if (!value) {\n                    return null;\n                }\n                // TODO: https://github.com/ethereum/web3.js/issues/344\n                // TODO: deal properly with components\n                if (Array.isArray(value)) {\n                    return value.map(function (v) {\n                        return abi.encodeParameter(i.type, v);\n                    });\n                }\n                return abi.encodeParameter(i.type, value);\n            });\n            result.topics = result.topics.concat(indexedTopics);\n        }\n        if (!result.topics.length)\n            delete result.topics;\n    }\n    if (this.options.address) {\n        result.address = this.options.address.toLowerCase();\n    }\n    return result;\n};\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\nContract.prototype._decodeEventABI = function (data) {\n    var event = this;\n    data.data = data.data || '';\n    data.topics = data.topics || [];\n    var result = formatters.outputLogFormatter(data);\n    // if allEvents get the right event\n    if (event.name === 'ALLEVENTS') {\n        event = event.jsonInterface.find(function (intf) {\n            return (intf.signature === data.topics[0]);\n        }) || { anonymous: true };\n    }\n    // create empty inputs if none are present (e.g. anonymous events on allEvents)\n    event.inputs = event.inputs || [];\n    // Handle case where an event signature shadows the current ABI with non-identical\n    // arg indexing. If # of topics doesn't match, event is anon.\n    if (!event.anonymous) {\n        let indexedInputs = 0;\n        event.inputs.forEach(input => input.indexed ? indexedInputs++ : null);\n        if (indexedInputs > 0 && (data.topics.length !== indexedInputs + 1)) {\n            event = {\n                anonymous: true,\n                inputs: []\n            };\n        }\n    }\n    var argTopics = event.anonymous ? data.topics : data.topics.slice(1);\n    result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);\n    delete result.returnValues.__length__;\n    // add name\n    result.event = event.name;\n    // add signature\n    result.signature = (event.anonymous || !data.topics[0]) ? null : data.topics[0];\n    // move the data and topics to \"raw\"\n    result.raw = {\n        data: result.data,\n        topics: result.topics\n    };\n    delete result.data;\n    delete result.topics;\n    return result;\n};\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n    var methodSignature = this._method.signature, args = this.arguments || [];\n    var signature = false, paramsABI = this._parent.options.jsonInterface.filter(function (json) {\n        return ((methodSignature === 'constructor' && json.type === methodSignature) ||\n            ((json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function'));\n    }).map(function (json) {\n        var inputLength = (Array.isArray(json.inputs)) ? json.inputs.length : 0;\n        if (inputLength !== args.length) {\n            throw new Error('The number of arguments is not matching the methods required number. You need to pass ' + inputLength + ' arguments.');\n        }\n        if (json.type === 'function') {\n            signature = json.signature;\n        }\n        return Array.isArray(json.inputs) ? json.inputs : [];\n    }).map(function (inputs) {\n        return abi.encodeParameters(inputs, args).replace('0x', '');\n    })[0] || '';\n    // return constructor\n    if (methodSignature === 'constructor') {\n        if (!this._deployData)\n            throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n        if (!this._deployData.startsWith('0x')) {\n            this._deployData = '0x' + this._deployData;\n        }\n        return this._deployData + paramsABI;\n    }\n    // return method\n    var returnValue = (signature) ? signature + paramsABI : paramsABI;\n    if (!returnValue) {\n        throw new Error('Couldn\\'t find a matching contract method named \"' + this._method.name + '\".');\n    }\n    return returnValue;\n};\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\nContract.prototype._decodeMethodReturn = function (outputs, returnValues) {\n    if (!returnValues) {\n        return null;\n    }\n    returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;\n    var result = abi.decodeParameters(outputs, returnValues);\n    if (result.__length__ === 1) {\n        return result[0];\n    }\n    delete result.__length__;\n    return result;\n};\n/**\n * Deploys a contract and fire events based on its state: transactionHash, receipt\n *\n * All event listeners will be removed, once the last possible event is fired (\"error\", or \"receipt\")\n *\n * @method deploy\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\nContract.prototype.deploy = function (options, callback) {\n    options = options || {};\n    options.arguments = options.arguments || [];\n    options = this._getOrSetDefaultOptions(options);\n    // throw error, if no \"data\" is specified\n    if (!options.data) {\n        if (typeof callback === 'function') {\n            return callback(errors.ContractMissingDeployDataError());\n        }\n        throw errors.ContractMissingDeployDataError();\n    }\n    var constructor = this.options.jsonInterface.find((method) => {\n        return (method.type === 'constructor');\n    }) || {};\n    constructor.signature = 'constructor';\n    return this._createTxObject.apply({\n        method: constructor,\n        parent: this,\n        deployData: options.data,\n        _ethAccounts: this.constructor._ethAccounts\n    }, options.arguments);\n};\n/**\n * Gets the event signature and outputFormatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\nContract.prototype._generateEventOptions = function () {\n    var args = Array.prototype.slice.call(arguments);\n    // get the callback\n    var callback = this._getCallback(args);\n    // get the options\n    var options = (!!args[args.length - 1] && typeof args[args.length - 1]) === 'object' ? args.pop() : {};\n    var eventName = (typeof args[0] === 'string') ? args[0] : 'allevents';\n    var event = (eventName.toLowerCase() === 'allevents') ? {\n        name: 'ALLEVENTS',\n        jsonInterface: this.options.jsonInterface\n    } : this.options.jsonInterface.find(function (json) {\n        return (json.type === 'event' && (json.name === eventName || json.signature === '0x' + eventName.replace('0x', '')));\n    });\n    if (!event) {\n        throw errors.ContractEventDoesNotExistError(eventName);\n    }\n    if (!utils.isAddress(this.options.address)) {\n        throw errors.ContractNoAddressDefinedError();\n    }\n    return {\n        params: this._encodeEventABI(event, options),\n        event: event,\n        callback: callback\n    };\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\nContract.prototype.clone = function () {\n    return new this.constructor(this.options.jsonInterface, this.options.address, this.options);\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\nContract.prototype.once = function (event, options, callback) {\n    var args = Array.prototype.slice.call(arguments);\n    // get the callback\n    callback = this._getCallback(args);\n    if (!callback) {\n        throw errors.ContractOnceRequiresCallbackError();\n    }\n    // don't allow fromBlock\n    if (options)\n        delete options.fromBlock;\n    // don't return as once shouldn't provide \"on\"\n    this._on(event, options, function (err, res, sub) {\n        sub.unsubscribe();\n        if (typeof callback === 'function') {\n            callback(err, res, sub);\n        }\n    });\n    return undefined;\n};\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n *\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n *\n * @return {Object} the event subscription\n */\nContract.prototype._on = function () {\n    var subOptions = this._generateEventOptions.apply(this, arguments);\n    if (subOptions.params && subOptions.params.toBlock) {\n        delete subOptions.params.toBlock;\n        console.warn('Invalid option: toBlock. Use getPastEvents for specific range.');\n    }\n    // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n    this._checkListener('newListener', subOptions.event.name);\n    this._checkListener('removeListener', subOptions.event.name);\n    // TODO check if listener already exists? and reuse subscription if options are the same.\n    // create new subscription\n    var subscription = new Subscription({\n        subscription: {\n            params: 1,\n            inputFormatter: [formatters.inputLogFormatter],\n            outputFormatter: this._decodeEventABI.bind(subOptions.event),\n            // DUBLICATE, also in web3-eth\n            subscriptionHandler: function (output) {\n                if (output.removed) {\n                    this.emit('changed', output);\n                }\n                else {\n                    this.emit('data', output);\n                }\n                if (typeof this.callback === 'function') {\n                    this.callback(null, output, this);\n                }\n            }\n        },\n        type: 'eth',\n        requestManager: this._requestManager\n    });\n    subscription.subscribe('logs', subOptions.params, subOptions.callback || function () { });\n    return subscription;\n};\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\nContract.prototype.getPastEvents = function () {\n    var subOptions = this._generateEventOptions.apply(this, arguments);\n    var getPastLogs = new Method({\n        name: 'getPastLogs',\n        call: 'eth_getLogs',\n        params: 1,\n        inputFormatter: [formatters.inputLogFormatter],\n        outputFormatter: this._decodeEventABI.bind(subOptions.event)\n    });\n    getPastLogs.setRequestManager(this._requestManager);\n    var call = getPastLogs.buildCall();\n    getPastLogs = null;\n    return call(subOptions.params, subOptions.callback);\n};\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\nContract.prototype._createTxObject = function _createTxObject() {\n    var args = Array.prototype.slice.call(arguments);\n    var txObject = {};\n    if (this.method.type === 'function') {\n        txObject.call = this.parent._executeMethod.bind(txObject, 'call');\n        txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true); // to make batch requests\n    }\n    txObject.send = this.parent._executeMethod.bind(txObject, 'send');\n    txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true); // to make batch requests\n    txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);\n    txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate');\n    if (args && this.method.inputs && args.length !== this.method.inputs.length) {\n        if (this.nextMethod) {\n            return this.nextMethod.apply(null, args);\n        }\n        throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name);\n    }\n    txObject.arguments = args || [];\n    txObject._method = this.method;\n    txObject._parent = this.parent;\n    txObject._ethAccounts = this.parent.constructor._ethAccounts || this._ethAccounts;\n    if (this.deployData) {\n        txObject._deployData = this.deployData;\n    }\n    return txObject;\n};\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n    var processedArgs = {};\n    processedArgs.type = args.shift();\n    // get the callback\n    processedArgs.callback = this._parent._getCallback(args);\n    // get block number to use for call\n    if (processedArgs.type === 'call' && args[args.length - 1] !== true && (typeof args[args.length - 1] === 'string' || isFinite(args[args.length - 1])))\n        processedArgs.defaultBlock = args.pop();\n    // get the options\n    processedArgs.options = (!!args[args.length - 1] && typeof args[args.length - 1]) === 'object' ? args.pop() : {};\n    // get the generateRequest argument for batch requests\n    processedArgs.generateRequest = (args[args.length - 1] === true) ? args.pop() : false;\n    processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);\n    processedArgs.options.data = this.encodeABI();\n    // add contract address\n    if (!this._deployData && !utils.isAddress(this._parent.options.address))\n        throw errors.ContractNoAddressDefinedError();\n    if (!this._deployData)\n        processedArgs.options.to = this._parent.options.address;\n    // return error, if no \"data\" is specified\n    if (!processedArgs.options.data)\n        return utils._fireError(new Error('Couldn\\'t find a matching contract method, or the number of parameters is wrong.'), defer.eventEmitter, defer.reject, processedArgs.callback);\n    return processedArgs;\n};\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\nContract.prototype._executeMethod = function _executeMethod() {\n    var _this = this, args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer), defer = promiEvent((args.type !== 'send')), ethAccounts = _this.constructor._ethAccounts || _this._ethAccounts;\n    // simple return request for batch requests\n    if (args.generateRequest) {\n        var payload = {\n            params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n            callback: args.callback\n        };\n        if (args.type === 'call') {\n            payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock));\n            payload.method = 'eth_call';\n            payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs);\n        }\n        else {\n            payload.method = 'eth_sendTransaction';\n        }\n        return payload;\n    }\n    switch (args.type) {\n        case 'estimate':\n            var estimateGas = (new Method({\n                name: 'estimateGas',\n                call: 'eth_estimateGas',\n                params: 1,\n                inputFormatter: [formatters.inputCallFormatter],\n                outputFormatter: utils.hexToNumber,\n                requestManager: _this._parent._requestManager,\n                accounts: ethAccounts,\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock\n            })).createFunction();\n            return estimateGas(args.options, args.callback);\n        case 'call':\n            // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n            var call = (new Method({\n                name: 'call',\n                call: 'eth_call',\n                params: 2,\n                inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n                // add output formatter for decoding\n                outputFormatter: function (result) {\n                    return _this._parent._decodeMethodReturn(_this._method.outputs, result);\n                },\n                requestManager: _this._parent._requestManager,\n                accounts: ethAccounts,\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n                handleRevert: _this._parent.handleRevert,\n                abiCoder: abi\n            })).createFunction();\n            return call(args.options, args.defaultBlock, args.callback);\n        case 'send':\n            // return error, if no \"from\" is specified\n            if (!utils.isAddress(args.options.from)) {\n                return utils._fireError(errors.ContractNoFromAddressDefinedError(), defer.eventEmitter, defer.reject, args.callback);\n            }\n            if (typeof this._method.payable === 'boolean' && !this._method.payable && args.options.value && args.options.value > 0) {\n                return utils._fireError(new Error('Can not send value to non-payable contract method or constructor'), defer.eventEmitter, defer.reject, args.callback);\n            }\n            // make sure receipt logs are decoded\n            var extraFormatters = {\n                receiptFormatter: function (receipt) {\n                    if (Array.isArray(receipt.logs)) {\n                        // decode logs\n                        var events = receipt.logs.map((log) => {\n                            return _this._parent._decodeEventABI.call({\n                                name: 'ALLEVENTS',\n                                jsonInterface: _this._parent.options.jsonInterface\n                            }, log);\n                        });\n                        // make log names keys\n                        receipt.events = {};\n                        var count = 0;\n                        events.forEach(function (ev) {\n                            if (ev.event) {\n                                // if > 1 of the same event, don't overwrite any existing events\n                                if (receipt.events[ev.event]) {\n                                    if (Array.isArray(receipt.events[ev.event])) {\n                                        receipt.events[ev.event].push(ev);\n                                    }\n                                    else {\n                                        receipt.events[ev.event] = [receipt.events[ev.event], ev];\n                                    }\n                                }\n                                else {\n                                    receipt.events[ev.event] = ev;\n                                }\n                            }\n                            else {\n                                receipt.events[count] = ev;\n                                count++;\n                            }\n                        });\n                        delete receipt.logs;\n                    }\n                    return receipt;\n                },\n                contractDeployFormatter: function (receipt) {\n                    var newContract = _this._parent.clone();\n                    newContract.options.address = receipt.contractAddress;\n                    return newContract;\n                }\n            };\n            var sendTransaction = (new Method({\n                name: 'sendTransaction',\n                call: 'eth_sendTransaction',\n                params: 1,\n                inputFormatter: [formatters.inputTransactionFormatter],\n                requestManager: _this._parent._requestManager,\n                accounts: _this.constructor._ethAccounts || _this._ethAccounts,\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n                transactionBlockTimeout: _this._parent.transactionBlockTimeout,\n                transactionConfirmationBlocks: _this._parent.transactionConfirmationBlocks,\n                transactionPollingTimeout: _this._parent.transactionPollingTimeout,\n                defaultCommon: _this._parent.defaultCommon,\n                defaultChain: _this._parent.defaultChain,\n                defaultHardfork: _this._parent.defaultHardfork,\n                handleRevert: _this._parent.handleRevert,\n                extraFormatters: extraFormatters,\n                abiCoder: abi\n            })).createFunction();\n            return sendTransaction(args.options, args.callback);\n        default:\n            throw new Error('Method \"' + args.type + '\" not implemented.');\n    }\n};\nmodule.exports = Contract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtY29udHJhY3QvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLFdBQVcsbUJBQU8sQ0FBQyw0RkFBVztBQUM5QixhQUFhLG1CQUFPLENBQUMsMEdBQWtCO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQyw4RkFBWTtBQUNoQyxtQkFBbUIsNEpBQStDO0FBQ2xFLGlCQUFpQiw4SUFBdUM7QUFDeEQsYUFBYSwwSUFBbUM7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsa0hBQXNCO0FBQy9DLFVBQVUsbUJBQU8sQ0FBQyxrR0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1jb250cmFjdC9saWIvaW5kZXguanM/NWVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBjb250cmFjdC5qc1xuICpcbiAqIFRvIGluaXRpYWxpemUgYSBjb250cmFjdCB1c2U6XG4gKlxuICogIHZhciBDb250cmFjdCA9IHJlcXVpcmUoJ3dlYjMtZXRoLWNvbnRyYWN0Jyk7XG4gKiAgQ29udHJhY3Quc2V0UHJvdmlkZXIoJ3dzOi8vbG9jYWxob3N0Ojg1NDYnKTtcbiAqICB2YXIgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWJpLCBhZGRyZXNzLCAuLi4pO1xuICpcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoJ3dlYjMtY29yZScpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJ3dlYjMtY29yZS1tZXRob2QnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBTdWJzY3JpcHRpb24gPSByZXF1aXJlKCd3ZWIzLWNvcmUtc3Vic2NyaXB0aW9ucycpLnN1YnNjcmlwdGlvbjtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5mb3JtYXR0ZXJzO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIHByb21pRXZlbnQgPSByZXF1aXJlKCd3ZWIzLWNvcmUtcHJvbWlldmVudCcpO1xudmFyIGFiaSA9IHJlcXVpcmUoJ3dlYjMtZXRoLWFiaScpO1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgY29udHJhY3QgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIENvbnRyYWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGpzb25JbnRlcmZhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG52YXIgQ29udHJhY3QgPSBmdW5jdGlvbiBDb250cmFjdChqc29uSW50ZXJmYWNlLCBhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbnRyYWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIga2V5d29yZCB0byBpbnN0YW50aWF0ZSBhIHdlYjMuZXRoLkNvbnRyYWN0KCkgb2JqZWN0IScpO1xuICAgIH1cbiAgICB0aGlzLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb3JlLnBhY2thZ2VJbml0KF90aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBfdGhpcy5jbGVhclN1YnNjcmlwdGlvbnMgPSBfdGhpcy5fcmVxdWVzdE1hbmFnZXIuY2xlYXJTdWJzY3JpcHRpb25zO1xuICAgIH07XG4gICAgLy8gc2V0cyBfcmVxdWVzdG1hbmFnZXJcbiAgICBjb3JlLnBhY2thZ2VJbml0KHRoaXMsIFt0aGlzLmNvbnN0cnVjdG9yXSk7XG4gICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbnMgPSB0aGlzLl9yZXF1ZXN0TWFuYWdlci5jbGVhclN1YnNjcmlwdGlvbnM7XG4gICAgaWYgKCFqc29uSW50ZXJmYWNlIHx8ICEoQXJyYXkuaXNBcnJheShqc29uSW50ZXJmYWNlKSkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLkNvbnRyYWN0TWlzc2luZ0FCSUVycm9yKCk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBpZiAoISFsYXN0QXJnICYmIHR5cGVvZiBsYXN0QXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShsYXN0QXJnKSkge1xuICAgICAgICBvcHRpb25zID0gbGFzdEFyZztcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLnRoaXMuX2dldE9yU2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykgfTtcbiAgICAgICAgaWYgKCEhYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBhZGRyZXNzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub3B0aW9ucywgJ2FkZHJlc3MnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWRkcmVzcyA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzKGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hZGRyZXNzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gYWRkIG1ldGhvZCBhbmQgZXZlbnQgc2lnbmF0dXJlcywgd2hlbiB0aGUganNvbkludGVyZmFjZSBnZXRzIHNldFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsICdqc29uSW50ZXJmYWNlJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMubWV0aG9kcyA9IHt9O1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRzID0ge307XG4gICAgICAgICAgICBfdGhpcy5fanNvbkludGVyZmFjZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMsIGZ1bmNOYW1lO1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgY29uc3RhbnQgYW5kIHBheWFibGUgYmFja3dhcmRzIGNvbXBhdGlibGVcbiAgICAgICAgICAgICAgICBtZXRob2QuY29uc3RhbnQgPSAobWV0aG9kLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgbWV0aG9kLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIgfHwgbWV0aG9kLmNvbnN0YW50KTtcbiAgICAgICAgICAgICAgICBtZXRob2QucGF5YWJsZSA9IChtZXRob2Quc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiB8fCBtZXRob2QucGF5YWJsZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhtZXRob2QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Quc2lnbmF0dXJlID0gYWJpLmVuY29kZUZ1bmN0aW9uU2lnbmF0dXJlKGZ1bmNOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyA9IF90aGlzLl9jcmVhdGVUeE9iamVjdC5iaW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG1ldGhvZCBvbmx5IGlmIG5vdCBvbmUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5tZXRob2RzW21ldGhvZC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWV0aG9kc1ttZXRob2QubmFtZV0gPSBmdW5jO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhc2NhZGVGdW5jID0gX3RoaXMuX2NyZWF0ZVR4T2JqZWN0LmJpbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE1ldGhvZDogX3RoaXMubWV0aG9kc1ttZXRob2QubmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWV0aG9kc1ttZXRob2QubmFtZV0gPSBjYXNjYWRlRnVuYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbml0ZWx5IGFkZCB0aGUgbWV0aG9kIGJhc2VkIG9uIGl0cyBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWV0aG9kc1ttZXRob2Quc2lnbmF0dXJlXSA9IGZ1bmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBtZXRob2QgYnkgbmFtZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXRob2RzW2Z1bmNOYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZC50eXBlID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC5zaWduYXR1cmUgPSBhYmkuZW5jb2RlRXZlbnRTaWduYXR1cmUoZnVuY05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBfdGhpcy5fb24uYmluZChfdGhpcywgbWV0aG9kLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBtZXRob2Qgb25seSBpZiBub3QgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5ldmVudHNbbWV0aG9kLm5hbWVdIHx8IF90aGlzLmV2ZW50c1ttZXRob2QubmFtZV0ubmFtZSA9PT0gJ2JvdW5kICcpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudHNbbWV0aG9kLm5hbWVdID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlbHkgYWRkIHRoZSBtZXRob2QgYmFzZWQgb24gaXRzIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudHNbbWV0aG9kLnNpZ25hdHVyZV0gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGV2ZW50IGJ5IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRzW2Z1bmNOYW1lXSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhZGQgYWxsRXZlbnRzXG4gICAgICAgICAgICBfdGhpcy5ldmVudHMuYWxsRXZlbnRzID0gX3RoaXMuX29uLmJpbmQoX3RoaXMsICdhbGxldmVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fanNvbkludGVyZmFjZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2pzb25JbnRlcmZhY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBnZXQgZGVmYXVsdCBhY2NvdW50IGZyb20gdGhlIENsYXNzXG4gICAgdmFyIGRlZmF1bHRBY2NvdW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0QWNjb3VudDtcbiAgICB2YXIgZGVmYXVsdEJsb2NrID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0QmxvY2sgfHwgJ2xhdGVzdCc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoYW5kbGVSZXZlcnQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuaGFuZGxlUmV2ZXJ0ID09PSBmYWxzZSB8fCBfdGhpcy5vcHRpb25zLmhhbmRsZVJldmVydCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLmhhbmRsZVJldmVydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmhhbmRsZVJldmVydDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zLmhhbmRsZVJldmVydCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdENvbW1vbicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5jb21tb24gfHwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0Q29tbW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuY29tbW9uID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWZhdWx0SGFyZGZvcmsnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMuaGFyZGZvcmsgfHwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0SGFyZGZvcms7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5oYXJkZm9yayA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdENoYWluJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLmNoYWluIHx8IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdENoYWluO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuY2hhaW4gPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0IHx8IHRoaXMuY29uc3RydWN0b3IudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyB8fCB0aGlzLmNvbnN0cnVjdG9yLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RyYW5zYWN0aW9uQmxvY2tUaW1lb3V0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy50cmFuc2FjdGlvbkJsb2NrVGltZW91dCB8fCB0aGlzLmNvbnN0cnVjdG9yLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRBY2NvdW50Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QWNjb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQgPSB1dGlscy50b0NoZWNrc3VtQWRkcmVzcyhmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlcih2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRCbG9jaycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEJsb2NrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRCbG9jayA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgdGhpcy5tZXRob2RzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB0aGlzLl9hZGRyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9qc29uSW50ZXJmYWNlID0gW107XG4gICAgLy8gc2V0IGdldHRlci9zZXR0ZXIgcHJvcGVydGllc1xuICAgIHRoaXMub3B0aW9ucy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLm9wdGlvbnMuanNvbkludGVyZmFjZSA9IGpzb25JbnRlcmZhY2U7XG59O1xuLyoqXG4gKiBTZXRzIHRoZSBuZXcgcHJvdmlkZXIsIGNyZWF0ZXMgYSBuZXcgcmVxdWVzdE1hbmFnZXIsIHJlZ2lzdGVycyB0aGUgXCJkYXRhXCIgbGlzdGVuZXIgb24gdGhlIHByb3ZpZGVyIGFuZCBzZXRzIHRoZVxuICogYWNjb3VudHMgbW9kdWxlIGZvciB0aGUgQ29udHJhY3QgY2xhc3MuXG4gKlxuICogQG1ldGhvZCBzZXRQcm92aWRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHByb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtBY2NvdW50c30gYWNjb3VudHNcbiAqXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cbkNvbnRyYWN0LnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBhY2NvdW50cykge1xuICAgIC8vIENvbnRyYWN0LmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIGNvcmUucGFja2FnZUluaXQodGhpcywgW3Byb3ZpZGVyXSk7XG4gICAgdGhpcy5fZXRoQWNjb3VudHMgPSBhY2NvdW50cztcbn07XG4vKipcbiAqIEdldCB0aGUgY2FsbGJhY2sgYW5kIG1vZGlmeSB0aGUgYXJyYXkgaWYgbmVjZXNzYXJ5XG4gKlxuICogQG1ldGhvZCBfZ2V0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2tcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9nZXRDYWxsYmFjayA9IGZ1bmN0aW9uIGdldENhbGxiYWNrKGFyZ3MpIHtcbiAgICBpZiAoYXJncyAmJiAhIWFyZ3NbYXJncy5sZW5ndGggLSAxXSAmJiB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcbi8qKlxuICogQ2hlY2tzIHRoYXQgbm8gbGlzdGVuZXIgd2l0aCBuYW1lIFwibmV3TGlzdGVuZXJcIiBvciBcInJlbW92ZUxpc3RlbmVyXCIgaXMgYWRkZWQuXG4gKlxuICogQG1ldGhvZCBfY2hlY2tMaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY29udHJhY3QgaW5zdGFuY2VcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9jaGVja0xpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSB0eXBlKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5Db250cmFjdFJlc2VydmVkRXZlbnRFcnJvcih0eXBlKTtcbiAgICB9XG59O1xuLyoqXG4gKiBVc2UgZGVmYXVsdCB2YWx1ZXMsIGlmIG9wdGlvbnMgYXJlIG5vdCBhdmFpbGFibGVcbiAqXG4gKiBAbWV0aG9kIF9nZXRPclNldERlZmF1bHRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBnaXZlZCBieSB0aGUgdXNlclxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgb3B0aW9ucyB3aXRoIGdhcHMgZmlsbGVkIGJ5IGRlZmF1bHRzXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fZ2V0T3JTZXREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9yU2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBnYXNQcmljZSA9IG9wdGlvbnMuZ2FzUHJpY2UgPyBTdHJpbmcob3B0aW9ucy5nYXNQcmljZSkgOiBudWxsO1xuICAgIHZhciBmcm9tID0gb3B0aW9ucy5mcm9tID8gdXRpbHMudG9DaGVja3N1bUFkZHJlc3MoZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy5mcm9tKSkgOiBudWxsO1xuICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCB0aGlzLm9wdGlvbnMuZGF0YTtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tIHx8IHRoaXMub3B0aW9ucy5mcm9tO1xuICAgIG9wdGlvbnMuZ2FzUHJpY2UgPSBnYXNQcmljZSB8fCB0aGlzLm9wdGlvbnMuZ2FzUHJpY2U7XG4gICAgb3B0aW9ucy5nYXMgPSBvcHRpb25zLmdhcyB8fCBvcHRpb25zLmdhc0xpbWl0IHx8IHRoaXMub3B0aW9ucy5nYXM7XG4gICAgLy8gVE9ETyByZXBsYWNlIHdpdGggb25seSBnYXNMaW1pdD9cbiAgICBkZWxldGUgb3B0aW9ucy5nYXNMaW1pdDtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBpbmRleGVkIHBhcmFtcyBhbmQgb3B0aW9ucyB0byBvbmUgZmluYWwgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfZW5jb2RlRXZlbnRBQklcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlcnl0aGluZyBjb21iaW5lZCB0b2dldGhlciBhbmQgZW5jb2RlZFxuICovXG5Db250cmFjdC5wcm90b3R5cGUuX2VuY29kZUV2ZW50QUJJID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyIHx8IHt9LCByZXN1bHQgPSB7fTtcbiAgICBbJ2Zyb21CbG9jaycsICd0b0Jsb2NrJ10uZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2ZdICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXN1bHRbZl0gPSBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9uc1tmXSk7XG4gICAgfSk7XG4gICAgLy8gdXNlIGdpdmVuIHRvcGljc1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudG9waWNzKSkge1xuICAgICAgICByZXN1bHQudG9waWNzID0gb3B0aW9ucy50b3BpY3M7XG4gICAgICAgIC8vIGNyZWF0ZSB0b3BpY3MgYmFzZWQgb24gZmlsdGVyXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQudG9waWNzID0gW107XG4gICAgICAgIC8vIGFkZCBldmVudCBzaWduYXR1cmVcbiAgICAgICAgaWYgKGV2ZW50ICYmICFldmVudC5hbm9ueW1vdXMgJiYgZXZlbnQubmFtZSAhPT0gJ0FMTEVWRU5UUycpIHtcbiAgICAgICAgICAgIHJlc3VsdC50b3BpY3MucHVzaChldmVudC5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBldmVudCB0b3BpY3MgKGluZGV4ZWQgYXJndW1lbnRzKVxuICAgICAgICBpZiAoZXZlbnQubmFtZSAhPT0gJ0FMTEVWRU5UUycpIHtcbiAgICAgICAgICAgIHZhciBpbmRleGVkVG9waWNzID0gZXZlbnQuaW5wdXRzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmluZGV4ZWQgPT09IHRydWU7XG4gICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmaWx0ZXJbaS5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2ViMy5qcy9pc3N1ZXMvMzQ0XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZGVhbCBwcm9wZXJseSB3aXRoIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFiaS5lbmNvZGVQYXJhbWV0ZXIoaS50eXBlLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhYmkuZW5jb2RlUGFyYW1ldGVyKGkudHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQudG9waWNzID0gcmVzdWx0LnRvcGljcy5jb25jYXQoaW5kZXhlZFRvcGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQudG9waWNzLmxlbmd0aClcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQudG9waWNzO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmFkZHJlc3MpIHtcbiAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB0aGlzLm9wdGlvbnMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGluZGV4ZWQgcGFyYW1zIGFuZCBvcHRpb25zXG4gKlxuICogQG1ldGhvZCBfZGVjb2RlRXZlbnRBQklcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCBvYmplY3Qgd2l0aCBkZWNvZGVkIGluZGV4ZWQgJiYgbm90IGluZGV4ZWQgcGFyYW1zXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fZGVjb2RlRXZlbnRBQkkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBldmVudCA9IHRoaXM7XG4gICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8ICcnO1xuICAgIGRhdGEudG9waWNzID0gZGF0YS50b3BpY3MgfHwgW107XG4gICAgdmFyIHJlc3VsdCA9IGZvcm1hdHRlcnMub3V0cHV0TG9nRm9ybWF0dGVyKGRhdGEpO1xuICAgIC8vIGlmIGFsbEV2ZW50cyBnZXQgdGhlIHJpZ2h0IGV2ZW50XG4gICAgaWYgKGV2ZW50Lm5hbWUgPT09ICdBTExFVkVOVFMnKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnQuanNvbkludGVyZmFjZS5maW5kKGZ1bmN0aW9uIChpbnRmKSB7XG4gICAgICAgICAgICByZXR1cm4gKGludGYuc2lnbmF0dXJlID09PSBkYXRhLnRvcGljc1swXSk7XG4gICAgICAgIH0pIHx8IHsgYW5vbnltb3VzOiB0cnVlIH07XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBlbXB0eSBpbnB1dHMgaWYgbm9uZSBhcmUgcHJlc2VudCAoZS5nLiBhbm9ueW1vdXMgZXZlbnRzIG9uIGFsbEV2ZW50cylcbiAgICBldmVudC5pbnB1dHMgPSBldmVudC5pbnB1dHMgfHwgW107XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgYW4gZXZlbnQgc2lnbmF0dXJlIHNoYWRvd3MgdGhlIGN1cnJlbnQgQUJJIHdpdGggbm9uLWlkZW50aWNhbFxuICAgIC8vIGFyZyBpbmRleGluZy4gSWYgIyBvZiB0b3BpY3MgZG9lc24ndCBtYXRjaCwgZXZlbnQgaXMgYW5vbi5cbiAgICBpZiAoIWV2ZW50LmFub255bW91cykge1xuICAgICAgICBsZXQgaW5kZXhlZElucHV0cyA9IDA7XG4gICAgICAgIGV2ZW50LmlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0LmluZGV4ZWQgPyBpbmRleGVkSW5wdXRzKysgOiBudWxsKTtcbiAgICAgICAgaWYgKGluZGV4ZWRJbnB1dHMgPiAwICYmIChkYXRhLnRvcGljcy5sZW5ndGggIT09IGluZGV4ZWRJbnB1dHMgKyAxKSkge1xuICAgICAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgYW5vbnltb3VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlucHV0czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFyZ1RvcGljcyA9IGV2ZW50LmFub255bW91cyA/IGRhdGEudG9waWNzIDogZGF0YS50b3BpY3Muc2xpY2UoMSk7XG4gICAgcmVzdWx0LnJldHVyblZhbHVlcyA9IGFiaS5kZWNvZGVMb2coZXZlbnQuaW5wdXRzLCBkYXRhLmRhdGEsIGFyZ1RvcGljcyk7XG4gICAgZGVsZXRlIHJlc3VsdC5yZXR1cm5WYWx1ZXMuX19sZW5ndGhfXztcbiAgICAvLyBhZGQgbmFtZVxuICAgIHJlc3VsdC5ldmVudCA9IGV2ZW50Lm5hbWU7XG4gICAgLy8gYWRkIHNpZ25hdHVyZVxuICAgIHJlc3VsdC5zaWduYXR1cmUgPSAoZXZlbnQuYW5vbnltb3VzIHx8ICFkYXRhLnRvcGljc1swXSkgPyBudWxsIDogZGF0YS50b3BpY3NbMF07XG4gICAgLy8gbW92ZSB0aGUgZGF0YSBhbmQgdG9waWNzIHRvIFwicmF3XCJcbiAgICByZXN1bHQucmF3ID0ge1xuICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgICAgdG9waWNzOiByZXN1bHQudG9waWNzXG4gICAgfTtcbiAgICBkZWxldGUgcmVzdWx0LmRhdGE7XG4gICAgZGVsZXRlIHJlc3VsdC50b3BpY3M7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIEVuY29kZXMgYW4gQUJJIGZvciBhIG1ldGhvZCwgaW5jbHVkaW5nIHNpZ25hdHVyZSBvciB0aGUgbWV0aG9kLlxuICogT3Igd2hlbiBjb25zdHJ1Y3RvciBlbmNvZGVzIG9ubHkgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMuXG4gKlxuICogQG1ldGhvZCBfZW5jb2RlTWV0aG9kQUJJXG4gKiBAcGFyYW0ge01peGVkfSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIGVuY29kZWQgQUJJXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fZW5jb2RlTWV0aG9kQUJJID0gZnVuY3Rpb24gX2VuY29kZU1ldGhvZEFCSSgpIHtcbiAgICB2YXIgbWV0aG9kU2lnbmF0dXJlID0gdGhpcy5fbWV0aG9kLnNpZ25hdHVyZSwgYXJncyA9IHRoaXMuYXJndW1lbnRzIHx8IFtdO1xuICAgIHZhciBzaWduYXR1cmUgPSBmYWxzZSwgcGFyYW1zQUJJID0gdGhpcy5fcGFyZW50Lm9wdGlvbnMuanNvbkludGVyZmFjZS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuICgobWV0aG9kU2lnbmF0dXJlID09PSAnY29uc3RydWN0b3InICYmIGpzb24udHlwZSA9PT0gbWV0aG9kU2lnbmF0dXJlKSB8fFxuICAgICAgICAgICAgKChqc29uLnNpZ25hdHVyZSA9PT0gbWV0aG9kU2lnbmF0dXJlIHx8IGpzb24uc2lnbmF0dXJlID09PSBtZXRob2RTaWduYXR1cmUucmVwbGFjZSgnMHgnLCAnJykgfHwganNvbi5uYW1lID09PSBtZXRob2RTaWduYXR1cmUpICYmIGpzb24udHlwZSA9PT0gJ2Z1bmN0aW9uJykpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoanNvbikge1xuICAgICAgICB2YXIgaW5wdXRMZW5ndGggPSAoQXJyYXkuaXNBcnJheShqc29uLmlucHV0cykpID8ganNvbi5pbnB1dHMubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBub3QgbWF0Y2hpbmcgdGhlIG1ldGhvZHMgcmVxdWlyZWQgbnVtYmVyLiBZb3UgbmVlZCB0byBwYXNzICcgKyBpbnB1dExlbmd0aCArICcgYXJndW1lbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGpzb24uc2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGpzb24uaW5wdXRzKSA/IGpzb24uaW5wdXRzIDogW107XG4gICAgfSkubWFwKGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGFiaS5lbmNvZGVQYXJhbWV0ZXJzKGlucHV0cywgYXJncykucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgfSlbMF0gfHwgJyc7XG4gICAgLy8gcmV0dXJuIGNvbnN0cnVjdG9yXG4gICAgaWYgKG1ldGhvZFNpZ25hdHVyZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICBpZiAoIXRoaXMuX2RlcGxveURhdGEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjb250cmFjdCBoYXMgbm8gY29udHJhY3QgZGF0YSBvcHRpb24gc2V0LiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBhcHBlbmQgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgIGlmICghdGhpcy5fZGVwbG95RGF0YS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXBsb3lEYXRhID0gJzB4JyArIHRoaXMuX2RlcGxveURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveURhdGEgKyBwYXJhbXNBQkk7XG4gICAgfVxuICAgIC8vIHJldHVybiBtZXRob2RcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSAoc2lnbmF0dXJlKSA/IHNpZ25hdHVyZSArIHBhcmFtc0FCSSA6IHBhcmFtc0FCSTtcbiAgICBpZiAoIXJldHVyblZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBmaW5kIGEgbWF0Y2hpbmcgY29udHJhY3QgbWV0aG9kIG5hbWVkIFwiJyArIHRoaXMuX21ldGhvZC5uYW1lICsgJ1wiLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuLyoqXG4gKiBEZWNvZGUgbWV0aG9kIHJldHVybiB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kIF9kZWNvZGVNZXRob2RSZXR1cm5cbiAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dHNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXR1cm5WYWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlZCBvdXRwdXQgcmV0dXJuIHZhbHVlc1xuICovXG5Db250cmFjdC5wcm90b3R5cGUuX2RlY29kZU1ldGhvZFJldHVybiA9IGZ1bmN0aW9uIChvdXRwdXRzLCByZXR1cm5WYWx1ZXMpIHtcbiAgICBpZiAoIXJldHVyblZhbHVlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuVmFsdWVzID0gcmV0dXJuVmFsdWVzLmxlbmd0aCA+PSAyID8gcmV0dXJuVmFsdWVzLnNsaWNlKDIpIDogcmV0dXJuVmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSBhYmkuZGVjb2RlUGFyYW1ldGVycyhvdXRwdXRzLCByZXR1cm5WYWx1ZXMpO1xuICAgIGlmIChyZXN1bHQuX19sZW5ndGhfXyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cbiAgICBkZWxldGUgcmVzdWx0Ll9fbGVuZ3RoX187XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIERlcGxveXMgYSBjb250cmFjdCBhbmQgZmlyZSBldmVudHMgYmFzZWQgb24gaXRzIHN0YXRlOiB0cmFuc2FjdGlvbkhhc2gsIHJlY2VpcHRcbiAqXG4gKiBBbGwgZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZCwgb25jZSB0aGUgbGFzdCBwb3NzaWJsZSBldmVudCBpcyBmaXJlZCAoXCJlcnJvclwiLCBvciBcInJlY2VpcHRcIilcbiAqXG4gKiBAbWV0aG9kIGRlcGxveVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9IEV2ZW50RW1pdHRlciBwb3NzaWJsZSBldmVudHMgYXJlIFwiZXJyb3JcIiwgXCJ0cmFuc2FjdGlvbkhhc2hcIiBhbmQgXCJyZWNlaXB0XCJcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLmRlcGxveSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuYXJndW1lbnRzID0gb3B0aW9ucy5hcmd1bWVudHMgfHwgW107XG4gICAgb3B0aW9ucyA9IHRoaXMuX2dldE9yU2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgLy8gdGhyb3cgZXJyb3IsIGlmIG5vIFwiZGF0YVwiIGlzIHNwZWNpZmllZFxuICAgIGlmICghb3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuQ29udHJhY3RNaXNzaW5nRGVwbG95RGF0YUVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9ycy5Db250cmFjdE1pc3NpbmdEZXBsb3lEYXRhRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5vcHRpb25zLmpzb25JbnRlcmZhY2UuZmluZCgobWV0aG9kKSA9PiB7XG4gICAgICAgIHJldHVybiAobWV0aG9kLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicpO1xuICAgIH0pIHx8IHt9O1xuICAgIGNvbnN0cnVjdG9yLnNpZ25hdHVyZSA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVR4T2JqZWN0LmFwcGx5KHtcbiAgICAgICAgbWV0aG9kOiBjb25zdHJ1Y3RvcixcbiAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICBkZXBsb3lEYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgIF9ldGhBY2NvdW50czogdGhpcy5jb25zdHJ1Y3Rvci5fZXRoQWNjb3VudHNcbiAgICB9LCBvcHRpb25zLmFyZ3VtZW50cyk7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBldmVudCBzaWduYXR1cmUgYW5kIG91dHB1dEZvcm1hdHRlcnNcbiAqXG4gKiBAbWV0aG9kIF9nZW5lcmF0ZUV2ZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGV2ZW50IG9wdGlvbnMgb2JqZWN0XG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fZ2VuZXJhdGVFdmVudE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIC8vIGdldCB0aGUgY2FsbGJhY2tcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9nZXRDYWxsYmFjayhhcmdzKTtcbiAgICAvLyBnZXQgdGhlIG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9ICghIWFyZ3NbYXJncy5sZW5ndGggLSAxXSAmJiB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gJ29iamVjdCcgPyBhcmdzLnBvcCgpIDoge307XG4gICAgdmFyIGV2ZW50TmFtZSA9ICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpID8gYXJnc1swXSA6ICdhbGxldmVudHMnO1xuICAgIHZhciBldmVudCA9IChldmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2FsbGV2ZW50cycpID8ge1xuICAgICAgICBuYW1lOiAnQUxMRVZFTlRTJyxcbiAgICAgICAganNvbkludGVyZmFjZTogdGhpcy5vcHRpb25zLmpzb25JbnRlcmZhY2VcbiAgICB9IDogdGhpcy5vcHRpb25zLmpzb25JbnRlcmZhY2UuZmluZChmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4gKGpzb24udHlwZSA9PT0gJ2V2ZW50JyAmJiAoanNvbi5uYW1lID09PSBldmVudE5hbWUgfHwganNvbi5zaWduYXR1cmUgPT09ICcweCcgKyBldmVudE5hbWUucmVwbGFjZSgnMHgnLCAnJykpKTtcbiAgICB9KTtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHRocm93IGVycm9ycy5Db250cmFjdEV2ZW50RG9lc05vdEV4aXN0RXJyb3IoZXZlbnROYW1lKTtcbiAgICB9XG4gICAgaWYgKCF1dGlscy5pc0FkZHJlc3ModGhpcy5vcHRpb25zLmFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5Db250cmFjdE5vQWRkcmVzc0RlZmluZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbXM6IHRoaXMuX2VuY29kZUV2ZW50QUJJKGV2ZW50LCBvcHRpb25zKSxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xufTtcbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgYW5kIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24sIGFuZCByZW1vdmUgaXQgb25jZSBpdHMgZmlyZWQuXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZXZlbnQgc3Vic2NyaXB0aW9uXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5vcHRpb25zLmpzb25JbnRlcmZhY2UsIHRoaXMub3B0aW9ucy5hZGRyZXNzLCB0aGlzLm9wdGlvbnMpO1xufTtcbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgYW5kIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24sIGFuZCByZW1vdmUgaXQgb25jZSBpdHMgZmlyZWQuXG4gKlxuICogQG1ldGhvZCBvbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZXZlbnQgc3Vic2NyaXB0aW9uXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAvLyBnZXQgdGhlIGNhbGxiYWNrXG4gICAgY2FsbGJhY2sgPSB0aGlzLl9nZXRDYWxsYmFjayhhcmdzKTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5Db250cmFjdE9uY2VSZXF1aXJlc0NhbGxiYWNrRXJyb3IoKTtcbiAgICB9XG4gICAgLy8gZG9uJ3QgYWxsb3cgZnJvbUJsb2NrXG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmZyb21CbG9jaztcbiAgICAvLyBkb24ndCByZXR1cm4gYXMgb25jZSBzaG91bGRuJ3QgcHJvdmlkZSBcIm9uXCJcbiAgICB0aGlzLl9vbihldmVudCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcmVzLCBzdWIpIHtcbiAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzLCBzdWIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBjcmVhdGVzIGEgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEBtZXRob2QgX29uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBldmVudCBzdWJzY3JpcHRpb25cbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3ViT3B0aW9ucyA9IHRoaXMuX2dlbmVyYXRlRXZlbnRPcHRpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHN1Yk9wdGlvbnMucGFyYW1zICYmIHN1Yk9wdGlvbnMucGFyYW1zLnRvQmxvY2spIHtcbiAgICAgICAgZGVsZXRlIHN1Yk9wdGlvbnMucGFyYW1zLnRvQmxvY2s7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBvcHRpb246IHRvQmxvY2suIFVzZSBnZXRQYXN0RXZlbnRzIGZvciBzcGVjaWZpYyByYW5nZS4nKTtcbiAgICB9XG4gICAgLy8gcHJldmVudCB0aGUgZXZlbnQgXCJuZXdMaXN0ZW5lclwiIGFuZCBcInJlbW92ZUxpc3RlbmVyXCIgZnJvbSBiZWluZyBvdmVyd3JpdHRlblxuICAgIHRoaXMuX2NoZWNrTGlzdGVuZXIoJ25ld0xpc3RlbmVyJywgc3ViT3B0aW9ucy5ldmVudC5uYW1lKTtcbiAgICB0aGlzLl9jaGVja0xpc3RlbmVyKCdyZW1vdmVMaXN0ZW5lcicsIHN1Yk9wdGlvbnMuZXZlbnQubmFtZSk7XG4gICAgLy8gVE9ETyBjaGVjayBpZiBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cz8gYW5kIHJldXNlIHN1YnNjcmlwdGlvbiBpZiBvcHRpb25zIGFyZSB0aGUgc2FtZS5cbiAgICAvLyBjcmVhdGUgbmV3IHN1YnNjcmlwdGlvblxuICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRMb2dGb3JtYXR0ZXJdLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB0aGlzLl9kZWNvZGVFdmVudEFCSS5iaW5kKHN1Yk9wdGlvbnMuZXZlbnQpLFxuICAgICAgICAgICAgLy8gRFVCTElDQVRFLCBhbHNvIGluIHdlYjMtZXRoXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25IYW5kbGVyOiBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlZCcsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsLCBvdXRwdXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ2V0aCcsXG4gICAgICAgIHJlcXVlc3RNYW5hZ2VyOiB0aGlzLl9yZXF1ZXN0TWFuYWdlclxuICAgIH0pO1xuICAgIHN1YnNjcmlwdGlvbi5zdWJzY3JpYmUoJ2xvZ3MnLCBzdWJPcHRpb25zLnBhcmFtcywgc3ViT3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG59O1xuLyoqXG4gKiBHZXQgcGFzdCBldmVudHMgZnJvbSBjb250cmFjdHNcbiAqXG4gKiBAbWV0aG9kIGdldFBhc3RFdmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwcm9taWV2ZW50XG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5nZXRQYXN0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdWJPcHRpb25zID0gdGhpcy5fZ2VuZXJhdGVFdmVudE9wdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgZ2V0UGFzdExvZ3MgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFBhc3RMb2dzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRMb2dzJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRMb2dGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHRoaXMuX2RlY29kZUV2ZW50QUJJLmJpbmQoc3ViT3B0aW9ucy5ldmVudClcbiAgICB9KTtcbiAgICBnZXRQYXN0TG9ncy5zZXRSZXF1ZXN0TWFuYWdlcih0aGlzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgdmFyIGNhbGwgPSBnZXRQYXN0TG9ncy5idWlsZENhbGwoKTtcbiAgICBnZXRQYXN0TG9ncyA9IG51bGw7XG4gICAgcmV0dXJuIGNhbGwoc3ViT3B0aW9ucy5wYXJhbXMsIHN1Yk9wdGlvbnMuY2FsbGJhY2spO1xufTtcbi8qKlxuICogcmV0dXJucyB0aGUgYW4gb2JqZWN0IHdpdGggY2FsbCwgc2VuZCwgZXN0aW1hdGUgZnVuY3Rpb25zXG4gKlxuICogQG1ldGhvZCBfY3JlYXRlVHhPYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIGZ1bmN0aW9ucyB0byBjYWxsIHRoZSBtZXRob2RzXG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fY3JlYXRlVHhPYmplY3QgPSBmdW5jdGlvbiBfY3JlYXRlVHhPYmplY3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciB0eE9iamVjdCA9IHt9O1xuICAgIGlmICh0aGlzLm1ldGhvZC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHR4T2JqZWN0LmNhbGwgPSB0aGlzLnBhcmVudC5fZXhlY3V0ZU1ldGhvZC5iaW5kKHR4T2JqZWN0LCAnY2FsbCcpO1xuICAgICAgICB0eE9iamVjdC5jYWxsLnJlcXVlc3QgPSB0aGlzLnBhcmVudC5fZXhlY3V0ZU1ldGhvZC5iaW5kKHR4T2JqZWN0LCAnY2FsbCcsIHRydWUpOyAvLyB0byBtYWtlIGJhdGNoIHJlcXVlc3RzXG4gICAgfVxuICAgIHR4T2JqZWN0LnNlbmQgPSB0aGlzLnBhcmVudC5fZXhlY3V0ZU1ldGhvZC5iaW5kKHR4T2JqZWN0LCAnc2VuZCcpO1xuICAgIHR4T2JqZWN0LnNlbmQucmVxdWVzdCA9IHRoaXMucGFyZW50Ll9leGVjdXRlTWV0aG9kLmJpbmQodHhPYmplY3QsICdzZW5kJywgdHJ1ZSk7IC8vIHRvIG1ha2UgYmF0Y2ggcmVxdWVzdHNcbiAgICB0eE9iamVjdC5lbmNvZGVBQkkgPSB0aGlzLnBhcmVudC5fZW5jb2RlTWV0aG9kQUJJLmJpbmQodHhPYmplY3QpO1xuICAgIHR4T2JqZWN0LmVzdGltYXRlR2FzID0gdGhpcy5wYXJlbnQuX2V4ZWN1dGVNZXRob2QuYmluZCh0eE9iamVjdCwgJ2VzdGltYXRlJyk7XG4gICAgaWYgKGFyZ3MgJiYgdGhpcy5tZXRob2QuaW5wdXRzICYmIGFyZ3MubGVuZ3RoICE9PSB0aGlzLm1ldGhvZC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHRNZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRNZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWROdW1iZXJPZlBhcmFtcyhhcmdzLmxlbmd0aCwgdGhpcy5tZXRob2QuaW5wdXRzLmxlbmd0aCwgdGhpcy5tZXRob2QubmFtZSk7XG4gICAgfVxuICAgIHR4T2JqZWN0LmFyZ3VtZW50cyA9IGFyZ3MgfHwgW107XG4gICAgdHhPYmplY3QuX21ldGhvZCA9IHRoaXMubWV0aG9kO1xuICAgIHR4T2JqZWN0Ll9wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICB0eE9iamVjdC5fZXRoQWNjb3VudHMgPSB0aGlzLnBhcmVudC5jb25zdHJ1Y3Rvci5fZXRoQWNjb3VudHMgfHwgdGhpcy5fZXRoQWNjb3VudHM7XG4gICAgaWYgKHRoaXMuZGVwbG95RGF0YSkge1xuICAgICAgICB0eE9iamVjdC5fZGVwbG95RGF0YSA9IHRoaXMuZGVwbG95RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHR4T2JqZWN0O1xufTtcbi8qKlxuICogR2VuZXJhdGVzIHRoZSBvcHRpb25zIGZvciB0aGUgZXhlY3V0ZSBjYWxsXG4gKlxuICogQG1ldGhvZCBfcHJvY2Vzc0V4ZWN1dGVBcmd1bWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEBwYXJhbSB7UHJvbWlzZX0gZGVmZXJcbiAqL1xuQ29udHJhY3QucHJvdG90eXBlLl9wcm9jZXNzRXhlY3V0ZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIF9wcm9jZXNzRXhlY3V0ZUFyZ3VtZW50cyhhcmdzLCBkZWZlcikge1xuICAgIHZhciBwcm9jZXNzZWRBcmdzID0ge307XG4gICAgcHJvY2Vzc2VkQXJncy50eXBlID0gYXJncy5zaGlmdCgpO1xuICAgIC8vIGdldCB0aGUgY2FsbGJhY2tcbiAgICBwcm9jZXNzZWRBcmdzLmNhbGxiYWNrID0gdGhpcy5fcGFyZW50Ll9nZXRDYWxsYmFjayhhcmdzKTtcbiAgICAvLyBnZXQgYmxvY2sgbnVtYmVyIHRvIHVzZSBmb3IgY2FsbFxuICAgIGlmIChwcm9jZXNzZWRBcmdzLnR5cGUgPT09ICdjYWxsJyAmJiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gIT09IHRydWUgJiYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdzdHJpbmcnIHx8IGlzRmluaXRlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpKVxuICAgICAgICBwcm9jZXNzZWRBcmdzLmRlZmF1bHRCbG9jayA9IGFyZ3MucG9wKCk7XG4gICAgLy8gZ2V0IHRoZSBvcHRpb25zXG4gICAgcHJvY2Vzc2VkQXJncy5vcHRpb25zID0gKCEhYXJnc1thcmdzLmxlbmd0aCAtIDFdICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSAnb2JqZWN0JyA/IGFyZ3MucG9wKCkgOiB7fTtcbiAgICAvLyBnZXQgdGhlIGdlbmVyYXRlUmVxdWVzdCBhcmd1bWVudCBmb3IgYmF0Y2ggcmVxdWVzdHNcbiAgICBwcm9jZXNzZWRBcmdzLmdlbmVyYXRlUmVxdWVzdCA9IChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IHRydWUpID8gYXJncy5wb3AoKSA6IGZhbHNlO1xuICAgIHByb2Nlc3NlZEFyZ3Mub3B0aW9ucyA9IHRoaXMuX3BhcmVudC5fZ2V0T3JTZXREZWZhdWx0T3B0aW9ucyhwcm9jZXNzZWRBcmdzLm9wdGlvbnMpO1xuICAgIHByb2Nlc3NlZEFyZ3Mub3B0aW9ucy5kYXRhID0gdGhpcy5lbmNvZGVBQkkoKTtcbiAgICAvLyBhZGQgY29udHJhY3QgYWRkcmVzc1xuICAgIGlmICghdGhpcy5fZGVwbG95RGF0YSAmJiAhdXRpbHMuaXNBZGRyZXNzKHRoaXMuX3BhcmVudC5vcHRpb25zLmFkZHJlc3MpKVxuICAgICAgICB0aHJvdyBlcnJvcnMuQ29udHJhY3ROb0FkZHJlc3NEZWZpbmVkRXJyb3IoKTtcbiAgICBpZiAoIXRoaXMuX2RlcGxveURhdGEpXG4gICAgICAgIHByb2Nlc3NlZEFyZ3Mub3B0aW9ucy50byA9IHRoaXMuX3BhcmVudC5vcHRpb25zLmFkZHJlc3M7XG4gICAgLy8gcmV0dXJuIGVycm9yLCBpZiBubyBcImRhdGFcIiBpcyBzcGVjaWZpZWRcbiAgICBpZiAoIXByb2Nlc3NlZEFyZ3Mub3B0aW9ucy5kYXRhKVxuICAgICAgICByZXR1cm4gdXRpbHMuX2ZpcmVFcnJvcihuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgZmluZCBhIG1hdGNoaW5nIGNvbnRyYWN0IG1ldGhvZCwgb3IgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGlzIHdyb25nLicpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgcHJvY2Vzc2VkQXJncy5jYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb2Nlc3NlZEFyZ3M7XG59O1xuLyoqXG4gKiBFeGVjdXRlcyBhIGNhbGwsIHRyYW5zYWN0IG9yIGVzdGltYXRlR2FzIG9uIGEgY29udHJhY3QgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIF9leGVjdXRlTWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSB0aGlzIGV4ZWN1dGUgZnVuY3Rpb24gc2hvdWxkIGV4ZWN1dGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFrZVJlcXVlc3QgaWYgdHJ1ZSwgaXQgc2ltcGx5IHJldHVybnMgdGhlIHJlcXVlc3QgcGFyYW1ldGVycywgcmF0aGVyIHRoYW4gZXhlY3V0aW5nIGl0XG4gKi9cbkNvbnRyYWN0LnByb3RvdHlwZS5fZXhlY3V0ZU1ldGhvZCA9IGZ1bmN0aW9uIF9leGVjdXRlTWV0aG9kKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIGFyZ3MgPSB0aGlzLl9wYXJlbnQuX3Byb2Nlc3NFeGVjdXRlQXJndW1lbnRzLmNhbGwodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZGVmZXIpLCBkZWZlciA9IHByb21pRXZlbnQoKGFyZ3MudHlwZSAhPT0gJ3NlbmQnKSksIGV0aEFjY291bnRzID0gX3RoaXMuY29uc3RydWN0b3IuX2V0aEFjY291bnRzIHx8IF90aGlzLl9ldGhBY2NvdW50cztcbiAgICAvLyBzaW1wbGUgcmV0dXJuIHJlcXVlc3QgZm9yIGJhdGNoIHJlcXVlc3RzXG4gICAgaWYgKGFyZ3MuZ2VuZXJhdGVSZXF1ZXN0KSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgcGFyYW1zOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXIuY2FsbCh0aGlzLl9wYXJlbnQsIGFyZ3Mub3B0aW9ucyldLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGFyZ3MuY2FsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2NhbGwnKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnBhcmFtcy5wdXNoKGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIuY2FsbCh0aGlzLl9wYXJlbnQsIGFyZ3MuZGVmYXVsdEJsb2NrKSk7XG4gICAgICAgICAgICBwYXlsb2FkLm1ldGhvZCA9ICdldGhfY2FsbCc7XG4gICAgICAgICAgICBwYXlsb2FkLmZvcm1hdCA9IHRoaXMuX3BhcmVudC5fZGVjb2RlTWV0aG9kUmV0dXJuLmJpbmQobnVsbCwgdGhpcy5fbWV0aG9kLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC5tZXRob2QgPSAnZXRoX3NlbmRUcmFuc2FjdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIHN3aXRjaCAoYXJncy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2VzdGltYXRlJzpcbiAgICAgICAgICAgIHZhciBlc3RpbWF0ZUdhcyA9IChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXN0aW1hdGVHYXMnLFxuICAgICAgICAgICAgICAgIGNhbGw6ICdldGhfZXN0aW1hdGVHYXMnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRDYWxsRm9ybWF0dGVyXSxcbiAgICAgICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLmhleFRvTnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNYW5hZ2VyOiBfdGhpcy5fcGFyZW50Ll9yZXF1ZXN0TWFuYWdlcixcbiAgICAgICAgICAgICAgICBhY2NvdW50czogZXRoQWNjb3VudHMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQ6IF90aGlzLl9wYXJlbnQuZGVmYXVsdEFjY291bnQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEJsb2NrOiBfdGhpcy5fcGFyZW50LmRlZmF1bHRCbG9ja1xuICAgICAgICAgICAgfSkpLmNyZWF0ZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZXN0aW1hdGVHYXMoYXJncy5vcHRpb25zLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSAnY2FsbCc6XG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIGVycm9yczogbWlzc2luZyBcImZyb21cIiBzaG91bGQgZ2l2ZSBlcnJvciBvbiBkZXBsb3kgYW5kIHNlbmQsIGNhbGwgP1xuICAgICAgICAgICAgdmFyIGNhbGwgPSAobmV3IE1ldGhvZCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NhbGwnLFxuICAgICAgICAgICAgICAgIGNhbGw6ICdldGhfY2FsbCcsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICAgICAgICAgIC8vIGFkZCBvdXRwdXQgZm9ybWF0dGVyIGZvciBkZWNvZGluZ1xuICAgICAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3BhcmVudC5fZGVjb2RlTWV0aG9kUmV0dXJuKF90aGlzLl9tZXRob2Qub3V0cHV0cywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNYW5hZ2VyOiBfdGhpcy5fcGFyZW50Ll9yZXF1ZXN0TWFuYWdlcixcbiAgICAgICAgICAgICAgICBhY2NvdW50czogZXRoQWNjb3VudHMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQ6IF90aGlzLl9wYXJlbnQuZGVmYXVsdEFjY291bnQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEJsb2NrOiBfdGhpcy5fcGFyZW50LmRlZmF1bHRCbG9jayxcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXZlcnQ6IF90aGlzLl9wYXJlbnQuaGFuZGxlUmV2ZXJ0LFxuICAgICAgICAgICAgICAgIGFiaUNvZGVyOiBhYmlcbiAgICAgICAgICAgIH0pKS5jcmVhdGVGdW5jdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGwoYXJncy5vcHRpb25zLCBhcmdzLmRlZmF1bHRCbG9jaywgYXJncy5jYWxsYmFjayk7XG4gICAgICAgIGNhc2UgJ3NlbmQnOlxuICAgICAgICAgICAgLy8gcmV0dXJuIGVycm9yLCBpZiBubyBcImZyb21cIiBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNBZGRyZXNzKGFyZ3Mub3B0aW9ucy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5Db250cmFjdE5vRnJvbUFkZHJlc3NEZWZpbmVkRXJyb3IoKSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9tZXRob2QucGF5YWJsZSA9PT0gJ2Jvb2xlYW4nICYmICF0aGlzLl9tZXRob2QucGF5YWJsZSAmJiBhcmdzLm9wdGlvbnMudmFsdWUgJiYgYXJncy5vcHRpb25zLnZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5fZmlyZUVycm9yKG5ldyBFcnJvcignQ2FuIG5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGNvbnRyYWN0IG1ldGhvZCBvciBjb25zdHJ1Y3RvcicpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgYXJncy5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgcmVjZWlwdCBsb2dzIGFyZSBkZWNvZGVkXG4gICAgICAgICAgICB2YXIgZXh0cmFGb3JtYXR0ZXJzID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpcHRGb3JtYXR0ZXI6IGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY2VpcHQubG9ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY29kZSBsb2dzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gcmVjZWlwdC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wYXJlbnQuX2RlY29kZUV2ZW50QUJJLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQUxMRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkludGVyZmFjZTogX3RoaXMuX3BhcmVudC5vcHRpb25zLmpzb25JbnRlcmZhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBsb2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGxvZyBuYW1lcyBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmV2ZW50cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiA+IDEgb2YgdGhlIHNhbWUgZXZlbnQsIGRvbid0IG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LmV2ZW50c1tldi5ldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY2VpcHQuZXZlbnRzW2V2LmV2ZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmV2ZW50c1tldi5ldmVudF0ucHVzaChldik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmV2ZW50c1tldi5ldmVudF0gPSBbcmVjZWlwdC5ldmVudHNbZXYuZXZlbnRdLCBldl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmV2ZW50c1tldi5ldmVudF0gPSBldjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5ldmVudHNbY291bnRdID0gZXY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVjZWlwdC5sb2dzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29udHJhY3REZXBsb3lGb3JtYXR0ZXI6IGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb250cmFjdCA9IF90aGlzLl9wYXJlbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJhY3Qub3B0aW9ucy5hZGRyZXNzID0gcmVjZWlwdC5jb250cmFjdEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb250cmFjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNlbmRUcmFuc2FjdGlvbiA9IChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBjYWxsOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0TWFuYWdlcjogX3RoaXMuX3BhcmVudC5fcmVxdWVzdE1hbmFnZXIsXG4gICAgICAgICAgICAgICAgYWNjb3VudHM6IF90aGlzLmNvbnN0cnVjdG9yLl9ldGhBY2NvdW50cyB8fCBfdGhpcy5fZXRoQWNjb3VudHMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQ6IF90aGlzLl9wYXJlbnQuZGVmYXVsdEFjY291bnQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEJsb2NrOiBfdGhpcy5fcGFyZW50LmRlZmF1bHRCbG9jayxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkJsb2NrVGltZW91dDogX3RoaXMuX3BhcmVudC50cmFuc2FjdGlvbkJsb2NrVGltZW91dCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrczogX3RoaXMuX3BhcmVudC50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0OiBfdGhpcy5fcGFyZW50LnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbW1vbjogX3RoaXMuX3BhcmVudC5kZWZhdWx0Q29tbW9uLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRDaGFpbjogX3RoaXMuX3BhcmVudC5kZWZhdWx0Q2hhaW4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdEhhcmRmb3JrOiBfdGhpcy5fcGFyZW50LmRlZmF1bHRIYXJkZm9yayxcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXZlcnQ6IF90aGlzLl9wYXJlbnQuaGFuZGxlUmV2ZXJ0LFxuICAgICAgICAgICAgICAgIGV4dHJhRm9ybWF0dGVyczogZXh0cmFGb3JtYXR0ZXJzLFxuICAgICAgICAgICAgICAgIGFiaUNvZGVyOiBhYmlcbiAgICAgICAgICAgIH0pKS5jcmVhdGVGdW5jdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbmRUcmFuc2FjdGlvbihhcmdzLm9wdGlvbnMsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgXCInICsgYXJncy50eXBlICsgJ1wiIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb250cmFjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-contract/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/ENS.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/ENS.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file ENS.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2018\n */\n\nvar config = __webpack_require__(/*! ./config */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/config.js\");\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar Registry = __webpack_require__(/*! ./contracts/Registry */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/contracts/Registry.js\");\nvar ResolverMethodHandler = __webpack_require__(/*! ./lib/ResolverMethodHandler */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/ResolverMethodHandler.js\");\nvar contenthash = __webpack_require__(/*! ./lib/contentHash */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/contentHash.js\");\n/**\n * Constructs a new instance of ENS\n *\n * @param {Eth} eth\n *\n * @constructor\n */\nfunction ENS(eth) {\n    this.eth = eth;\n    var registryAddress = null;\n    this._detectedAddress = null;\n    this._lastSyncCheck = null;\n    Object.defineProperty(this, 'registry', {\n        get: function () {\n            return new Registry(this);\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'resolverMethodHandler', {\n        get: function () {\n            return new ResolverMethodHandler(this.registry);\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'registryAddress', {\n        get: function () {\n            return registryAddress;\n        },\n        set: function (value) {\n            if (value === null) {\n                registryAddress = value;\n                return;\n            }\n            registryAddress = formatters.inputAddressFormatter(value);\n        },\n        enumerable: true\n    });\n}\n/**\n * Returns true if the given interfaceId is supported and otherwise false.\n *\n * @method supportsInterface\n *\n * @param {string} name\n * @param {string} interfaceId\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\nENS.prototype.supportsInterface = function (name, interfaceId, callback) {\n    return this.getResolver(name).then(function (resolver) {\n        if (!utils.isHexStrict(interfaceId)) {\n            interfaceId = utils.sha3(interfaceId).slice(0, 10);\n        }\n        return resolver.methods.supportsInterface(interfaceId).call(callback);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        throw error;\n    });\n};\n/**\n * Returns the Resolver by the given address\n *\n * @deprecated Please use the \"getResolver\" method instead of \"resolver\"\n *\n * @method resolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\nENS.prototype.resolver = function (name, callback) {\n    return this.registry.resolver(name, callback);\n};\n/**\n * Returns the Resolver by the given address\n *\n * @method getResolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\nENS.prototype.getResolver = function (name, callback) {\n    return this.registry.getResolver(name, callback);\n};\n/**\n * Does set the resolver of the given name\n *\n * @method setResolver\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setResolver = function (name, address, txConfig, callback) {\n    return this.registry.setResolver(name, address, txConfig, callback);\n};\n/**\n * Sets the owner, resolver, and TTL for an ENS record in a single operation.\n *\n * @method setRecord\n *\n * @param {string} name\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setRecord = function (name, owner, resolver, ttl, txConfig, callback) {\n    return this.registry.setRecord(name, owner, resolver, ttl, txConfig, callback);\n};\n/**\n * Sets the owner, resolver and TTL for a subdomain, creating it if necessary.\n *\n * @method setSubnodeRecord\n *\n * @param {string} name\n * @param {string} label\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setSubnodeRecord = function (name, label, owner, resolver, ttl, txConfig, callback) {\n    return this.registry.setSubnodeRecord(name, label, owner, resolver, ttl, txConfig, callback);\n};\n/**\n * Sets or clears an approval by the given operator.\n *\n * @method setApprovalForAll\n *\n * @param {string} operator\n * @param {boolean} approved\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setApprovalForAll = function (operator, approved, txConfig, callback) {\n    return this.registry.setApprovalForAll(operator, approved, txConfig, callback);\n};\n/**\n * Returns true if the operator is approved\n *\n * @method isApprovedForAll\n *\n * @param {string} owner\n * @param {string} operator\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\nENS.prototype.isApprovedForAll = function (owner, operator, callback) {\n    return this.registry.isApprovedForAll(owner, operator, callback);\n};\n/**\n * Returns true if the record exists\n *\n * @method recordExists\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\nENS.prototype.recordExists = function (name, callback) {\n    return this.registry.recordExists(name, callback);\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setSubnodeOwner\n *\n * @param {string} name\n * @param {string} label\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setSubnodeOwner = function (name, label, address, txConfig, callback) {\n    return this.registry.setSubnodeOwner(name, label, address, txConfig, callback);\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method getTTL\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.getTTL = function (name, callback) {\n    return this.registry.getTTL(name, callback);\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setTTL\n *\n * @param {string} name\n * @param {number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setTTL = function (name, ttl, txConfig, callback) {\n    return this.registry.setTTL(name, ttl, txConfig, callback);\n};\n/**\n * Returns the owner by the given name and current configured or detected Registry\n *\n * @method getOwner\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.getOwner = function (name, callback) {\n    return this.registry.getOwner(name, callback);\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setOwner\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setOwner = function (name, address, txConfig, callback) {\n    return this.registry.setOwner(name, address, txConfig, callback);\n};\n/**\n * Returns the address record associated with a name.\n *\n * @method getAddress\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.getAddress = function (name, callback) {\n    return this.resolverMethodHandler.method(name, 'addr', []).call(callback);\n};\n/**\n * Sets a new address\n *\n * @method setAddress\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setAddress = function (name, address, txConfig, callback) {\n    return this.resolverMethodHandler.method(name, 'setAddr', [address]).send(txConfig, callback);\n};\n/**\n * Returns the public key\n *\n * @method getPubkey\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.getPubkey = function (name, callback) {\n    return this.resolverMethodHandler.method(name, 'pubkey', [], null, callback).call(callback);\n};\n/**\n * Set the new public key\n *\n * @method setPubkey\n *\n * @param {string} name\n * @param {string} x\n * @param {string} y\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setPubkey = function (name, x, y, txConfig, callback) {\n    return this.resolverMethodHandler.method(name, 'setPubkey', [x, y]).send(txConfig, callback);\n};\n/**\n * Returns the content\n *\n * @method getContent\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.getContent = function (name, callback) {\n    return this.resolverMethodHandler.method(name, 'content', []).call(callback);\n};\n/**\n * Set the content\n *\n * @method setContent\n *\n * @param {string} name\n * @param {string} hash\n * @param {function} callback\n * @param {TransactionConfig} txConfig\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setContent = function (name, hash, txConfig, callback) {\n    return this.resolverMethodHandler.method(name, 'setContent', [hash]).send(txConfig, callback);\n};\n/**\n * Returns the contenthash\n *\n * @method getContenthash\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<ContentHash>}\n */\nENS.prototype.getContenthash = function (name, callback) {\n    return this.resolverMethodHandler.method(name, 'contenthash', [], contenthash.decode).call(callback);\n};\n/**\n * Set the contenthash\n *\n * @method setContent\n *\n * @param {string} name\n * @param {string} hash\n * @param {function} callback\n * @param {TransactionConfig} txConfig\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setContenthash = function (name, hash, txConfig, callback) {\n    var encoded;\n    try {\n        encoded = contenthash.encode(hash);\n    }\n    catch (err) {\n        var error = new Error('Could not encode ' + hash + '. See docs for supported hash protocols.');\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        throw error;\n    }\n    return this.resolverMethodHandler.method(name, 'setContenthash', [encoded]).send(txConfig, callback);\n};\n/**\n * Get the multihash\n *\n * @method getMultihash\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.getMultihash = function (name, callback) {\n    return this.resolverMethodHandler.method(name, 'multihash', []).call(callback);\n};\n/**\n * Set the multihash\n *\n * @method setMultihash\n *\n * @param {string} name\n * @param {string} hash\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nENS.prototype.setMultihash = function (name, hash, txConfig, callback) {\n    return this.resolverMethodHandler.method(name, 'multihash', [hash]).send(txConfig, callback);\n};\n/**\n * Checks if the current used network is synced and looks for ENS support there.\n * Throws an error if not.\n *\n * @returns {Promise<string>}\n */\nENS.prototype.checkNetwork = async function () {\n    var now = new Date() / 1000;\n    if (!this._lastSyncCheck || (now - this._lastSyncCheck) > 3600) {\n        var block = await this.eth.getBlock('latest');\n        var headAge = now - block.timestamp;\n        if (headAge > 3600) {\n            throw new Error(\"Network not synced; last block was \" + headAge + \" seconds ago\");\n        }\n        this._lastSyncCheck = now;\n    }\n    if (this.registryAddress) {\n        return this.registryAddress;\n    }\n    if (!this._detectedAddress) {\n        var networkType = await this.eth.net.getNetworkType();\n        var addr = config.addresses[networkType];\n        if (typeof addr === 'undefined') {\n            throw new Error(\"ENS is not supported on network \" + networkType);\n        }\n        this._detectedAddress = addr;\n        return this._detectedAddress;\n    }\n    return this._detectedAddress;\n};\nmodule.exports = ENS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9FTlMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLCtGQUFVO0FBQy9CLGlCQUFpQiw4SUFBdUM7QUFDeEQsWUFBWSxtQkFBTyxDQUFDLDhGQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyx1SEFBc0I7QUFDN0MsNEJBQTRCLG1CQUFPLENBQUMscUlBQTZCO0FBQ2pFLGtCQUFrQixtQkFBTyxDQUFDLGlIQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWVucy9saWIvRU5TLmpzP2Q0MGQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgRU5TLmpzXG4gKlxuICogQGF1dGhvciBTYW11ZWwgRnVydGVyIDxzYW11ZWxAZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxOFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmZvcm1hdHRlcnM7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgUmVnaXN0cnkgPSByZXF1aXJlKCcuL2NvbnRyYWN0cy9SZWdpc3RyeScpO1xudmFyIFJlc29sdmVyTWV0aG9kSGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL1Jlc29sdmVyTWV0aG9kSGFuZGxlcicpO1xudmFyIGNvbnRlbnRoYXNoID0gcmVxdWlyZSgnLi9saWIvY29udGVudEhhc2gnKTtcbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiBFTlNcbiAqXG4gKiBAcGFyYW0ge0V0aH0gZXRoXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEVOUyhldGgpIHtcbiAgICB0aGlzLmV0aCA9IGV0aDtcbiAgICB2YXIgcmVnaXN0cnlBZGRyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9kZXRlY3RlZEFkZHJlc3MgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RTeW5jQ2hlY2sgPSBudWxsO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVnaXN0cnknLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdpc3RyeSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzb2x2ZXJNZXRob2RIYW5kbGVyJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXJNZXRob2RIYW5kbGVyKHRoaXMucmVnaXN0cnkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWdpc3RyeUFkZHJlc3MnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5QWRkcmVzcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJ5QWRkcmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2lzdHJ5QWRkcmVzcyA9IGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGludGVyZmFjZUlkIGlzIHN1cHBvcnRlZCBhbmQgb3RoZXJ3aXNlIGZhbHNlLlxuICpcbiAqIEBtZXRob2Qgc3VwcG9ydHNJbnRlcmZhY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGludGVyZmFjZUlkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gKi9cbkVOUy5wcm90b3R5cGUuc3VwcG9ydHNJbnRlcmZhY2UgPSBmdW5jdGlvbiAobmFtZSwgaW50ZXJmYWNlSWQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCF1dGlscy5pc0hleFN0cmljdChpbnRlcmZhY2VJZCkpIHtcbiAgICAgICAgICAgIGludGVyZmFjZUlkID0gdXRpbHMuc2hhMyhpbnRlcmZhY2VJZCkuc2xpY2UoMCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlci5tZXRob2RzLnN1cHBvcnRzSW50ZXJmYWNlKGludGVyZmFjZUlkKS5jYWxsKGNhbGxiYWNrKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgUmVzb2x2ZXIgYnkgdGhlIGdpdmVuIGFkZHJlc3NcbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIHRoZSBcImdldFJlc29sdmVyXCIgbWV0aG9kIGluc3RlYWQgb2YgXCJyZXNvbHZlclwiXG4gKlxuICogQG1ldGhvZCByZXNvbHZlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pc2U8Q29udHJhY3Q+fVxuICovXG5FTlMucHJvdG90eXBlLnJlc29sdmVyID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkucmVzb2x2ZXIobmFtZSwgY2FsbGJhY2spO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgUmVzb2x2ZXIgYnkgdGhlIGdpdmVuIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGdldFJlc29sdmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxDb250cmFjdD59XG4gKi9cbkVOUy5wcm90b3R5cGUuZ2V0UmVzb2x2ZXIgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5nZXRSZXNvbHZlcihuYW1lLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBEb2VzIHNldCB0aGUgcmVzb2x2ZXIgb2YgdGhlIGdpdmVuIG5hbWVcbiAqXG4gKiBAbWV0aG9kIHNldFJlc29sdmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cbkVOUy5wcm90b3R5cGUuc2V0UmVzb2x2ZXIgPSBmdW5jdGlvbiAobmFtZSwgYWRkcmVzcywgdHhDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuc2V0UmVzb2x2ZXIobmFtZSwgYWRkcmVzcywgdHhDb25maWcsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFNldHMgdGhlIG93bmVyLCByZXNvbHZlciwgYW5kIFRUTCBmb3IgYW4gRU5TIHJlY29yZCBpbiBhIHNpbmdsZSBvcGVyYXRpb24uXG4gKlxuICogQG1ldGhvZCBzZXRSZWNvcmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IG93bmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzb2x2ZXJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSB0dGxcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHR4Q29uZmlnXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pRXZlbnQ8VHJhbnNhY3Rpb25SZWNlaXB0IHwgVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yPn1cbiAqL1xuRU5TLnByb3RvdHlwZS5zZXRSZWNvcmQgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIsIHJlc29sdmVyLCB0dGwsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnNldFJlY29yZChuYW1lLCBvd25lciwgcmVzb2x2ZXIsIHR0bCwgdHhDb25maWcsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFNldHMgdGhlIG93bmVyLCByZXNvbHZlciBhbmQgVFRMIGZvciBhIHN1YmRvbWFpbiwgY3JlYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2Qgc2V0U3Vibm9kZVJlY29yZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBvd25lclxuICogQHBhcmFtIHtzdHJpbmd9IHJlc29sdmVyXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gdHRsXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cbkVOUy5wcm90b3R5cGUuc2V0U3Vibm9kZVJlY29yZCA9IGZ1bmN0aW9uIChuYW1lLCBsYWJlbCwgb3duZXIsIHJlc29sdmVyLCB0dGwsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnNldFN1Ym5vZGVSZWNvcmQobmFtZSwgbGFiZWwsIG93bmVyLCByZXNvbHZlciwgdHRsLCB0eENvbmZpZywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogU2V0cyBvciBjbGVhcnMgYW4gYXBwcm92YWwgYnkgdGhlIGdpdmVuIG9wZXJhdG9yLlxuICpcbiAqIEBtZXRob2Qgc2V0QXBwcm92YWxGb3JBbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXBwcm92ZWRcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHR4Q29uZmlnXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pRXZlbnQ8VHJhbnNhY3Rpb25SZWNlaXB0IHwgVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yPn1cbiAqL1xuRU5TLnByb3RvdHlwZS5zZXRBcHByb3ZhbEZvckFsbCA9IGZ1bmN0aW9uIChvcGVyYXRvciwgYXBwcm92ZWQsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnNldEFwcHJvdmFsRm9yQWxsKG9wZXJhdG9yLCBhcHByb3ZlZCwgdHhDb25maWcsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb3BlcmF0b3IgaXMgYXBwcm92ZWRcbiAqXG4gKiBAbWV0aG9kIGlzQXBwcm92ZWRGb3JBbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3duZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICovXG5FTlMucHJvdG90eXBlLmlzQXBwcm92ZWRGb3JBbGwgPSBmdW5jdGlvbiAob3duZXIsIG9wZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmlzQXBwcm92ZWRGb3JBbGwob3duZXIsIG9wZXJhdG9yLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlY29yZCBleGlzdHNcbiAqXG4gKiBAbWV0aG9kIHJlY29yZEV4aXN0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gKi9cbkVOUy5wcm90b3R5cGUucmVjb3JkRXhpc3RzID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkucmVjb3JkRXhpc3RzKG5hbWUsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIG93bmVyIG9mIGFuIEVOUyBuYW1lLlxuICpcbiAqIEBtZXRob2Qgc2V0U3Vibm9kZU93bmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHR4Q29uZmlnXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pRXZlbnQ8VHJhbnNhY3Rpb25SZWNlaXB0IHwgVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yPn1cbiAqL1xuRU5TLnByb3RvdHlwZS5zZXRTdWJub2RlT3duZXIgPSBmdW5jdGlvbiAobmFtZSwgbGFiZWwsIGFkZHJlc3MsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnNldFN1Ym5vZGVPd25lcihuYW1lLCBsYWJlbCwgYWRkcmVzcywgdHhDb25maWcsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIG93bmVyIG9mIGFuIEVOUyBuYW1lLlxuICpcbiAqIEBtZXRob2QgZ2V0VFRMXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5FTlMucHJvdG90eXBlLmdldFRUTCA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmdldFRUTChuYW1lLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBvd25lciBvZiBhbiBFTlMgbmFtZS5cbiAqXG4gKiBAbWV0aG9kIHNldFRUTFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gdHRsXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cbkVOUy5wcm90b3R5cGUuc2V0VFRMID0gZnVuY3Rpb24gKG5hbWUsIHR0bCwgdHhDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuc2V0VFRMKG5hbWUsIHR0bCwgdHhDb25maWcsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIG93bmVyIGJ5IHRoZSBnaXZlbiBuYW1lIGFuZCBjdXJyZW50IGNvbmZpZ3VyZWQgb3IgZGV0ZWN0ZWQgUmVnaXN0cnlcbiAqXG4gKiBAbWV0aG9kIGdldE93bmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5FTlMucHJvdG90eXBlLmdldE93bmVyID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0T3duZXIobmFtZSwgY2FsbGJhY2spO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgb3duZXIgb2YgYW4gRU5TIG5hbWUuXG4gKlxuICogQG1ldGhvZCBzZXRPd25lclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHhDb25maWdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5FTlMucHJvdG90eXBlLnNldE93bmVyID0gZnVuY3Rpb24gKG5hbWUsIGFkZHJlc3MsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnNldE93bmVyKG5hbWUsIGFkZHJlc3MsIHR4Q29uZmlnLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhZGRyZXNzIHJlY29yZCBhc3NvY2lhdGVkIHdpdGggYSBuYW1lLlxuICpcbiAqIEBtZXRob2QgZ2V0QWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pRXZlbnQ8VHJhbnNhY3Rpb25SZWNlaXB0IHwgVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yPn1cbiAqL1xuRU5TLnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJNZXRob2RIYW5kbGVyLm1ldGhvZChuYW1lLCAnYWRkcicsIFtdKS5jYWxsKGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFNldHMgYSBuZXcgYWRkcmVzc1xuICpcbiAqIEBtZXRob2Qgc2V0QWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHhDb25maWdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5FTlMucHJvdG90eXBlLnNldEFkZHJlc3MgPSBmdW5jdGlvbiAobmFtZSwgYWRkcmVzcywgdHhDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJNZXRob2RIYW5kbGVyLm1ldGhvZChuYW1lLCAnc2V0QWRkcicsIFthZGRyZXNzXSkuc2VuZCh0eENvbmZpZywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcHVibGljIGtleVxuICpcbiAqIEBtZXRob2QgZ2V0UHVia2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5FTlMucHJvdG90eXBlLmdldFB1YmtleSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVyTWV0aG9kSGFuZGxlci5tZXRob2QobmFtZSwgJ3B1YmtleScsIFtdLCBudWxsLCBjYWxsYmFjaykuY2FsbChjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBTZXQgdGhlIG5ldyBwdWJsaWMga2V5XG4gKlxuICogQG1ldGhvZCBzZXRQdWJrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHhcbiAqIEBwYXJhbSB7c3RyaW5nfSB5XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cbkVOUy5wcm90b3R5cGUuc2V0UHVia2V5ID0gZnVuY3Rpb24gKG5hbWUsIHgsIHksIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVyTWV0aG9kSGFuZGxlci5tZXRob2QobmFtZSwgJ3NldFB1YmtleScsIFt4LCB5XSkuc2VuZCh0eENvbmZpZywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY29udGVudFxuICpcbiAqIEBtZXRob2QgZ2V0Q29udGVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pRXZlbnQ8VHJhbnNhY3Rpb25SZWNlaXB0IHwgVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yPn1cbiAqL1xuRU5TLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJNZXRob2RIYW5kbGVyLm1ldGhvZChuYW1lLCAnY29udGVudCcsIFtdKS5jYWxsKGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFNldCB0aGUgY29udGVudFxuICpcbiAqIEBtZXRob2Qgc2V0Q29udGVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHR4Q29uZmlnXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5FTlMucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAobmFtZSwgaGFzaCwgdHhDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJNZXRob2RIYW5kbGVyLm1ldGhvZChuYW1lLCAnc2V0Q29udGVudCcsIFtoYXNoXSkuc2VuZCh0eENvbmZpZywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY29udGVudGhhc2hcbiAqXG4gKiBAbWV0aG9kIGdldENvbnRlbnRoYXNoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxDb250ZW50SGFzaD59XG4gKi9cbkVOUy5wcm90b3R5cGUuZ2V0Q29udGVudGhhc2ggPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlck1ldGhvZEhhbmRsZXIubWV0aG9kKG5hbWUsICdjb250ZW50aGFzaCcsIFtdLCBjb250ZW50aGFzaC5kZWNvZGUpLmNhbGwoY2FsbGJhY2spO1xufTtcbi8qKlxuICogU2V0IHRoZSBjb250ZW50aGFzaFxuICpcbiAqIEBtZXRob2Qgc2V0Q29udGVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHR4Q29uZmlnXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5FTlMucHJvdG90eXBlLnNldENvbnRlbnRoYXNoID0gZnVuY3Rpb24gKG5hbWUsIGhhc2gsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciBlbmNvZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIGVuY29kZWQgPSBjb250ZW50aGFzaC5lbmNvZGUoaGFzaCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgZW5jb2RlICcgKyBoYXNoICsgJy4gU2VlIGRvY3MgZm9yIHN1cHBvcnRlZCBoYXNoIHByb3RvY29scy4nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlck1ldGhvZEhhbmRsZXIubWV0aG9kKG5hbWUsICdzZXRDb250ZW50aGFzaCcsIFtlbmNvZGVkXSkuc2VuZCh0eENvbmZpZywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogR2V0IHRoZSBtdWx0aWhhc2hcbiAqXG4gKiBAbWV0aG9kIGdldE11bHRpaGFzaFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pRXZlbnQ8VHJhbnNhY3Rpb25SZWNlaXB0IHwgVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yPn1cbiAqL1xuRU5TLnByb3RvdHlwZS5nZXRNdWx0aWhhc2ggPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlck1ldGhvZEhhbmRsZXIubWV0aG9kKG5hbWUsICdtdWx0aWhhc2gnLCBbXSkuY2FsbChjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBTZXQgdGhlIG11bHRpaGFzaFxuICpcbiAqIEBtZXRob2Qgc2V0TXVsdGloYXNoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cbkVOUy5wcm90b3R5cGUuc2V0TXVsdGloYXNoID0gZnVuY3Rpb24gKG5hbWUsIGhhc2gsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVyTWV0aG9kSGFuZGxlci5tZXRob2QobmFtZSwgJ211bHRpaGFzaCcsIFtoYXNoXSkuc2VuZCh0eENvbmZpZywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHVzZWQgbmV0d29yayBpcyBzeW5jZWQgYW5kIGxvb2tzIGZvciBFTlMgc3VwcG9ydCB0aGVyZS5cbiAqIFRocm93cyBhbiBlcnJvciBpZiBub3QuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAqL1xuRU5TLnByb3RvdHlwZS5jaGVja05ldHdvcmsgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkgLyAxMDAwO1xuICAgIGlmICghdGhpcy5fbGFzdFN5bmNDaGVjayB8fCAobm93IC0gdGhpcy5fbGFzdFN5bmNDaGVjaykgPiAzNjAwKSB7XG4gICAgICAgIHZhciBibG9jayA9IGF3YWl0IHRoaXMuZXRoLmdldEJsb2NrKCdsYXRlc3QnKTtcbiAgICAgICAgdmFyIGhlYWRBZ2UgPSBub3cgLSBibG9jay50aW1lc3RhbXA7XG4gICAgICAgIGlmIChoZWFkQWdlID4gMzYwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV0d29yayBub3Qgc3luY2VkOyBsYXN0IGJsb2NrIHdhcyBcIiArIGhlYWRBZ2UgKyBcIiBzZWNvbmRzIGFnb1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U3luY0NoZWNrID0gbm93O1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWdpc3RyeUFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnlBZGRyZXNzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RldGVjdGVkQWRkcmVzcykge1xuICAgICAgICB2YXIgbmV0d29ya1R5cGUgPSBhd2FpdCB0aGlzLmV0aC5uZXQuZ2V0TmV0d29ya1R5cGUoKTtcbiAgICAgICAgdmFyIGFkZHIgPSBjb25maWcuYWRkcmVzc2VzW25ldHdvcmtUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRU5TIGlzIG5vdCBzdXBwb3J0ZWQgb24gbmV0d29yayBcIiArIG5ldHdvcmtUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZXRlY3RlZEFkZHJlc3MgPSBhZGRyO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGV0ZWN0ZWRBZGRyZXNzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGV0ZWN0ZWRBZGRyZXNzO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRU5TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/ENS.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/config.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/config.js ***!
  \*************************************************************************************/
/***/ (function(module) {

"use strict";
eval("/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file config.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2017\n */\n\n/**\n * Source: https://docs.ens.domains/ens-deployments\n *\n * @type {{addresses: {main: string, rinkeby: string, goerli: string, ropsten: string}}}\n */\nvar config = {\n    addresses: {\n        main: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        ropsten: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        rinkeby: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        goerli: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\"\n    },\n    // These ids obtained at ensdomains docs:\n    // https://docs.ens.domains/contract-developer-guide/writing-a-resolver\n    interfaceIds: {\n        addr: \"0x3b3b57de\",\n        setAddr: \"0x3b3b57de\",\n        pubkey: \"0xc8690233\",\n        setPubkey: \"0xc8690233\",\n        contenthash: \"0xbc1c58d1\",\n        setContenthash: \"0xbc1c58d1\",\n        content: \"0xd8389dc5\",\n        setContent: \"0xd8389dc5\"\n    }\n};\nmodule.exports = config;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9jb25maWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWVucy9saWIvY29uZmlnLmpzPzhlMWIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgY29uZmlnLmpzXG4gKlxuICogQGF1dGhvciBTYW11ZWwgRnVydGVyIDxzYW11ZWxAZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogU291cmNlOiBodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvZW5zLWRlcGxveW1lbnRzXG4gKlxuICogQHR5cGUge3thZGRyZXNzZXM6IHttYWluOiBzdHJpbmcsIHJpbmtlYnk6IHN0cmluZywgZ29lcmxpOiBzdHJpbmcsIHJvcHN0ZW46IHN0cmluZ319fVxuICovXG52YXIgY29uZmlnID0ge1xuICAgIGFkZHJlc3Nlczoge1xuICAgICAgICBtYWluOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICByb3BzdGVuOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICByaW5rZWJ5OiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBnb2VybGk6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCJcbiAgICB9LFxuICAgIC8vIFRoZXNlIGlkcyBvYnRhaW5lZCBhdCBlbnNkb21haW5zIGRvY3M6XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL2NvbnRyYWN0LWRldmVsb3Blci1ndWlkZS93cml0aW5nLWEtcmVzb2x2ZXJcbiAgICBpbnRlcmZhY2VJZHM6IHtcbiAgICAgICAgYWRkcjogXCIweDNiM2I1N2RlXCIsXG4gICAgICAgIHNldEFkZHI6IFwiMHgzYjNiNTdkZVwiLFxuICAgICAgICBwdWJrZXk6IFwiMHhjODY5MDIzM1wiLFxuICAgICAgICBzZXRQdWJrZXk6IFwiMHhjODY5MDIzM1wiLFxuICAgICAgICBjb250ZW50aGFzaDogXCIweGJjMWM1OGQxXCIsXG4gICAgICAgIHNldENvbnRlbnRoYXNoOiBcIjB4YmMxYzU4ZDFcIixcbiAgICAgICAgY29udGVudDogXCIweGQ4Mzg5ZGM1XCIsXG4gICAgICAgIHNldENvbnRlbnQ6IFwiMHhkODM4OWRjNVwiXG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/config.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/contracts/Registry.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/contracts/Registry.js ***!
  \*************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file Registry.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2018\n */\n\nvar Contract = __webpack_require__(/*! web3-eth-contract */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-contract/lib/index.js\");\nvar namehash = __webpack_require__(/*! eth-ens-namehash */ \"../../node_modules/eth-ens-namehash/index.js\");\nvar PromiEvent = __webpack_require__(/*! web3-core-promievent */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/lib/index.js\");\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar REGISTRY_ABI = __webpack_require__(/*! ../resources/ABI/Registry */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Registry.js\");\nvar RESOLVER_ABI = __webpack_require__(/*! ../resources/ABI/Resolver */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Resolver.js\");\n/**\n * A wrapper around the ENS registry contract.\n *\n * @method Registry\n * @param {Ens} ens\n * @constructor\n */\nfunction Registry(ens) {\n    var self = this;\n    this.ens = ens;\n    this.contract = ens.checkNetwork().then(function (address) {\n        var contract = new Contract(REGISTRY_ABI, address);\n        contract.setProvider(self.ens.eth.currentProvider);\n        return contract;\n    });\n}\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @deprecated Please use the \"getOwner\" method instead of \"owner\"\n *\n * @method owner\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<string>}\n */\nRegistry.prototype.owner = function (name, callback) {\n    console.warn('Deprecated: Please use the \"getOwner\" method instead of \"owner\".');\n    return this.getOwner(name, callback);\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method getOwner\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<string>}\n */\nRegistry.prototype.getOwner = function (name, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.owner(namehash.hash(name)).call();\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setOwner\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setOwner = function (name, address, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.setOwner(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Returns the TTL of the given node by his name\n *\n * @method getTTL\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returnss {Promise<string>}\n */\nRegistry.prototype.getTTL = function (name, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.ttl(namehash.hash(name)).call();\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setTTL\n *\n * @param {string} name\n * @param {number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setTTL = function (name, ttl, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.setTTL(namehash.hash(name), ttl).send(txConfig);\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setSubnodeOwner\n *\n * @param {string} name\n * @param {string} label\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setSubnodeOwner = function (name, label, address, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n    if (!utils.isHexStrict(label)) {\n        label = utils.sha3(label);\n    }\n    this.contract.then(function (contract) {\n        return contract.methods.setSubnodeOwner(namehash.hash(name), label, formatters.inputAddressFormatter(address)).send(txConfig);\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Sets the owner, resolver, and TTL for an ENS record in a single operation.\n *\n * @method setRecord\n *\n * @param {string} name\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setRecord = function (name, owner, resolver, ttl, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.setRecord(namehash.hash(name), formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Sets the owner, resolver and TTL for a subdomain, creating it if necessary.\n *\n * @method setSubnodeRecord\n *\n * @param {string} name\n * @param {string} label\n * @param {string} owner\n * @param {string} resolver\n * @param {string | number} ttl\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setSubnodeRecord = function (name, label, owner, resolver, ttl, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n    if (!utils.isHexStrict(label)) {\n        label = utils.sha3(label);\n    }\n    this.contract.then(function (contract) {\n        return contract.methods.setSubnodeRecord(namehash.hash(name), label, formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Sets or clears an approval by the given operator.\n *\n * @method setApprovalForAll\n *\n * @param {string} operator\n * @param {boolean} approved\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setApprovalForAll = function (operator, approved, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.setApprovalForAll(formatters.inputAddressFormatter(operator), approved).send(txConfig);\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Returns true if the operator is approved\n *\n * @method isApprovedForAll\n *\n * @param {string} owner\n * @param {string} operator\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\nRegistry.prototype.isApprovedForAll = function (owner, operator, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.isApprovedForAll(formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(operator)).call();\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Returns true if the record exists\n *\n * @method recordExists\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<boolean>}\n */\nRegistry.prototype.recordExists = function (name, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.recordExists(namehash.hash(name)).call();\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Returns the resolver contract associated with a name.\n *\n * @deprecated Please use the \"getResolver\" method instead of \"resolver\"\n *\n * @method resolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\nRegistry.prototype.resolver = function (name, callback) {\n    console.warn('Deprecated: Please use the \"getResolver\" method instead of \"resolver\".');\n    return this.getResolver(name, callback);\n};\n/**\n * Returns the resolver contract associated with a name.\n *\n * @method getResolver\n *\n * @param {string} name\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {Promise<Contract>}\n */\nRegistry.prototype.getResolver = function (name, callback) {\n    var self = this;\n    return this.contract.then(function (contract) {\n        return contract.methods.resolver(namehash.hash(name)).call();\n    }).then(function (address) {\n        var contract = new Contract(RESOLVER_ABI, address);\n        contract.setProvider(self.ens.eth.currentProvider);\n        if (typeof callback === 'function') {\n            // It's required to pass the contract to the first argument to be backward compatible and to have the required consistency\n            callback(contract, contract);\n            return;\n        }\n        return contract;\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        throw error;\n    });\n};\n/**\n * Returns the address of the owner of an ENS name.\n *\n * @method setResolver\n *\n * @param {string} name\n * @param {string} address\n * @param {TransactionConfig} txConfig\n * @param {function} callback\n *\n * @callback callback callback(error, result)\n * @returns {PromiEvent<TransactionReceipt | TransactionRevertInstructionError>}\n */\nRegistry.prototype.setResolver = function (name, address, txConfig, callback) {\n    var promiEvent = new PromiEvent(true);\n    this.contract.then(function (contract) {\n        return contract.methods.setResolver(namehash.hash(name), formatters.inputAddressFormatter(address)).send(txConfig);\n    }).then(function (receipt) {\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the first argument to be backward compatible and to have the required consistency\n            callback(receipt, receipt);\n            return;\n        }\n        promiEvent.resolve(receipt);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\nmodule.exports = Registry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9jb250cmFjdHMvUmVnaXN0cnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLDRHQUFtQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsc0VBQWtCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGtIQUFzQjtBQUMvQyxpQkFBaUIsOElBQXVDO0FBQ3hELFlBQVksbUJBQU8sQ0FBQyw4RkFBWTtBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyxnSUFBMkI7QUFDdEQsbUJBQW1CLG1CQUFPLENBQUMsZ0lBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9jb250cmFjdHMvUmVnaXN0cnkuanM/YThjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBSZWdpc3RyeS5qc1xuICpcbiAqIEBhdXRob3IgU2FtdWVsIEZ1cnRlciA8c2FtdWVsQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMThcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ29udHJhY3QgPSByZXF1aXJlKCd3ZWIzLWV0aC1jb250cmFjdCcpO1xudmFyIG5hbWVoYXNoID0gcmVxdWlyZSgnZXRoLWVucy1uYW1laGFzaCcpO1xudmFyIFByb21pRXZlbnQgPSByZXF1aXJlKCd3ZWIzLWNvcmUtcHJvbWlldmVudCcpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmZvcm1hdHRlcnM7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgUkVHSVNUUllfQUJJID0gcmVxdWlyZSgnLi4vcmVzb3VyY2VzL0FCSS9SZWdpc3RyeScpO1xudmFyIFJFU09MVkVSX0FCSSA9IHJlcXVpcmUoJy4uL3Jlc291cmNlcy9BQkkvUmVzb2x2ZXInKTtcbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgRU5TIHJlZ2lzdHJ5IGNvbnRyYWN0LlxuICpcbiAqIEBtZXRob2QgUmVnaXN0cnlcbiAqIEBwYXJhbSB7RW5zfSBlbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZWdpc3RyeShlbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5lbnMgPSBlbnM7XG4gICAgdGhpcy5jb250cmFjdCA9IGVucy5jaGVja05ldHdvcmsoKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBjb250cmFjdCA9IG5ldyBDb250cmFjdChSRUdJU1RSWV9BQkksIGFkZHJlc3MpO1xuICAgICAgICBjb250cmFjdC5zZXRQcm92aWRlcihzZWxmLmVucy5ldGguY3VycmVudFByb3ZpZGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBvd25lciBvZiBhbiBFTlMgbmFtZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIHRoZSBcImdldE93bmVyXCIgbWV0aG9kIGluc3RlYWQgb2YgXCJvd25lclwiXG4gKlxuICogQG1ldGhvZCBvd25lclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAqL1xuUmVnaXN0cnkucHJvdG90eXBlLm93bmVyID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkOiBQbGVhc2UgdXNlIHRoZSBcImdldE93bmVyXCIgbWV0aG9kIGluc3RlYWQgb2YgXCJvd25lclwiLicpO1xuICAgIHJldHVybiB0aGlzLmdldE93bmVyKG5hbWUsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIG93bmVyIG9mIGFuIEVOUyBuYW1lLlxuICpcbiAqIEBtZXRob2QgZ2V0T3duZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRPd25lciA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBwcm9taUV2ZW50ID0gbmV3IFByb21pRXZlbnQodHJ1ZSk7XG4gICAgdGhpcy5jb250cmFjdC50aGVuKGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgICAgICByZXR1cm4gY29udHJhY3QubWV0aG9kcy5vd25lcihuYW1laGFzaC5oYXNoKG5hbWUpKS5jYWxsKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHBhc3MgdGhlIHJlY2VpcHQgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgYW5kIHRvIGhhdmUgdGhlIHJlcXVpcmVkIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjYWxsYmFjayhyZWNlaXB0LCByZWNlaXB0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlc29sdmUocmVjZWlwdCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pRXZlbnQuZXZlbnRFbWl0dGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgb3duZXIgb2YgYW4gRU5TIG5hbWUuXG4gKlxuICogQG1ldGhvZCBzZXRPd25lclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHhDb25maWdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUuc2V0T3duZXIgPSBmdW5jdGlvbiAobmFtZSwgYWRkcmVzcywgdHhDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pRXZlbnQgPSBuZXcgUHJvbWlFdmVudCh0cnVlKTtcbiAgICB0aGlzLmNvbnRyYWN0LnRoZW4oZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5tZXRob2RzLnNldE93bmVyKG5hbWVoYXNoLmhhc2gobmFtZSksIGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKGFkZHJlc3MpKS5zZW5kKHR4Q29uZmlnKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gcGFzcyB0aGUgcmVjZWlwdCB0byB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZSBhbmQgdG8gaGF2ZSB0aGUgcmVxdWlyZWQgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlY2VpcHQsIHJlY2VpcHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVzb2x2ZShyZWNlaXB0KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlFdmVudC5ldmVudEVtaXR0ZXI7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBUVEwgb2YgdGhlIGdpdmVuIG5vZGUgYnkgaGlzIG5hbWVcbiAqXG4gKiBAbWV0aG9kIGdldFRUTFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnNzIHtQcm9taXNlPHN0cmluZz59XG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRUVEwgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlFdmVudCA9IG5ldyBQcm9taUV2ZW50KHRydWUpO1xuICAgIHRoaXMuY29udHJhY3QudGhlbihmdW5jdGlvbiAoY29udHJhY3QpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0Lm1ldGhvZHMudHRsKG5hbWVoYXNoLmhhc2gobmFtZSkpLmNhbGwoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gcGFzcyB0aGUgcmVjZWlwdCB0byB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZSBhbmQgdG8gaGF2ZSB0aGUgcmVxdWlyZWQgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlY2VpcHQsIHJlY2VpcHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVzb2x2ZShyZWNlaXB0KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlFdmVudC5ldmVudEVtaXR0ZXI7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhZGRyZXNzIG9mIHRoZSBvd25lciBvZiBhbiBFTlMgbmFtZS5cbiAqXG4gKiBAbWV0aG9kIHNldFRUTFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gdHRsXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5zZXRUVEwgPSBmdW5jdGlvbiAobmFtZSwgdHRsLCB0eENvbmZpZywgY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlFdmVudCA9IG5ldyBQcm9taUV2ZW50KHRydWUpO1xuICAgIHRoaXMuY29udHJhY3QudGhlbihmdW5jdGlvbiAoY29udHJhY3QpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0Lm1ldGhvZHMuc2V0VFRMKG5hbWVoYXNoLmhhc2gobmFtZSksIHR0bCkuc2VuZCh0eENvbmZpZyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHBhc3MgdGhlIHJlY2VpcHQgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgYW5kIHRvIGhhdmUgdGhlIHJlcXVpcmVkIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjYWxsYmFjayhyZWNlaXB0LCByZWNlaXB0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlc29sdmUocmVjZWlwdCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pRXZlbnQuZXZlbnRFbWl0dGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgb3duZXIgb2YgYW4gRU5TIG5hbWUuXG4gKlxuICogQG1ldGhvZCBzZXRTdWJub2RlT3duZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHhDb25maWdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUuc2V0U3Vibm9kZU93bmVyID0gZnVuY3Rpb24gKG5hbWUsIGxhYmVsLCBhZGRyZXNzLCB0eENvbmZpZywgY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlFdmVudCA9IG5ldyBQcm9taUV2ZW50KHRydWUpO1xuICAgIGlmICghdXRpbHMuaXNIZXhTdHJpY3QobGFiZWwpKSB7XG4gICAgICAgIGxhYmVsID0gdXRpbHMuc2hhMyhsYWJlbCk7XG4gICAgfVxuICAgIHRoaXMuY29udHJhY3QudGhlbihmdW5jdGlvbiAoY29udHJhY3QpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0Lm1ldGhvZHMuc2V0U3Vibm9kZU93bmVyKG5hbWVoYXNoLmhhc2gobmFtZSksIGxhYmVsLCBmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlcihhZGRyZXNzKSkuc2VuZCh0eENvbmZpZyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHBhc3MgdGhlIHJlY2VpcHQgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgYW5kIHRvIGhhdmUgdGhlIHJlcXVpcmVkIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjYWxsYmFjayhyZWNlaXB0LCByZWNlaXB0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlc29sdmUocmVjZWlwdCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pRXZlbnQuZXZlbnRFbWl0dGVyO1xufTtcbi8qKlxuICogU2V0cyB0aGUgb3duZXIsIHJlc29sdmVyLCBhbmQgVFRMIGZvciBhbiBFTlMgcmVjb3JkIGluIGEgc2luZ2xlIG9wZXJhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIHNldFJlY29yZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gb3duZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNvbHZlclxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IHR0bFxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHhDb25maWdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUuc2V0UmVjb3JkID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyLCByZXNvbHZlciwgdHRsLCB0eENvbmZpZywgY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlFdmVudCA9IG5ldyBQcm9taUV2ZW50KHRydWUpO1xuICAgIHRoaXMuY29udHJhY3QudGhlbihmdW5jdGlvbiAoY29udHJhY3QpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0Lm1ldGhvZHMuc2V0UmVjb3JkKG5hbWVoYXNoLmhhc2gobmFtZSksIGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG93bmVyKSwgZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIocmVzb2x2ZXIpLCB0dGwpLnNlbmQodHhDb25maWcpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byBwYXNzIHRoZSByZWNlaXB0IHRvIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIGFuZCB0byBoYXZlIHRoZSByZXF1aXJlZCBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgY2FsbGJhY2socmVjZWlwdCwgcmVjZWlwdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlFdmVudC5yZXNvbHZlKHJlY2VpcHQpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlFdmVudC5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taUV2ZW50LmV2ZW50RW1pdHRlcjtcbn07XG4vKipcbiAqIFNldHMgdGhlIG93bmVyLCByZXNvbHZlciBhbmQgVFRMIGZvciBhIHN1YmRvbWFpbiwgY3JlYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2Qgc2V0U3Vibm9kZVJlY29yZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBvd25lclxuICogQHBhcmFtIHtzdHJpbmd9IHJlc29sdmVyXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gdHRsXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5zZXRTdWJub2RlUmVjb3JkID0gZnVuY3Rpb24gKG5hbWUsIGxhYmVsLCBvd25lciwgcmVzb2x2ZXIsIHR0bCwgdHhDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pRXZlbnQgPSBuZXcgUHJvbWlFdmVudCh0cnVlKTtcbiAgICBpZiAoIXV0aWxzLmlzSGV4U3RyaWN0KGxhYmVsKSkge1xuICAgICAgICBsYWJlbCA9IHV0aWxzLnNoYTMobGFiZWwpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyYWN0LnRoZW4oZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5tZXRob2RzLnNldFN1Ym5vZGVSZWNvcmQobmFtZWhhc2guaGFzaChuYW1lKSwgbGFiZWwsIGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG93bmVyKSwgZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIocmVzb2x2ZXIpLCB0dGwpLnNlbmQodHhDb25maWcpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byBwYXNzIHRoZSByZWNlaXB0IHRvIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIGFuZCB0byBoYXZlIHRoZSByZXF1aXJlZCBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgY2FsbGJhY2socmVjZWlwdCwgcmVjZWlwdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlFdmVudC5yZXNvbHZlKHJlY2VpcHQpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlFdmVudC5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taUV2ZW50LmV2ZW50RW1pdHRlcjtcbn07XG4vKipcbiAqIFNldHMgb3IgY2xlYXJzIGFuIGFwcHJvdmFsIGJ5IHRoZSBnaXZlbiBvcGVyYXRvci5cbiAqXG4gKiBAbWV0aG9kIHNldEFwcHJvdmFsRm9yQWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFwcHJvdmVkXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0eENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taUV2ZW50PFRyYW5zYWN0aW9uUmVjZWlwdCB8IFRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcj59XG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5zZXRBcHByb3ZhbEZvckFsbCA9IGZ1bmN0aW9uIChvcGVyYXRvciwgYXBwcm92ZWQsIHR4Q29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciBwcm9taUV2ZW50ID0gbmV3IFByb21pRXZlbnQodHJ1ZSk7XG4gICAgdGhpcy5jb250cmFjdC50aGVuKGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgICAgICByZXR1cm4gY29udHJhY3QubWV0aG9kcy5zZXRBcHByb3ZhbEZvckFsbChmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcGVyYXRvciksIGFwcHJvdmVkKS5zZW5kKHR4Q29uZmlnKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gcGFzcyB0aGUgcmVjZWlwdCB0byB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZSBhbmQgdG8gaGF2ZSB0aGUgcmVxdWlyZWQgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlY2VpcHQsIHJlY2VpcHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVzb2x2ZShyZWNlaXB0KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlFdmVudC5ldmVudEVtaXR0ZXI7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9wZXJhdG9yIGlzIGFwcHJvdmVkXG4gKlxuICogQG1ldGhvZCBpc0FwcHJvdmVkRm9yQWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG93bmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAqL1xuUmVnaXN0cnkucHJvdG90eXBlLmlzQXBwcm92ZWRGb3JBbGwgPSBmdW5jdGlvbiAob3duZXIsIG9wZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBwcm9taUV2ZW50ID0gbmV3IFByb21pRXZlbnQodHJ1ZSk7XG4gICAgdGhpcy5jb250cmFjdC50aGVuKGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgICAgICByZXR1cm4gY29udHJhY3QubWV0aG9kcy5pc0FwcHJvdmVkRm9yQWxsKGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG93bmVyKSwgZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3BlcmF0b3IpKS5jYWxsKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHBhc3MgdGhlIHJlY2VpcHQgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgYW5kIHRvIGhhdmUgdGhlIHJlcXVpcmVkIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjYWxsYmFjayhyZWNlaXB0LCByZWNlaXB0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlc29sdmUocmVjZWlwdCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pRXZlbnQuZXZlbnRFbWl0dGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSByZWNvcmQgZXhpc3RzXG4gKlxuICogQG1ldGhvZCByZWNvcmRFeGlzdHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAY2FsbGJhY2sgY2FsbGJhY2sgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUucmVjb3JkRXhpc3RzID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pRXZlbnQgPSBuZXcgUHJvbWlFdmVudCh0cnVlKTtcbiAgICB0aGlzLmNvbnRyYWN0LnRoZW4oZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5tZXRob2RzLnJlY29yZEV4aXN0cyhuYW1laGFzaC5oYXNoKG5hbWUpKS5jYWxsKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHBhc3MgdGhlIHJlY2VpcHQgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgYW5kIHRvIGhhdmUgdGhlIHJlcXVpcmVkIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjYWxsYmFjayhyZWNlaXB0LCByZWNlaXB0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlc29sdmUocmVjZWlwdCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pRXZlbnQuZXZlbnRFbWl0dGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcmVzb2x2ZXIgY29udHJhY3QgYXNzb2NpYXRlZCB3aXRoIGEgbmFtZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIHRoZSBcImdldFJlc29sdmVyXCIgbWV0aG9kIGluc3RlYWQgb2YgXCJyZXNvbHZlclwiXG4gKlxuICogQG1ldGhvZCByZXNvbHZlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEBjYWxsYmFjayBjYWxsYmFjayBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxuICogQHJldHVybnMge1Byb21pc2U8Q29udHJhY3Q+fVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUucmVzb2x2ZXIgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQ6IFBsZWFzZSB1c2UgdGhlIFwiZ2V0UmVzb2x2ZXJcIiBtZXRob2QgaW5zdGVhZCBvZiBcInJlc29sdmVyXCIuJyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSwgY2FsbGJhY2spO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcmVzb2x2ZXIgY29udHJhY3QgYXNzb2NpYXRlZCB3aXRoIGEgbmFtZS5cbiAqXG4gKiBAbWV0aG9kIGdldFJlc29sdmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxDb250cmFjdD59XG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRSZXNvbHZlciA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5jb250cmFjdC50aGVuKGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgICAgICByZXR1cm4gY29udHJhY3QubWV0aG9kcy5yZXNvbHZlcihuYW1laGFzaC5oYXNoKG5hbWUpKS5jYWxsKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICB2YXIgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoUkVTT0xWRVJfQUJJLCBhZGRyZXNzKTtcbiAgICAgICAgY29udHJhY3Quc2V0UHJvdmlkZXIoc2VsZi5lbnMuZXRoLmN1cnJlbnRQcm92aWRlcik7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gcGFzcyB0aGUgY29udHJhY3QgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgYW5kIHRvIGhhdmUgdGhlIHJlcXVpcmVkIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjYWxsYmFjayhjb250cmFjdCwgY29udHJhY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgb3duZXIgb2YgYW4gRU5TIG5hbWUuXG4gKlxuICogQG1ldGhvZCBzZXRSZXNvbHZlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHhDb25maWdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpXG4gKiBAcmV0dXJucyB7UHJvbWlFdmVudDxUcmFuc2FjdGlvblJlY2VpcHQgfCBUcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3I+fVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUuc2V0UmVzb2x2ZXIgPSBmdW5jdGlvbiAobmFtZSwgYWRkcmVzcywgdHhDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pRXZlbnQgPSBuZXcgUHJvbWlFdmVudCh0cnVlKTtcbiAgICB0aGlzLmNvbnRyYWN0LnRoZW4oZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5tZXRob2RzLnNldFJlc29sdmVyKG5hbWVoYXNoLmhhc2gobmFtZSksIGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKGFkZHJlc3MpKS5zZW5kKHR4Q29uZmlnKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gcGFzcyB0aGUgcmVjZWlwdCB0byB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZSBhbmQgdG8gaGF2ZSB0aGUgcmVxdWlyZWQgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlY2VpcHQsIHJlY2VpcHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVzb2x2ZShyZWNlaXB0KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlFdmVudC5ldmVudEVtaXR0ZXI7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3RyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/contracts/Registry.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/index.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/index.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2018\n */\n\nvar ENS = __webpack_require__(/*! ./ENS */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/ENS.js\");\nmodule.exports = ENS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixVQUFVLG1CQUFPLENBQUMseUZBQU87QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWVucy9saWIvaW5kZXguanM/YjZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICpcbiAqIEBhdXRob3IgU2FtdWVsIEZ1cnRlciA8c2FtdWVsQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMThcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRU5TID0gcmVxdWlyZSgnLi9FTlMnKTtcbm1vZHVsZS5leHBvcnRzID0gRU5TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/ResolverMethodHandler.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/ResolverMethodHandler.js ***!
  \********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file ResolverMethodHandler.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2018\n */\n\nvar PromiEvent = __webpack_require__(/*! web3-core-promievent */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-promievent/lib/index.js\");\nvar namehash = __webpack_require__(/*! eth-ens-namehash */ \"../../node_modules/eth-ens-namehash/index.js\");\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar interfaceIds = (__webpack_require__(/*! ../config */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/config.js\").interfaceIds);\n/**\n * @param {Registry} registry\n * @constructor\n */\nfunction ResolverMethodHandler(registry) {\n    this.registry = registry;\n}\n/**\n * Executes an resolver method and returns an eventifiedPromise\n *\n * @param {string} ensName\n * @param {string} methodName\n * @param {array} methodArguments\n * @param {function} callback\n * @returns {Object}\n */\nResolverMethodHandler.prototype.method = function (ensName, methodName, methodArguments, outputFormatter, callback) {\n    return {\n        call: this.call.bind({\n            ensName: ensName,\n            methodName: methodName,\n            methodArguments: methodArguments,\n            callback: callback,\n            parent: this,\n            outputFormatter: outputFormatter\n        }),\n        send: this.send.bind({\n            ensName: ensName,\n            methodName: methodName,\n            methodArguments: methodArguments,\n            callback: callback,\n            parent: this\n        })\n    };\n};\n/**\n * Executes call\n *\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.call = function (callback) {\n    var self = this;\n    var promiEvent = new PromiEvent();\n    var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);\n    var outputFormatter = this.outputFormatter || null;\n    this.parent.registry.getResolver(this.ensName).then(async function (resolver) {\n        await self.parent.checkInterfaceSupport(resolver, self.methodName);\n        self.parent.handleCall(promiEvent, resolver.methods[self.methodName], preparedArguments, outputFormatter, callback);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Executes send\n *\n * @param {Object} sendOptions\n * @param {function} callback\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.send = function (sendOptions, callback) {\n    var self = this;\n    var promiEvent = new PromiEvent();\n    var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);\n    this.parent.registry.getResolver(this.ensName).then(async function (resolver) {\n        await self.parent.checkInterfaceSupport(resolver, self.methodName);\n        self.parent.handleSend(promiEvent, resolver.methods[self.methodName], preparedArguments, sendOptions, callback);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Handles a call method\n *\n * @param {eventifiedPromise} promiEvent\n * @param {function} method\n * @param {array} preparedArguments\n * @param {function} callback\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.handleCall = function (promiEvent, method, preparedArguments, outputFormatter, callback) {\n    method.apply(this, preparedArguments).call()\n        .then(function (result) {\n        if (outputFormatter) {\n            result = outputFormatter(result);\n        }\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the second argument to be backwards compatible and to have the required consistency\n            callback(result, result);\n            return;\n        }\n        promiEvent.resolve(result);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent;\n};\n/**\n * Handles a send method\n *\n * @param {eventifiedPromise} promiEvent\n * @param {function} method\n * @param {array} preparedArguments\n * @param {Object} sendOptions\n * @param {function} callback\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.handleSend = function (promiEvent, method, preparedArguments, sendOptions, callback) {\n    method.apply(this, preparedArguments).send(sendOptions)\n        .on('sending', function () {\n        promiEvent.eventEmitter.emit('sending');\n    })\n        .on('sent', function () {\n        promiEvent.eventEmitter.emit('sent');\n    })\n        .on('transactionHash', function (hash) {\n        promiEvent.eventEmitter.emit('transactionHash', hash);\n    })\n        .on('confirmation', function (confirmationNumber, receipt) {\n        promiEvent.eventEmitter.emit('confirmation', confirmationNumber, receipt);\n    })\n        .on('receipt', function (receipt) {\n        promiEvent.eventEmitter.emit('receipt', receipt);\n        promiEvent.resolve(receipt);\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the second argument to be backwards compatible and to have the required consistency\n            callback(receipt, receipt);\n        }\n    })\n        .on('error', function (error) {\n        promiEvent.eventEmitter.emit('error', error);\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent;\n};\n/**\n * Adds the ENS node to the arguments\n *\n * @param {string} name\n * @param {array} methodArguments\n *\n * @returns {array}\n */\nResolverMethodHandler.prototype.prepareArguments = function (name, methodArguments) {\n    var node = namehash.hash(name);\n    if (methodArguments.length > 0) {\n        methodArguments.unshift(node);\n        return methodArguments;\n    }\n    return [node];\n};\n/**\n *\n *\n * @param {Contract} resolver\n * @param {string} methodName\n *\n * @returns {Promise}\n */\nResolverMethodHandler.prototype.checkInterfaceSupport = async function (resolver, methodName) {\n    // Skip validation for undocumented interface ids (ex: multihash)\n    if (!interfaceIds[methodName])\n        return;\n    var supported = false;\n    try {\n        supported = await resolver\n            .methods\n            .supportsInterface(interfaceIds[methodName])\n            .call();\n    }\n    catch (err) {\n        console.warn('Could not verify interface of resolver contract at \"' + resolver.options.address + '\". ');\n    }\n    if (!supported) {\n        throw errors.ResolverMethodMissingError(resolver.options.address, methodName);\n    }\n};\nmodule.exports = ResolverMethodHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9saWIvUmVzb2x2ZXJNZXRob2RIYW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLGtIQUFzQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsc0VBQWtCO0FBQ3pDLGFBQWEsMElBQW1DO0FBQ2hELG1CQUFtQixvSUFBaUM7QUFDcEQ7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWVucy9saWIvbGliL1Jlc29sdmVyTWV0aG9kSGFuZGxlci5qcz8zYjQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIFJlc29sdmVyTWV0aG9kSGFuZGxlci5qc1xuICpcbiAqIEBhdXRob3IgU2FtdWVsIEZ1cnRlciA8c2FtdWVsQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMThcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUHJvbWlFdmVudCA9IHJlcXVpcmUoJ3dlYjMtY29yZS1wcm9taWV2ZW50Jyk7XG52YXIgbmFtZWhhc2ggPSByZXF1aXJlKCdldGgtZW5zLW5hbWVoYXNoJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5lcnJvcnM7XG52YXIgaW50ZXJmYWNlSWRzID0gcmVxdWlyZSgnLi4vY29uZmlnJykuaW50ZXJmYWNlSWRzO1xuLyoqXG4gKiBAcGFyYW0ge1JlZ2lzdHJ5fSByZWdpc3RyeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlc29sdmVyTWV0aG9kSGFuZGxlcihyZWdpc3RyeSkge1xuICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbn1cbi8qKlxuICogRXhlY3V0ZXMgYW4gcmVzb2x2ZXIgbWV0aG9kIGFuZCByZXR1cm5zIGFuIGV2ZW50aWZpZWRQcm9taXNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuc05hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcGFyYW0ge2FycmF5fSBtZXRob2RBcmd1bWVudHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5SZXNvbHZlck1ldGhvZEhhbmRsZXIucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChlbnNOYW1lLCBtZXRob2ROYW1lLCBtZXRob2RBcmd1bWVudHMsIG91dHB1dEZvcm1hdHRlciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxsOiB0aGlzLmNhbGwuYmluZCh7XG4gICAgICAgICAgICBlbnNOYW1lOiBlbnNOYW1lLFxuICAgICAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIG1ldGhvZEFyZ3VtZW50czogbWV0aG9kQXJndW1lbnRzLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBvdXRwdXRGb3JtYXR0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIHNlbmQ6IHRoaXMuc2VuZC5iaW5kKHtcbiAgICAgICAgICAgIGVuc05hbWU6IGVuc05hbWUsXG4gICAgICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgICAgICAgbWV0aG9kQXJndW1lbnRzOiBtZXRob2RBcmd1bWVudHMsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgfSlcbiAgICB9O1xufTtcbi8qKlxuICogRXhlY3V0ZXMgY2FsbFxuICpcbiAqIEByZXR1cm5zIHtldmVudGlmaWVkUHJvbWlzZX1cbiAqL1xuUmVzb2x2ZXJNZXRob2RIYW5kbGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taUV2ZW50ID0gbmV3IFByb21pRXZlbnQoKTtcbiAgICB2YXIgcHJlcGFyZWRBcmd1bWVudHMgPSB0aGlzLnBhcmVudC5wcmVwYXJlQXJndW1lbnRzKHRoaXMuZW5zTmFtZSwgdGhpcy5tZXRob2RBcmd1bWVudHMpO1xuICAgIHZhciBvdXRwdXRGb3JtYXR0ZXIgPSB0aGlzLm91dHB1dEZvcm1hdHRlciB8fCBudWxsO1xuICAgIHRoaXMucGFyZW50LnJlZ2lzdHJ5LmdldFJlc29sdmVyKHRoaXMuZW5zTmFtZSkudGhlbihhc3luYyBmdW5jdGlvbiAocmVzb2x2ZXIpIHtcbiAgICAgICAgYXdhaXQgc2VsZi5wYXJlbnQuY2hlY2tJbnRlcmZhY2VTdXBwb3J0KHJlc29sdmVyLCBzZWxmLm1ldGhvZE5hbWUpO1xuICAgICAgICBzZWxmLnBhcmVudC5oYW5kbGVDYWxsKHByb21pRXZlbnQsIHJlc29sdmVyLm1ldGhvZHNbc2VsZi5tZXRob2ROYW1lXSwgcHJlcGFyZWRBcmd1bWVudHMsIG91dHB1dEZvcm1hdHRlciwgY2FsbGJhY2spO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlFdmVudC5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taUV2ZW50LmV2ZW50RW1pdHRlcjtcbn07XG4vKipcbiAqIEV4ZWN1dGVzIHNlbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VuZE9wdGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7ZXZlbnRpZmllZFByb21pc2V9XG4gKi9cblJlc29sdmVyTWV0aG9kSGFuZGxlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChzZW5kT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pRXZlbnQgPSBuZXcgUHJvbWlFdmVudCgpO1xuICAgIHZhciBwcmVwYXJlZEFyZ3VtZW50cyA9IHRoaXMucGFyZW50LnByZXBhcmVBcmd1bWVudHModGhpcy5lbnNOYW1lLCB0aGlzLm1ldGhvZEFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYXJlbnQucmVnaXN0cnkuZ2V0UmVzb2x2ZXIodGhpcy5lbnNOYW1lKS50aGVuKGFzeW5jIGZ1bmN0aW9uIChyZXNvbHZlcikge1xuICAgICAgICBhd2FpdCBzZWxmLnBhcmVudC5jaGVja0ludGVyZmFjZVN1cHBvcnQocmVzb2x2ZXIsIHNlbGYubWV0aG9kTmFtZSk7XG4gICAgICAgIHNlbGYucGFyZW50LmhhbmRsZVNlbmQocHJvbWlFdmVudCwgcmVzb2x2ZXIubWV0aG9kc1tzZWxmLm1ldGhvZE5hbWVdLCBwcmVwYXJlZEFyZ3VtZW50cywgc2VuZE9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pRXZlbnQucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlFdmVudC5ldmVudEVtaXR0ZXI7XG59O1xuLyoqXG4gKiBIYW5kbGVzIGEgY2FsbCBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge2V2ZW50aWZpZWRQcm9taXNlfSBwcm9taUV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7YXJyYXl9IHByZXBhcmVkQXJndW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge2V2ZW50aWZpZWRQcm9taXNlfVxuICovXG5SZXNvbHZlck1ldGhvZEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUNhbGwgPSBmdW5jdGlvbiAocHJvbWlFdmVudCwgbWV0aG9kLCBwcmVwYXJlZEFyZ3VtZW50cywgb3V0cHV0Rm9ybWF0dGVyLCBjYWxsYmFjaykge1xuICAgIG1ldGhvZC5hcHBseSh0aGlzLCBwcmVwYXJlZEFyZ3VtZW50cykuY2FsbCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKG91dHB1dEZvcm1hdHRlcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gb3V0cHV0Rm9ybWF0dGVyKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byBwYXNzIHRoZSByZWNlaXB0IHRvIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYmFja3dhcmRzIGNvbXBhdGlibGUgYW5kIHRvIGhhdmUgdGhlIHJlcXVpcmVkIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlFdmVudC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taUV2ZW50LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pRXZlbnQ7XG59O1xuLyoqXG4gKiBIYW5kbGVzIGEgc2VuZCBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge2V2ZW50aWZpZWRQcm9taXNlfSBwcm9taUV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7YXJyYXl9IHByZXBhcmVkQXJndW1lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gc2VuZE9wdGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7ZXZlbnRpZmllZFByb21pc2V9XG4gKi9cblJlc29sdmVyTWV0aG9kSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlU2VuZCA9IGZ1bmN0aW9uIChwcm9taUV2ZW50LCBtZXRob2QsIHByZXBhcmVkQXJndW1lbnRzLCBzZW5kT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBtZXRob2QuYXBwbHkodGhpcywgcHJlcGFyZWRBcmd1bWVudHMpLnNlbmQoc2VuZE9wdGlvbnMpXG4gICAgICAgIC5vbignc2VuZGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvbWlFdmVudC5ldmVudEVtaXR0ZXIuZW1pdCgnc2VuZGluZycpO1xuICAgIH0pXG4gICAgICAgIC5vbignc2VudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvbWlFdmVudC5ldmVudEVtaXR0ZXIuZW1pdCgnc2VudCcpO1xuICAgIH0pXG4gICAgICAgIC5vbigndHJhbnNhY3Rpb25IYXNoJywgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgcHJvbWlFdmVudC5ldmVudEVtaXR0ZXIuZW1pdCgndHJhbnNhY3Rpb25IYXNoJywgaGFzaCk7XG4gICAgfSlcbiAgICAgICAgLm9uKCdjb25maXJtYXRpb24nLCBmdW5jdGlvbiAoY29uZmlybWF0aW9uTnVtYmVyLCByZWNlaXB0KSB7XG4gICAgICAgIHByb21pRXZlbnQuZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbmZpcm1hdGlvbicsIGNvbmZpcm1hdGlvbk51bWJlciwgcmVjZWlwdCk7XG4gICAgfSlcbiAgICAgICAgLm9uKCdyZWNlaXB0JywgZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgcHJvbWlFdmVudC5ldmVudEVtaXR0ZXIuZW1pdCgncmVjZWlwdCcsIHJlY2VpcHQpO1xuICAgICAgICBwcm9taUV2ZW50LnJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gcGFzcyB0aGUgcmVjZWlwdCB0byB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGJhY2t3YXJkcyBjb21wYXRpYmxlIGFuZCB0byBoYXZlIHRoZSByZXF1aXJlZCBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgY2FsbGJhY2socmVjZWlwdCwgcmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHByb21pRXZlbnQuZXZlbnRFbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlFdmVudC5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taUV2ZW50O1xufTtcbi8qKlxuICogQWRkcyB0aGUgRU5TIG5vZGUgdG8gdGhlIGFyZ3VtZW50c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2FycmF5fSBtZXRob2RBcmd1bWVudHNcbiAqXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKi9cblJlc29sdmVyTWV0aG9kSGFuZGxlci5wcm90b3R5cGUucHJlcGFyZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIChuYW1lLCBtZXRob2RBcmd1bWVudHMpIHtcbiAgICB2YXIgbm9kZSA9IG5hbWVoYXNoLmhhc2gobmFtZSk7XG4gICAgaWYgKG1ldGhvZEFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1ldGhvZEFyZ3VtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICByZXR1cm4gbWV0aG9kQXJndW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gW25vZGVdO1xufTtcbi8qKlxuICpcbiAqXG4gKiBAcGFyYW0ge0NvbnRyYWN0fSByZXNvbHZlclxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuUmVzb2x2ZXJNZXRob2RIYW5kbGVyLnByb3RvdHlwZS5jaGVja0ludGVyZmFjZVN1cHBvcnQgPSBhc3luYyBmdW5jdGlvbiAocmVzb2x2ZXIsIG1ldGhvZE5hbWUpIHtcbiAgICAvLyBTa2lwIHZhbGlkYXRpb24gZm9yIHVuZG9jdW1lbnRlZCBpbnRlcmZhY2UgaWRzIChleDogbXVsdGloYXNoKVxuICAgIGlmICghaW50ZXJmYWNlSWRzW21ldGhvZE5hbWVdKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGF3YWl0IHJlc29sdmVyXG4gICAgICAgICAgICAubWV0aG9kc1xuICAgICAgICAgICAgLnN1cHBvcnRzSW50ZXJmYWNlKGludGVyZmFjZUlkc1ttZXRob2ROYW1lXSlcbiAgICAgICAgICAgIC5jYWxsKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgdmVyaWZ5IGludGVyZmFjZSBvZiByZXNvbHZlciBjb250cmFjdCBhdCBcIicgKyByZXNvbHZlci5vcHRpb25zLmFkZHJlc3MgKyAnXCIuICcpO1xuICAgIH1cbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuUmVzb2x2ZXJNZXRob2RNaXNzaW5nRXJyb3IocmVzb2x2ZXIub3B0aW9ucy5hZGRyZXNzLCBtZXRob2ROYW1lKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBSZXNvbHZlck1ldGhvZEhhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/ResolverMethodHandler.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/contentHash.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/contentHash.js ***!
  \**********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\nAdapted from ensdomains/ui\nhttps://github.com/ensdomains/ui/blob/3e62e440b53466eeec9dd1c63d73924eefbd88c1/src/utils/contents.js#L1-L85\n\nBSD 2-Clause License\n\nCopyright (c) 2019, Ethereum Name Service\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nvar contentHash = __webpack_require__(/*! content-hash */ \"../../node_modules/content-hash/src/index.js\");\nfunction decode(encoded) {\n    var decoded = null;\n    var protocolType = null;\n    var error = null;\n    if (encoded && encoded.error) {\n        return {\n            protocolType: null,\n            decoded: encoded.error\n        };\n    }\n    if (encoded) {\n        try {\n            decoded = contentHash.decode(encoded);\n            var codec = contentHash.getCodec(encoded);\n            if (codec === 'ipfs-ns') {\n                protocolType = 'ipfs';\n            }\n            else if (codec === 'swarm-ns') {\n                protocolType = 'bzz';\n            }\n            else if (codec === 'onion') {\n                protocolType = 'onion';\n            }\n            else if (codec === 'onion3') {\n                protocolType = 'onion3';\n            }\n            else {\n                decoded = encoded;\n            }\n        }\n        catch (e) {\n            error = e.message;\n        }\n    }\n    return {\n        protocolType: protocolType,\n        decoded: decoded,\n        error: error\n    };\n}\nfunction encode(text) {\n    var content, contentType;\n    var encoded = false;\n    if (!!text) {\n        var matched = text.match(/^(ipfs|bzz|onion|onion3):\\/\\/(.*)/) || text.match(/\\/(ipfs)\\/(.*)/);\n        if (matched) {\n            contentType = matched[1];\n            content = matched[2];\n        }\n        try {\n            if (contentType === 'ipfs') {\n                if (content.length >= 4) {\n                    encoded = '0x' + contentHash.fromIpfs(content);\n                }\n            }\n            else if (contentType === 'bzz') {\n                if (content.length >= 4) {\n                    encoded = '0x' + contentHash.fromSwarm(content);\n                }\n            }\n            else if (contentType === 'onion') {\n                if (content.length === 16) {\n                    encoded = '0x' + contentHash.encode('onion', content);\n                }\n            }\n            else if (contentType === 'onion3') {\n                if (content.length === 56) {\n                    encoded = '0x' + contentHash.encode('onion3', content);\n                }\n            }\n            else {\n                throw new Error('Could not encode content hash: unsupported content type');\n            }\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n    return encoded;\n}\nmodule.exports = {\n    decode: decode,\n    encode: encode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9saWIvY29udGVudEhhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGtFQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9saWIvY29udGVudEhhc2guanM/MjJjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQWRhcHRlZCBmcm9tIGVuc2RvbWFpbnMvdWlcbmh0dHBzOi8vZ2l0aHViLmNvbS9lbnNkb21haW5zL3VpL2Jsb2IvM2U2MmU0NDBiNTM0NjZlZWVjOWRkMWM2M2Q3MzkyNGVlZmJkODhjMS9zcmMvdXRpbHMvY29udGVudHMuanMjTDEtTDg1XG5cbkJTRCAyLUNsYXVzZSBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxOSwgRXRoZXJldW0gTmFtZSBTZXJ2aWNlXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG5BTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG5JTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEVcbkZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG5EQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVJcbkNBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksXG5PUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG52YXIgY29udGVudEhhc2ggPSByZXF1aXJlKCdjb250ZW50LWhhc2gnKTtcbmZ1bmN0aW9uIGRlY29kZShlbmNvZGVkKSB7XG4gICAgdmFyIGRlY29kZWQgPSBudWxsO1xuICAgIHZhciBwcm90b2NvbFR5cGUgPSBudWxsO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgaWYgKGVuY29kZWQgJiYgZW5jb2RlZC5lcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdG9jb2xUeXBlOiBudWxsLFxuICAgICAgICAgICAgZGVjb2RlZDogZW5jb2RlZC5lcnJvclxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5jb2RlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVjb2RlZCA9IGNvbnRlbnRIYXNoLmRlY29kZShlbmNvZGVkKTtcbiAgICAgICAgICAgIHZhciBjb2RlYyA9IGNvbnRlbnRIYXNoLmdldENvZGVjKGVuY29kZWQpO1xuICAgICAgICAgICAgaWYgKGNvZGVjID09PSAnaXBmcy1ucycpIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbFR5cGUgPSAnaXBmcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlYyA9PT0gJ3N3YXJtLW5zJykge1xuICAgICAgICAgICAgICAgIHByb3RvY29sVHlwZSA9ICdienonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZWMgPT09ICdvbmlvbicpIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbFR5cGUgPSAnb25pb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZWMgPT09ICdvbmlvbjMnKSB7XG4gICAgICAgICAgICAgICAgcHJvdG9jb2xUeXBlID0gJ29uaW9uMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkID0gZW5jb2RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvdG9jb2xUeXBlOiBwcm90b2NvbFR5cGUsXG4gICAgICAgIGRlY29kZWQ6IGRlY29kZWQsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGUodGV4dCkge1xuICAgIHZhciBjb250ZW50LCBjb250ZW50VHlwZTtcbiAgICB2YXIgZW5jb2RlZCA9IGZhbHNlO1xuICAgIGlmICghIXRleHQpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSB0ZXh0Lm1hdGNoKC9eKGlwZnN8Ynp6fG9uaW9ufG9uaW9uMyk6XFwvXFwvKC4qKS8pIHx8IHRleHQubWF0Y2goL1xcLyhpcGZzKVxcLyguKikvKTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBtYXRjaGVkWzJdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdpcGZzJykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWQgPSAnMHgnICsgY29udGVudEhhc2guZnJvbUlwZnMoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09ICdienonKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZCA9ICcweCcgKyBjb250ZW50SGFzaC5mcm9tU3dhcm0oY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09ICdvbmlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWQgPSAnMHgnICsgY29udGVudEhhc2guZW5jb2RlKCdvbmlvbicsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUeXBlID09PSAnb25pb24zJykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZCA9ICcweCcgKyBjb250ZW50SGFzaC5lbmNvZGUoJ29uaW9uMycsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGVuY29kZSBjb250ZW50IGhhc2g6IHVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2RlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/lib/contentHash.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Registry.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Registry.js ***!
  \*****************************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\nvar REGISTRY = [\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"resolver\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"address\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"owner\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"address\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"label\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"setSubnodeOwner\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"ttl\",\n                \"type\": \"uint64\"\n            }\n        ],\n        \"name\": \"setTTL\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"ttl\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"uint64\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"resolver\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"setResolver\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"setOwner\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"Transfer\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": true,\n                \"name\": \"label\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"NewOwner\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"resolver\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"NewResolver\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"ttl\",\n                \"type\": \"uint64\"\n            }\n        ],\n        \"name\": \"NewTTL\",\n        \"type\": \"event\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"resolver\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"ttl\",\n                \"type\": \"uint64\"\n            }\n        ],\n        \"name\": \"setRecord\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"operator\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"approved\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"name\": \"setApprovalForAll\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"internalType\": \"address\",\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": true,\n                \"internalType\": \"address\",\n                \"name\": \"operator\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"internalType\": \"bool\",\n                \"name\": \"approved\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"name\": \"ApprovalForAll\",\n        \"type\": \"event\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"internalType\": \"address\",\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"operator\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"isApprovedForAll\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"recordExists\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"label\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"address\",\n                \"name\": \"resolver\",\n                \"type\": \"address\"\n            },\n            {\n                \"internalType\": \"uint64\",\n                \"name\": \"ttl\",\n                \"type\": \"uint64\"\n            }\n        ],\n        \"name\": \"setSubnodeRecord\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n];\nmodule.exports = REGISTRY;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9yZXNvdXJjZXMvQUJJL1JlZ2lzdHJ5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1lbnMvbGliL3Jlc291cmNlcy9BQkkvUmVnaXN0cnkuanM/YzYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBSRUdJU1RSWSA9IFtcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwicmVzb2x2ZXJcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwib3duZXJcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcInNldFN1Ym5vZGVPd25lclwiLFxuICAgICAgICBcIm91dHB1dHNcIjogW10sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0dGxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50NjRcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJzZXRUVExcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJ0dGxcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50NjRcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVzb2x2ZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwic2V0UmVzb2x2ZXJcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwic2V0T3duZXJcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJUcmFuc2ZlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJldmVudFwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiYW5vbnltb3VzXCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJsYWJlbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwiTmV3T3duZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJlc29sdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcIk5ld1Jlc29sdmVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImV2ZW50XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0dGxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50NjRcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJOZXdUVExcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXNvbHZlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcInVpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInR0bFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVpbnQ2NFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcInNldFJlY29yZFwiLFxuICAgICAgICBcIm91dHB1dHNcIjogW10sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFwcHJvdmVkXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcInNldEFwcHJvdmFsRm9yQWxsXCIsXG4gICAgICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhcHByb3ZlZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJBcHByb3ZhbEZvckFsbFwiLFxuICAgICAgICBcInR5cGVcIjogXCJldmVudFwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcImlzQXBwcm92ZWRGb3JBbGxcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZEV4aXN0c1wiLFxuICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJlc29sdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwidWludDY0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidHRsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidWludDY0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwic2V0U3Vibm9kZVJlY29yZFwiLFxuICAgICAgICBcIm91dHB1dHNcIjogW10sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9XG5dO1xubW9kdWxlLmV4cG9ydHMgPSBSRUdJU1RSWTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Registry.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Resolver.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Resolver.js ***!
  \*****************************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\nvar RESOLVER = [\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"interfaceID\",\n                \"type\": \"bytes4\"\n            }\n        ],\n        \"name\": \"supportsInterface\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"contentTypes\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"ABI\",\n        \"outputs\": [\n            {\n                \"name\": \"contentType\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"name\": \"data\",\n                \"type\": \"bytes\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"hash\",\n                \"type\": \"bytes\"\n            }\n        ],\n        \"name\": \"setMultihash\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"multihash\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"bytes\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"x\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"y\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"setPubkey\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"content\",\n        \"outputs\": [\n            {\n                \"name\": \"ret\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"addr\",\n        \"outputs\": [\n            {\n                \"name\": \"ret\",\n                \"type\": \"address\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"contentType\",\n                \"type\": \"uint256\"\n            },\n            {\n                \"name\": \"data\",\n                \"type\": \"bytes\"\n            }\n        ],\n        \"name\": \"setABI\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"name\",\n        \"outputs\": [\n            {\n                \"name\": \"ret\",\n                \"type\": \"string\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"name\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"setName\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"hash\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"setContent\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"pubkey\",\n        \"outputs\": [\n            {\n                \"name\": \"x\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"y\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"addr\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"setAddr\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"name\": \"ensAddr\",\n                \"type\": \"address\"\n            }\n        ],\n        \"payable\": false,\n        \"type\": \"constructor\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"a\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"AddrChanged\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"hash\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"ContentChanged\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"name\",\n                \"type\": \"string\"\n            }\n        ],\n        \"name\": \"NameChanged\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": true,\n                \"name\": \"contentType\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"ABIChanged\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"x\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"y\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"PubkeyChanged\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"hash\",\n                \"type\": \"bytes\"\n            }\n        ],\n        \"name\": \"ContenthashChanged\",\n        \"type\": \"event\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"contenthash\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"bytes\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"node\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"name\": \"hash\",\n                \"type\": \"bytes\"\n            }\n        ],\n        \"name\": \"setContenthash\",\n        \"outputs\": [],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    }\n];\nmodule.exports = RESOLVER;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtZW5zL2xpYi9yZXNvdXJjZXMvQUJJL1Jlc29sdmVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1lbnMvbGliL3Jlc291cmNlcy9BQkkvUmVzb2x2ZXIuanM/MDQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBSRVNPTFZFUiA9IFtcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImludGVyZmFjZUlEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXM0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwic3VwcG9ydHNJbnRlcmZhY2VcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29udGVudFR5cGVzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcIkFCSVwiLFxuICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnRlbnRUeXBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRhdGFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoYXNoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXNcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJzZXRNdWx0aWhhc2hcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwibXVsdGloYXNoXCIsXG4gICAgICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXNcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwieVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJzZXRQdWJrZXlcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJjb250ZW50XCIsXG4gICAgICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicmV0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcImFkZHJcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnRlbnRUeXBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRhdGFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcInNldEFCSVwiLFxuICAgICAgICBcIm91dHB1dHNcIjogW10sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcIm5hbWVcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibmFtZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcInNldE5hbWVcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaGFzaFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJzZXRDb250ZW50XCIsXG4gICAgICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwicHVia2V5XCIsXG4gICAgICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwieFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhZGRyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcInNldEFkZHJcIixcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImVuc0FkZHJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJjb25zdHJ1Y3RvclwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiYW5vbnltb3VzXCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJBZGRyQ2hhbmdlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJldmVudFwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiYW5vbnltb3VzXCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaGFzaFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJDb250ZW50Q2hhbmdlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJldmVudFwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiYW5vbnltb3VzXCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibmFtZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcIk5hbWVDaGFuZ2VkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImV2ZW50XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnRlbnRUeXBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwibmFtZVwiOiBcIkFCSUNoYW5nZWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwiUHVia2V5Q2hhbmdlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJldmVudFwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwiYW5vbnltb3VzXCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaGFzaFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJuYW1lXCI6IFwiQ29udGVudGhhc2hDaGFuZ2VkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImV2ZW50XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJjb250ZW50aGFzaFwiLFxuICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoYXNoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXNcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm5hbWVcIjogXCJzZXRDb250ZW50aGFzaFwiLFxuICAgICAgICBcIm91dHB1dHNcIjogW10sXG4gICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICB9XG5dO1xubW9kdWxlLmV4cG9ydHMgPSBSRVNPTFZFUjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/resources/ABI/Resolver.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-iban/lib/index.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-iban/lib/index.js ***!
  \*************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file iban.js\n *\n * Details: https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol\n *\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2015\n */\n\nconst utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nconst BigNumber = __webpack_require__(/*! bn.js */ \"../../node_modules/bn.js/lib/bn.js\");\nconst leftPad = function (string, bytes) {\n    let result = string;\n    while (result.length < bytes * 2) {\n        result = '0' + result;\n    }\n    return result;\n};\n/**\n * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to\n * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.\n *\n * @method iso13616Prepare\n * @param {String} iban the IBAN\n * @returns {String} the prepared IBAN\n */\nconst iso13616Prepare = function (iban) {\n    const A = 'A'.charCodeAt(0);\n    const Z = 'Z'.charCodeAt(0);\n    iban = iban.toUpperCase();\n    iban = iban.substr(4) + iban.substr(0, 4);\n    return iban.split('').map(function (n) {\n        const code = n.charCodeAt(0);\n        if (code >= A && code <= Z) {\n            // A = 10, B = 11, ... Z = 35\n            return code - A + 10;\n        }\n        else {\n            return n;\n        }\n    }).join('');\n};\n/**\n * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.\n *\n * @method mod9710\n * @param {String} iban\n * @returns {Number}\n */\nconst mod9710 = function (iban) {\n    let remainder = iban;\n    let block;\n    while (remainder.length > 2) {\n        block = remainder.slice(0, 9);\n        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);\n    }\n    return parseInt(remainder, 10) % 97;\n};\n/**\n * This prototype should be used to create iban object from iban correct string\n *\n * @param {String} iban\n */\nclass Iban {\n    constructor(iban) {\n        this._iban = iban;\n    }\n    /**\n     * This method should be used to create an ethereum address from a direct iban address\n     *\n     * @method toAddress\n     * @param {String} iban address\n     * @return {String} the ethereum address\n     */\n    static toAddress(ib) {\n        ib = new Iban(ib);\n        if (!ib.isDirect()) {\n            throw new Error('IBAN is indirect and can\\'t be converted');\n        }\n        return ib.toAddress();\n    }\n    /**\n     * This method should be used to create iban address from an ethereum address\n     *\n     * @method toIban\n     * @param {String} address\n     * @return {String} the IBAN address\n     */\n    static toIban(address) {\n        return Iban.fromAddress(address).toString();\n    }\n    /**\n     * This method should be used to create iban object from an ethereum address\n     *\n     * @method fromAddress\n     * @param {String} address\n     * @return {Iban} the IBAN object\n     */\n    static fromAddress(address) {\n        if (!utils.isAddress(address)) {\n            throw new Error('Provided address is not a valid address: ' + address);\n        }\n        address = address.replace('0x', '').replace('0X', '');\n        const asBn = new BigNumber(address, 16);\n        const base36 = asBn.toString(36);\n        const padded = leftPad(base36, 15);\n        return Iban.fromBban(padded.toUpperCase());\n    }\n    /**\n     * Convert the passed BBAN to an IBAN for this country specification.\n     * Please note that <i>\"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account\"</i>.\n     * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits\n     *\n     * @method fromBban\n     * @param {String} bban the BBAN to convert to IBAN\n     * @returns {Iban} the IBAN object\n     */\n    static fromBban(bban) {\n        const countryCode = 'XE';\n        const remainder = mod9710(iso13616Prepare(countryCode + '00' + bban));\n        const checkDigit = ('0' + (98 - remainder)).slice(-2);\n        return new Iban(countryCode + checkDigit + bban);\n    }\n    /**\n     * Should be used to create IBAN object for given institution and identifier\n     *\n     * @method createIndirect\n     * @param {Object} options, required options are \"institution\" and \"identifier\"\n     * @return {Iban} the IBAN object\n     */\n    static createIndirect(options) {\n        return Iban.fromBban('ETH' + options.institution + options.identifier);\n    }\n    /**\n     * This method should be used to check if given string is valid iban object\n     *\n     * @method isValid\n     * @param {String} iban string\n     * @return {Boolean} true if it is valid IBAN\n     */\n    static isValid(iban) {\n        const i = new Iban(iban);\n        return i.isValid();\n    }\n    ;\n    /**\n     * Should be called to check if iban is correct\n     *\n     * @method isValid\n     * @returns {Boolean} true if it is, otherwise false\n     */\n    isValid() {\n        return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) &&\n            mod9710(iso13616Prepare(this._iban)) === 1;\n    }\n    ;\n    /**\n     * Should be called to check if iban number is direct\n     *\n     * @method isDirect\n     * @returns {Boolean} true if it is, otherwise false\n     */\n    isDirect() {\n        return this._iban.length === 34 || this._iban.length === 35;\n    }\n    ;\n    /**\n     * Should be called to check if iban number if indirect\n     *\n     * @method isIndirect\n     * @returns {Boolean} true if it is, otherwise false\n     */\n    isIndirect() {\n        return this._iban.length === 20;\n    }\n    ;\n    /**\n     * Should be called to get iban checksum\n     * Uses the mod-97-10 checksumming protocol (ISO/IEC 7064:2003)\n     *\n     * @method checksum\n     * @returns {String} checksum\n     */\n    checksum() {\n        return this._iban.substr(2, 2);\n    }\n    ;\n    /**\n     * Should be called to get institution identifier\n     * eg. XREG\n     *\n     * @method institution\n     * @returns {String} institution identifier\n     */\n    institution() {\n        return this.isIndirect() ? this._iban.substr(7, 4) : '';\n    }\n    ;\n    /**\n     * Should be called to get client identifier within institution\n     * eg. GAVOFYORK\n     *\n     * @method client\n     * @returns {String} client identifier\n     */\n    client() {\n        return this.isIndirect() ? this._iban.substr(11) : '';\n    }\n    ;\n    /**\n     * Should be called to get client direct address\n     *\n     * @method toAddress\n     * @returns {String} ethereum address\n     */\n    toAddress() {\n        if (this.isDirect()) {\n            const base36 = this._iban.substr(4);\n            const asBn = new BigNumber(base36, 36);\n            return utils.toChecksumAddress(asBn.toString(16, 20));\n        }\n        return '';\n    }\n    ;\n    toString() {\n        return this._iban;\n    }\n    ;\n}\nmodule.exports = Iban;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtaWJhbi9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyw4RkFBWTtBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyxpREFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EseUJBQXlCLEVBQUUsYUFBYSxHQUFHLFVBQVUsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1pYmFuL2xpYi9pbmRleC5qcz8yOWFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGliYW4uanNcbiAqXG4gKiBEZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0lDQVA6LUludGVyLWV4Y2hhbmdlLUNsaWVudC1BZGRyZXNzLVByb3RvY29sXG4gKlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGRhdGUgMjAxNVxuICovXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnd2ViMy11dGlscycpO1xuY29uc3QgQmlnTnVtYmVyID0gcmVxdWlyZSgnYm4uanMnKTtcbmNvbnN0IGxlZnRQYWQgPSBmdW5jdGlvbiAoc3RyaW5nLCBieXRlcykge1xuICAgIGxldCByZXN1bHQgPSBzdHJpbmc7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBieXRlcyAqIDIpIHtcbiAgICAgICAgcmVzdWx0ID0gJzAnICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogUHJlcGFyZSBhbiBJQkFOIGZvciBtb2QgOTcgY29tcHV0YXRpb24gYnkgbW92aW5nIHRoZSBmaXJzdCA0IGNoYXJzIHRvIHRoZSBlbmQgYW5kIHRyYW5zZm9ybWluZyB0aGUgbGV0dGVycyB0b1xuICogbnVtYmVycyAoQSA9IDEwLCBCID0gMTEsIC4uLiwgWiA9IDM1KSwgYXMgc3BlY2lmaWVkIGluIElTTzEzNjE2LlxuICpcbiAqIEBtZXRob2QgaXNvMTM2MTZQcmVwYXJlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhbiB0aGUgSUJBTlxuICogQHJldHVybnMge1N0cmluZ30gdGhlIHByZXBhcmVkIElCQU5cbiAqL1xuY29uc3QgaXNvMTM2MTZQcmVwYXJlID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICBjb25zdCBBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgWiA9ICdaJy5jaGFyQ29kZUF0KDApO1xuICAgIGliYW4gPSBpYmFuLnRvVXBwZXJDYXNlKCk7XG4gICAgaWJhbiA9IGliYW4uc3Vic3RyKDQpICsgaWJhbi5zdWJzdHIoMCwgNCk7XG4gICAgcmV0dXJuIGliYW4uc3BsaXQoJycpLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICBjb25zdCBjb2RlID0gbi5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAoY29kZSA+PSBBICYmIGNvZGUgPD0gWikge1xuICAgICAgICAgICAgLy8gQSA9IDEwLCBCID0gMTEsIC4uLiBaID0gMzVcbiAgICAgICAgICAgIHJldHVybiBjb2RlIC0gQSArIDEwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9KS5qb2luKCcnKTtcbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIE1PRCA5NyAxMCBvZiB0aGUgcGFzc2VkIElCQU4gYXMgc3BlY2lmaWVkIGluIElTTzcwNjQuXG4gKlxuICogQG1ldGhvZCBtb2Q5NzEwXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhblxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuY29uc3QgbW9kOTcxMCA9IGZ1bmN0aW9uIChpYmFuKSB7XG4gICAgbGV0IHJlbWFpbmRlciA9IGliYW47XG4gICAgbGV0IGJsb2NrO1xuICAgIHdoaWxlIChyZW1haW5kZXIubGVuZ3RoID4gMikge1xuICAgICAgICBibG9jayA9IHJlbWFpbmRlci5zbGljZSgwLCA5KTtcbiAgICAgICAgcmVtYWluZGVyID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgcmVtYWluZGVyLnNsaWNlKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChyZW1haW5kZXIsIDEwKSAlIDk3O1xufTtcbi8qKlxuICogVGhpcyBwcm90b3R5cGUgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGliYW4gb2JqZWN0IGZyb20gaWJhbiBjb3JyZWN0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuXG4gKi9cbmNsYXNzIEliYW4ge1xuICAgIGNvbnN0cnVjdG9yKGliYW4pIHtcbiAgICAgICAgdGhpcy5faWJhbiA9IGliYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhbiBldGhlcmV1bSBhZGRyZXNzIGZyb20gYSBkaXJlY3QgaWJhbiBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvQWRkcmVzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBldGhlcmV1bSBhZGRyZXNzXG4gICAgICovXG4gICAgc3RhdGljIHRvQWRkcmVzcyhpYikge1xuICAgICAgICBpYiA9IG5ldyBJYmFuKGliKTtcbiAgICAgICAgaWYgKCFpYi5pc0RpcmVjdCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lCQU4gaXMgaW5kaXJlY3QgYW5kIGNhblxcJ3QgYmUgY29udmVydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGliLnRvQWRkcmVzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgaWJhbiBhZGRyZXNzIGZyb20gYW4gZXRoZXJldW0gYWRkcmVzc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b0liYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElCQU4gYWRkcmVzc1xuICAgICAqL1xuICAgIHN0YXRpYyB0b0liYW4oYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gSWJhbi5mcm9tQWRkcmVzcyhhZGRyZXNzKS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgaWJhbiBvYmplY3QgZnJvbSBhbiBldGhlcmV1bSBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZyb21BZGRyZXNzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuIHtJYmFufSB0aGUgSUJBTiBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICBpZiAoIXV0aWxzLmlzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBhZGRyZXNzIGlzIG5vdCBhIHZhbGlkIGFkZHJlc3M6ICcgKyBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKCcweCcsICcnKS5yZXBsYWNlKCcwWCcsICcnKTtcbiAgICAgICAgY29uc3QgYXNCbiA9IG5ldyBCaWdOdW1iZXIoYWRkcmVzcywgMTYpO1xuICAgICAgICBjb25zdCBiYXNlMzYgPSBhc0JuLnRvU3RyaW5nKDM2KTtcbiAgICAgICAgY29uc3QgcGFkZGVkID0gbGVmdFBhZChiYXNlMzYsIDE1KTtcbiAgICAgICAgcmV0dXJuIEliYW4uZnJvbUJiYW4ocGFkZGVkLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBwYXNzZWQgQkJBTiB0byBhbiBJQkFOIGZvciB0aGlzIGNvdW50cnkgc3BlY2lmaWNhdGlvbi5cbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IDxpPlwiZ2VuZXJhdGlvbiBvZiB0aGUgSUJBTiBzaGFsbCBiZSB0aGUgZXhjbHVzaXZlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBiYW5rL2JyYW5jaCBzZXJ2aWNpbmcgdGhlIGFjY291bnRcIjwvaT4uXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgcHJlZmVycmVkIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXIjR2VuZXJhdGluZ19JQkFOX2NoZWNrX2RpZ2l0c1xuICAgICAqXG4gICAgICogQG1ldGhvZCBmcm9tQmJhblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiYmFuIHRoZSBCQkFOIHRvIGNvbnZlcnQgdG8gSUJBTlxuICAgICAqIEByZXR1cm5zIHtJYmFufSB0aGUgSUJBTiBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJiYW4oYmJhbikge1xuICAgICAgICBjb25zdCBjb3VudHJ5Q29kZSA9ICdYRSc7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IG1vZDk3MTAoaXNvMTM2MTZQcmVwYXJlKGNvdW50cnlDb2RlICsgJzAwJyArIGJiYW4pKTtcbiAgICAgICAgY29uc3QgY2hlY2tEaWdpdCA9ICgnMCcgKyAoOTggLSByZW1haW5kZXIpKS5zbGljZSgtMik7XG4gICAgICAgIHJldHVybiBuZXcgSWJhbihjb3VudHJ5Q29kZSArIGNoZWNrRGlnaXQgKyBiYmFuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIElCQU4gb2JqZWN0IGZvciBnaXZlbiBpbnN0aXR1dGlvbiBhbmQgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVJbmRpcmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLCByZXF1aXJlZCBvcHRpb25zIGFyZSBcImluc3RpdHV0aW9uXCIgYW5kIFwiaWRlbnRpZmllclwiXG4gICAgICogQHJldHVybiB7SWJhbn0gdGhlIElCQU4gb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUluZGlyZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEliYW4uZnJvbUJiYW4oJ0VUSCcgKyBvcHRpb25zLmluc3RpdHV0aW9uICsgb3B0aW9ucy5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gY2hlY2sgaWYgZ2l2ZW4gc3RyaW5nIGlzIHZhbGlkIGliYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzVmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWJhbiBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzIHZhbGlkIElCQU5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZChpYmFuKSB7XG4gICAgICAgIGNvbnN0IGkgPSBuZXcgSWJhbihpYmFuKTtcbiAgICAgICAgcmV0dXJuIGkuaXNWYWxpZCgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIGlzIGNvcnJlY3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNWYWxpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gL15YRVswLTldezJ9KEVUSFswLTlBLVpdezEzfXxbMC05QS1aXXszMCwzMX0pJC8udGVzdCh0aGlzLl9pYmFuKSAmJlxuICAgICAgICAgICAgbW9kOTcxMChpc28xMzYxNlByZXBhcmUodGhpcy5faWJhbikpID09PSAxO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIG51bWJlciBpcyBkaXJlY3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNEaXJlY3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgaXNEaXJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pYmFuLmxlbmd0aCA9PT0gMzQgfHwgdGhpcy5faWJhbi5sZW5ndGggPT09IDM1O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIG51bWJlciBpZiBpbmRpcmVjdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBpc0luZGlyZWN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIGlzSW5kaXJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pYmFuLmxlbmd0aCA9PT0gMjA7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBpYmFuIGNoZWNrc3VtXG4gICAgICogVXNlcyB0aGUgbW9kLTk3LTEwIGNoZWNrc3VtbWluZyBwcm90b2NvbCAoSVNPL0lFQyA3MDY0OjIwMDMpXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNoZWNrc3VtXG4gICAgICogQHJldHVybnMge1N0cmluZ30gY2hlY2tzdW1cbiAgICAgKi9cbiAgICBjaGVja3N1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2liYW4uc3Vic3RyKDIsIDIpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaW5zdGl0dXRpb24gaWRlbnRpZmllclxuICAgICAqIGVnLiBYUkVHXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluc3RpdHV0aW9uXG4gICAgICogQHJldHVybnMge1N0cmluZ30gaW5zdGl0dXRpb24gaWRlbnRpZmllclxuICAgICAqL1xuICAgIGluc3RpdHV0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luZGlyZWN0KCkgPyB0aGlzLl9pYmFuLnN1YnN0cig3LCA0KSA6ICcnO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgY2xpZW50IGlkZW50aWZpZXIgd2l0aGluIGluc3RpdHV0aW9uXG4gICAgICogZWcuIEdBVk9GWU9SS1xuICAgICAqXG4gICAgICogQG1ldGhvZCBjbGllbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBjbGllbnQgaWRlbnRpZmllclxuICAgICAqL1xuICAgIGNsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpID8gdGhpcy5faWJhbi5zdWJzdHIoMTEpIDogJyc7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBjbGllbnQgZGlyZWN0IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BZGRyZXNzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gZXRoZXJldW0gYWRkcmVzc1xuICAgICAqL1xuICAgIHRvQWRkcmVzcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJlY3QoKSkge1xuICAgICAgICAgICAgY29uc3QgYmFzZTM2ID0gdGhpcy5faWJhbi5zdWJzdHIoNCk7XG4gICAgICAgICAgICBjb25zdCBhc0JuID0gbmV3IEJpZ051bWJlcihiYXNlMzYsIDM2KTtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy50b0NoZWNrc3VtQWRkcmVzcyhhc0JuLnRvU3RyaW5nKDE2LCAyMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgO1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWJhbjtcbiAgICB9XG4gICAgO1xufVxubW9kdWxlLmV4cG9ydHMgPSBJYmFuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-iban/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-personal/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-personal/lib/index.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar core = __webpack_require__(/*! web3-core */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\");\nvar Method = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar Net = __webpack_require__(/*! web3-net */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-net/lib/index.js\");\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar Personal = function Personal() {\n    var _this = this;\n    // sets _requestmanager\n    core.packageInit(this, arguments);\n    this.net = new Net(this);\n    var defaultAccount = null;\n    var defaultBlock = 'latest';\n    Object.defineProperty(this, 'defaultAccount', {\n        get: function () {\n            return defaultAccount;\n        },\n        set: function (val) {\n            if (val) {\n                defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n            }\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.defaultAccount = defaultAccount;\n            });\n            return val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultBlock', {\n        get: function () {\n            return defaultBlock;\n        },\n        set: function (val) {\n            defaultBlock = val;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.defaultBlock = defaultBlock;\n            });\n            return val;\n        },\n        enumerable: true\n    });\n    var methods = [\n        new Method({\n            name: 'getAccounts',\n            call: 'personal_listAccounts',\n            params: 0,\n            outputFormatter: utils.toChecksumAddress\n        }),\n        new Method({\n            name: 'newAccount',\n            call: 'personal_newAccount',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: utils.toChecksumAddress\n        }),\n        new Method({\n            name: 'unlockAccount',\n            call: 'personal_unlockAccount',\n            params: 3,\n            inputFormatter: [formatters.inputAddressFormatter, null, null]\n        }),\n        new Method({\n            name: 'lockAccount',\n            call: 'personal_lockAccount',\n            params: 1,\n            inputFormatter: [formatters.inputAddressFormatter]\n        }),\n        new Method({\n            name: 'importRawKey',\n            call: 'personal_importRawKey',\n            params: 2\n        }),\n        new Method({\n            name: 'sendTransaction',\n            call: 'personal_sendTransaction',\n            params: 2,\n            inputFormatter: [formatters.inputTransactionFormatter, null]\n        }),\n        new Method({\n            name: 'signTransaction',\n            call: 'personal_signTransaction',\n            params: 2,\n            inputFormatter: [formatters.inputTransactionFormatter, null]\n        }),\n        new Method({\n            name: 'sign',\n            call: 'personal_sign',\n            params: 3,\n            inputFormatter: [formatters.inputSignFormatter, formatters.inputAddressFormatter, null]\n        }),\n        new Method({\n            name: 'ecRecover',\n            call: 'personal_ecRecover',\n            params: 2,\n            inputFormatter: [formatters.inputSignFormatter, null]\n        })\n    ];\n    methods.forEach(function (method) {\n        method.attachToObject(_this);\n        method.setRequestManager(_this._requestManager);\n        method.defaultBlock = _this.defaultBlock;\n        method.defaultAccount = _this.defaultAccount;\n    });\n};\ncore.addProviders(Personal);\nmodule.exports = Personal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgtcGVyc29uYWwvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixXQUFXLG1CQUFPLENBQUMsNEZBQVc7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDBHQUFrQjtBQUN2QyxZQUFZLG1CQUFPLENBQUMsOEZBQVk7QUFDaEMsVUFBVSxtQkFBTyxDQUFDLDBGQUFVO0FBQzVCLGlCQUFpQiw4SUFBdUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1wZXJzb25hbC9saWIvaW5kZXguanM/NjE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViMy1jb3JlJyk7XG52YXIgTWV0aG9kID0gcmVxdWlyZSgnd2ViMy1jb3JlLW1ldGhvZCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnd2ViMy11dGlscycpO1xudmFyIE5ldCA9IHJlcXVpcmUoJ3dlYjMtbmV0Jyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZm9ybWF0dGVycztcbnZhciBQZXJzb25hbCA9IGZ1bmN0aW9uIFBlcnNvbmFsKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gc2V0cyBfcmVxdWVzdG1hbmFnZXJcbiAgICBjb3JlLnBhY2thZ2VJbml0KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5uZXQgPSBuZXcgTmV0KHRoaXMpO1xuICAgIHZhciBkZWZhdWx0QWNjb3VudCA9IG51bGw7XG4gICAgdmFyIGRlZmF1bHRCbG9jayA9ICdsYXRlc3QnO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdEFjY291bnQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRBY2NvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjb3VudCA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzKGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIGRlZmF1bHRCbG9ja1xuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuZGVmYXVsdEFjY291bnQgPSBkZWZhdWx0QWNjb3VudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdEJsb2NrJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QmxvY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZGVmYXVsdEJsb2NrID0gdmFsO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGRlZmF1bHRCbG9ja1xuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuZGVmYXVsdEJsb2NrID0gZGVmYXVsdEJsb2NrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIG1ldGhvZHMgPSBbXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEFjY291bnRzJyxcbiAgICAgICAgICAgIGNhbGw6ICdwZXJzb25hbF9saXN0QWNjb3VudHMnLFxuICAgICAgICAgICAgcGFyYW1zOiAwLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0NoZWNrc3VtQWRkcmVzc1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnbmV3QWNjb3VudCcsXG4gICAgICAgICAgICBjYWxsOiAncGVyc29uYWxfbmV3QWNjb3VudCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0NoZWNrc3VtQWRkcmVzc1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAndW5sb2NrQWNjb3VudCcsXG4gICAgICAgICAgICBjYWxsOiAncGVyc29uYWxfdW5sb2NrQWNjb3VudCcsXG4gICAgICAgICAgICBwYXJhbXM6IDMsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBudWxsLCBudWxsXVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnbG9ja0FjY291bnQnLFxuICAgICAgICAgICAgY2FsbDogJ3BlcnNvbmFsX2xvY2tBY2NvdW50JyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXJdXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdpbXBvcnRSYXdLZXknLFxuICAgICAgICAgICAgY2FsbDogJ3BlcnNvbmFsX2ltcG9ydFJhd0tleScsXG4gICAgICAgICAgICBwYXJhbXM6IDJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICBjYWxsOiAncGVyc29uYWxfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLCBudWxsXVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnc2lnblRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIGNhbGw6ICdwZXJzb25hbF9zaWduVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIsIG51bGxdXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdzaWduJyxcbiAgICAgICAgICAgIGNhbGw6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dFNpZ25Gb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBudWxsXVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZWNSZWNvdmVyJyxcbiAgICAgICAgICAgIGNhbGw6ICdwZXJzb25hbF9lY1JlY292ZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0U2lnbkZvcm1hdHRlciwgbnVsbF1cbiAgICAgICAgfSlcbiAgICBdO1xuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChfdGhpcyk7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihfdGhpcy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICBtZXRob2QuZGVmYXVsdEJsb2NrID0gX3RoaXMuZGVmYXVsdEJsb2NrO1xuICAgICAgICBtZXRob2QuZGVmYXVsdEFjY291bnQgPSBfdGhpcy5kZWZhdWx0QWNjb3VudDtcbiAgICB9KTtcbn07XG5jb3JlLmFkZFByb3ZpZGVycyhQZXJzb25hbCk7XG5tb2R1bGUuZXhwb3J0cyA9IFBlcnNvbmFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-personal/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/getNetworkType.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/getNetworkType.js ***!
  \*****************************************************************************************/
/***/ (function(module) {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file getNetworkType.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar getNetworkType = function (callback) {\n    var _this = this, id;\n    return this.net.getId()\n        .then(function (givenId) {\n        id = givenId;\n        return _this.getBlock(0);\n    })\n        .then(function (genesis) {\n        var returnValue = 'private';\n        if (genesis.hash === '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3' &&\n            id === 1) {\n            returnValue = 'main';\n        }\n        if (genesis.hash === '0cd786a2425d16f152c658316c423e6ce1181e15c3295826d7c9904cba9ce303' &&\n            id === 2) {\n            returnValue = 'morden';\n        }\n        if (genesis.hash === '0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d' &&\n            id === 3) {\n            returnValue = 'ropsten';\n        }\n        if (genesis.hash === '0x6341fd3daf94b748c72ced5a5b26028f2474f5f00d824504e4fa37a75767e177' &&\n            id === 4) {\n            returnValue = 'rinkeby';\n        }\n        if (genesis.hash === '0xbf7e331f7f7c1dd2e05159666b3bf8bc7a8a3a9eb1d518969eab529dd9b88c1a' &&\n            id === 5) {\n            returnValue = 'goerli';\n        }\n        if (genesis.hash === '0xa3c565fc15c7478862d50ccd6561e3c06b24cc509bf388941c25ea985ce32cb9' &&\n            id === 42) {\n            returnValue = 'kovan';\n        }\n        if (typeof callback === 'function') {\n            callback(null, returnValue);\n        }\n        return returnValue;\n    })\n        .catch(function (err) {\n        if (typeof callback === 'function') {\n            callback(err);\n        }\n        else {\n            throw err;\n        }\n    });\n};\nmodule.exports = getNetworkType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgvbGliL2dldE5ldHdvcmtUeXBlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoL2xpYi9nZXROZXR3b3JrVHlwZS5qcz8yYTI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBnZXROZXR3b3JrVHlwZS5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBnZXROZXR3b3JrVHlwZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIGlkO1xuICAgIHJldHVybiB0aGlzLm5ldC5nZXRJZCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChnaXZlbklkKSB7XG4gICAgICAgIGlkID0gZ2l2ZW5JZDtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldEJsb2NrKDApO1xuICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChnZW5lc2lzKSB7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9ICdwcml2YXRlJztcbiAgICAgICAgaWYgKGdlbmVzaXMuaGFzaCA9PT0gJzB4ZDRlNTY3NDBmODc2YWVmOGMwMTBiODZhNDBkNWY1Njc0NWExMThkMDkwNmEzNGU2OWFlYzhjMGRiMWNiOGZhMycgJiZcbiAgICAgICAgICAgIGlkID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICdtYWluJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VuZXNpcy5oYXNoID09PSAnMGNkNzg2YTI0MjVkMTZmMTUyYzY1ODMxNmM0MjNlNmNlMTE4MWUxNWMzMjk1ODI2ZDdjOTkwNGNiYTljZTMwMycgJiZcbiAgICAgICAgICAgIGlkID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICdtb3JkZW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lc2lzLmhhc2ggPT09ICcweDQxOTQxMDIzNjgwOTIzZTBmZTRkNzRhMzRiZGFjODE0MWYyNTQwZTNhZTkwNjIzNzE4ZTQ3ZDY2ZDFjYTRhMmQnICYmXG4gICAgICAgICAgICBpZCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSAncm9wc3Rlbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVzaXMuaGFzaCA9PT0gJzB4NjM0MWZkM2RhZjk0Yjc0OGM3MmNlZDVhNWIyNjAyOGYyNDc0ZjVmMDBkODI0NTA0ZTRmYTM3YTc1NzY3ZTE3NycgJiZcbiAgICAgICAgICAgIGlkID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICdyaW5rZWJ5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VuZXNpcy5oYXNoID09PSAnMHhiZjdlMzMxZjdmN2MxZGQyZTA1MTU5NjY2YjNiZjhiYzdhOGEzYTllYjFkNTE4OTY5ZWFiNTI5ZGQ5Yjg4YzFhJyAmJlxuICAgICAgICAgICAgaWQgPT09IDUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gJ2dvZXJsaSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVzaXMuaGFzaCA9PT0gJzB4YTNjNTY1ZmMxNWM3NDc4ODYyZDUwY2NkNjU2MWUzYzA2YjI0Y2M1MDliZjM4ODk0MWMyNWVhOTg1Y2UzMmNiOScgJiZcbiAgICAgICAgICAgIGlkID09PSA0Mikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSAna292YW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJldHVyblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZ2V0TmV0d29ya1R5cGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/getNetworkType.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/index.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar core = __webpack_require__(/*! web3-core */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\");\nvar helpers = __webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\");\nvar Subscriptions = (__webpack_require__(/*! web3-core-subscriptions */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js\").subscriptions);\nvar Method = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar Net = __webpack_require__(/*! web3-net */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-net/lib/index.js\");\nvar ENS = __webpack_require__(/*! web3-eth-ens */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-ens/lib/index.js\");\nvar Personal = __webpack_require__(/*! web3-eth-personal */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-personal/lib/index.js\");\nvar BaseContract = __webpack_require__(/*! web3-eth-contract */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-contract/lib/index.js\");\nvar Iban = __webpack_require__(/*! web3-eth-iban */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-iban/lib/index.js\");\nvar Accounts = __webpack_require__(/*! web3-eth-accounts */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-accounts/lib/index.js\");\nvar abi = __webpack_require__(/*! web3-eth-abi */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-abi/lib/index.js\");\nvar getNetworkType = __webpack_require__(/*! ./getNetworkType.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/getNetworkType.js\");\nvar formatter = helpers.formatters;\nvar blockCall = function (args) {\n    return (typeof args[0] === 'string' && args[0].indexOf('0x') === 0) ? \"eth_getBlockByHash\" : \"eth_getBlockByNumber\";\n};\nvar transactionFromBlockCall = function (args) {\n    return (typeof args[0] === 'string' && args[0].indexOf('0x') === 0) ? 'eth_getTransactionByBlockHashAndIndex' : 'eth_getTransactionByBlockNumberAndIndex';\n};\nvar uncleCall = function (args) {\n    return (typeof args[0] === 'string' && args[0].indexOf('0x') === 0) ? 'eth_getUncleByBlockHashAndIndex' : 'eth_getUncleByBlockNumberAndIndex';\n};\nvar getBlockTransactionCountCall = function (args) {\n    return (typeof args[0] === 'string' && args[0].indexOf('0x') === 0) ? 'eth_getBlockTransactionCountByHash' : 'eth_getBlockTransactionCountByNumber';\n};\nvar uncleCountCall = function (args) {\n    return (typeof args[0] === 'string' && args[0].indexOf('0x') === 0) ? 'eth_getUncleCountByBlockHash' : 'eth_getUncleCountByBlockNumber';\n};\nvar Eth = function Eth() {\n    var _this = this;\n    // sets _requestmanager\n    core.packageInit(this, arguments);\n    // overwrite package setRequestManager\n    var setRequestManager = this.setRequestManager;\n    this.setRequestManager = function (manager) {\n        setRequestManager(manager);\n        _this.net.setRequestManager(manager);\n        _this.personal.setRequestManager(manager);\n        _this.accounts.setRequestManager(manager);\n        _this.Contract._requestManager = _this._requestManager;\n        _this.Contract.currentProvider = _this._provider;\n        return true;\n    };\n    // overwrite setProvider\n    var setProvider = this.setProvider;\n    this.setProvider = function () {\n        setProvider.apply(_this, arguments);\n        _this.setRequestManager(_this._requestManager);\n        // Set detectedAddress/lastSyncCheck back to null because the provider could be connected to a different chain now\n        _this.ens._detectedAddress = null;\n        _this.ens._lastSyncCheck = null;\n    };\n    var handleRevert = false;\n    var defaultAccount = null;\n    var defaultBlock = 'latest';\n    var transactionBlockTimeout = 50;\n    var transactionConfirmationBlocks = 24;\n    var transactionPollingTimeout = 750;\n    var maxListenersWarningThreshold = 100;\n    var defaultChain, defaultHardfork, defaultCommon;\n    Object.defineProperty(this, 'handleRevert', {\n        get: function () {\n            return handleRevert;\n        },\n        set: function (val) {\n            handleRevert = val;\n            // also set on the Contract object\n            _this.Contract.handleRevert = handleRevert;\n            // update handleRevert\n            methods.forEach(function (method) {\n                method.handleRevert = handleRevert;\n            });\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultCommon', {\n        get: function () {\n            return defaultCommon;\n        },\n        set: function (val) {\n            defaultCommon = val;\n            // also set on the Contract object\n            _this.Contract.defaultCommon = defaultCommon;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.defaultCommon = defaultCommon;\n            });\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultHardfork', {\n        get: function () {\n            return defaultHardfork;\n        },\n        set: function (val) {\n            defaultHardfork = val;\n            // also set on the Contract object\n            _this.Contract.defaultHardfork = defaultHardfork;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.defaultHardfork = defaultHardfork;\n            });\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultChain', {\n        get: function () {\n            return defaultChain;\n        },\n        set: function (val) {\n            defaultChain = val;\n            // also set on the Contract object\n            _this.Contract.defaultChain = defaultChain;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.defaultChain = defaultChain;\n            });\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionPollingTimeout', {\n        get: function () {\n            return transactionPollingTimeout;\n        },\n        set: function (val) {\n            transactionPollingTimeout = val;\n            // also set on the Contract object\n            _this.Contract.transactionPollingTimeout = transactionPollingTimeout;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.transactionPollingTimeout = transactionPollingTimeout;\n            });\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionConfirmationBlocks', {\n        get: function () {\n            return transactionConfirmationBlocks;\n        },\n        set: function (val) {\n            transactionConfirmationBlocks = val;\n            // also set on the Contract object\n            _this.Contract.transactionConfirmationBlocks = transactionConfirmationBlocks;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.transactionConfirmationBlocks = transactionConfirmationBlocks;\n            });\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'transactionBlockTimeout', {\n        get: function () {\n            return transactionBlockTimeout;\n        },\n        set: function (val) {\n            transactionBlockTimeout = val;\n            // also set on the Contract object\n            _this.Contract.transactionBlockTimeout = transactionBlockTimeout;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.transactionBlockTimeout = transactionBlockTimeout;\n            });\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultAccount', {\n        get: function () {\n            return defaultAccount;\n        },\n        set: function (val) {\n            if (val) {\n                defaultAccount = utils.toChecksumAddress(formatter.inputAddressFormatter(val));\n            }\n            // also set on the Contract object\n            _this.Contract.defaultAccount = defaultAccount;\n            _this.personal.defaultAccount = defaultAccount;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.defaultAccount = defaultAccount;\n            });\n            return val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'defaultBlock', {\n        get: function () {\n            return defaultBlock;\n        },\n        set: function (val) {\n            defaultBlock = val;\n            // also set on the Contract object\n            _this.Contract.defaultBlock = defaultBlock;\n            _this.personal.defaultBlock = defaultBlock;\n            // update defaultBlock\n            methods.forEach(function (method) {\n                method.defaultBlock = defaultBlock;\n            });\n            return val;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(this, 'maxListenersWarningThreshold', {\n        get: function () {\n            return maxListenersWarningThreshold;\n        },\n        set: function (val) {\n            if (_this.currentProvider && _this.currentProvider.setMaxListeners) {\n                maxListenersWarningThreshold = val;\n                _this.currentProvider.setMaxListeners(val);\n            }\n        },\n        enumerable: true\n    });\n    this.clearSubscriptions = _this._requestManager.clearSubscriptions.bind(_this._requestManager);\n    this.removeSubscriptionById = _this._requestManager.removeSubscription.bind(_this._requestManager);\n    // add net\n    this.net = new Net(this);\n    // add chain detection\n    this.net.getNetworkType = getNetworkType.bind(this);\n    // add accounts\n    this.accounts = new Accounts(this);\n    // add personal\n    this.personal = new Personal(this);\n    this.personal.defaultAccount = this.defaultAccount;\n    // set warnings threshold\n    this.maxListenersWarningThreshold = maxListenersWarningThreshold;\n    // create a proxy Contract type for this instance, as a Contract's provider\n    // is stored as a class member rather than an instance variable. If we do\n    // not create this proxy type, changing the provider in one instance of\n    // web3-eth would subsequently change the provider for _all_ contract\n    // instances!\n    var self = this;\n    var Contract = function Contract() {\n        BaseContract.apply(this, arguments);\n        // when Eth.setProvider is called, call packageInit\n        // on all contract instances instantiated via this Eth\n        // instances. This will update the currentProvider for\n        // the contract instances\n        var _this = this;\n        var setProvider = self.setProvider;\n        self.setProvider = function () {\n            setProvider.apply(self, arguments);\n            core.packageInit(_this, [self]);\n        };\n    };\n    Contract.setProvider = function () {\n        BaseContract.setProvider.apply(this, arguments);\n    };\n    // make our proxy Contract inherit from web3-eth-contract so that it has all\n    // the right functionality and so that instanceof and friends work properly\n    Contract.prototype = Object.create(BaseContract.prototype);\n    Contract.prototype.constructor = Contract;\n    // add contract\n    this.Contract = Contract;\n    this.Contract.defaultAccount = this.defaultAccount;\n    this.Contract.defaultBlock = this.defaultBlock;\n    this.Contract.transactionBlockTimeout = this.transactionBlockTimeout;\n    this.Contract.transactionConfirmationBlocks = this.transactionConfirmationBlocks;\n    this.Contract.transactionPollingTimeout = this.transactionPollingTimeout;\n    this.Contract.handleRevert = this.handleRevert;\n    this.Contract._requestManager = this._requestManager;\n    this.Contract._ethAccounts = this.accounts;\n    this.Contract.currentProvider = this._requestManager.provider;\n    // add IBAN\n    this.Iban = Iban;\n    // add ABI\n    this.abi = abi;\n    // add ENS\n    this.ens = new ENS(this);\n    var methods = [\n        new Method({\n            name: 'getNodeInfo',\n            call: 'web3_clientVersion'\n        }),\n        new Method({\n            name: 'getProtocolVersion',\n            call: 'eth_protocolVersion',\n            params: 0\n        }),\n        new Method({\n            name: 'getCoinbase',\n            call: 'eth_coinbase',\n            params: 0\n        }),\n        new Method({\n            name: 'isMining',\n            call: 'eth_mining',\n            params: 0\n        }),\n        new Method({\n            name: 'getHashrate',\n            call: 'eth_hashrate',\n            params: 0,\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'isSyncing',\n            call: 'eth_syncing',\n            params: 0,\n            outputFormatter: formatter.outputSyncingFormatter\n        }),\n        new Method({\n            name: 'getGasPrice',\n            call: 'eth_gasPrice',\n            params: 0,\n            outputFormatter: formatter.outputBigNumberFormatter\n        }),\n        new Method({\n            name: 'getFeeHistory',\n            call: 'eth_feeHistory',\n            params: 3,\n            inputFormatter: [utils.toNumber, formatter.inputBlockNumberFormatter, null]\n        }),\n        new Method({\n            name: 'getAccounts',\n            call: 'eth_accounts',\n            params: 0,\n            outputFormatter: utils.toChecksumAddress\n        }),\n        new Method({\n            name: 'getBlockNumber',\n            call: 'eth_blockNumber',\n            params: 0,\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'getBalance',\n            call: 'eth_getBalance',\n            params: 2,\n            inputFormatter: [formatter.inputAddressFormatter, formatter.inputDefaultBlockNumberFormatter],\n            outputFormatter: formatter.outputBigNumberFormatter\n        }),\n        new Method({\n            name: 'getStorageAt',\n            call: 'eth_getStorageAt',\n            params: 3,\n            inputFormatter: [formatter.inputAddressFormatter, utils.numberToHex, formatter.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatter.inputAddressFormatter, formatter.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getBlock',\n            call: blockCall,\n            params: 2,\n            inputFormatter: [formatter.inputBlockNumberFormatter, function (val) { return !!val; }],\n            outputFormatter: formatter.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getUncle',\n            call: uncleCall,\n            params: 2,\n            inputFormatter: [formatter.inputBlockNumberFormatter, utils.numberToHex],\n            outputFormatter: formatter.outputBlockFormatter,\n        }),\n        new Method({\n            name: 'getBlockTransactionCount',\n            call: getBlockTransactionCountCall,\n            params: 1,\n            inputFormatter: [formatter.inputBlockNumberFormatter],\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'getBlockUncleCount',\n            call: uncleCountCall,\n            params: 1,\n            inputFormatter: [formatter.inputBlockNumberFormatter],\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'getTransaction',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatter.outputTransactionFormatter\n        }),\n        new Method({\n            name: 'getTransactionFromBlock',\n            call: transactionFromBlockCall,\n            params: 2,\n            inputFormatter: [formatter.inputBlockNumberFormatter, utils.numberToHex],\n            outputFormatter: formatter.outputTransactionFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatter.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getTransactionCount',\n            call: 'eth_getTransactionCount',\n            params: 2,\n            inputFormatter: [formatter.inputAddressFormatter, formatter.inputDefaultBlockNumberFormatter],\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'sendSignedTransaction',\n            call: 'eth_sendRawTransaction',\n            params: 1,\n            inputFormatter: [null],\n            abiCoder: abi\n        }),\n        new Method({\n            name: 'signTransaction',\n            call: 'eth_signTransaction',\n            params: 1,\n            inputFormatter: [formatter.inputTransactionFormatter]\n        }),\n        new Method({\n            name: 'sendTransaction',\n            call: 'eth_sendTransaction',\n            params: 1,\n            inputFormatter: [formatter.inputTransactionFormatter],\n            abiCoder: abi\n        }),\n        new Method({\n            name: 'sign',\n            call: 'eth_sign',\n            params: 2,\n            inputFormatter: [formatter.inputSignFormatter, formatter.inputAddressFormatter],\n            transformPayload: function (payload) {\n                payload.params.reverse();\n                return payload;\n            }\n        }),\n        new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            inputFormatter: [formatter.inputCallFormatter, formatter.inputDefaultBlockNumberFormatter],\n            abiCoder: abi\n        }),\n        new Method({\n            name: 'estimateGas',\n            call: 'eth_estimateGas',\n            params: 1,\n            inputFormatter: [formatter.inputCallFormatter],\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'submitWork',\n            call: 'eth_submitWork',\n            params: 3\n        }),\n        new Method({\n            name: 'getWork',\n            call: 'eth_getWork',\n            params: 0\n        }),\n        new Method({\n            name: 'getPastLogs',\n            call: 'eth_getLogs',\n            params: 1,\n            inputFormatter: [formatter.inputLogFormatter],\n            outputFormatter: formatter.outputLogFormatter\n        }),\n        new Method({\n            name: 'getChainId',\n            call: 'eth_chainId',\n            params: 0,\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'requestAccounts',\n            call: 'eth_requestAccounts',\n            params: 0,\n            outputFormatter: utils.toChecksumAddress\n        }),\n        new Method({\n            name: 'getProof',\n            call: 'eth_getProof',\n            params: 3,\n            inputFormatter: [formatter.inputAddressFormatter, formatter.inputStorageKeysFormatter, formatter.inputDefaultBlockNumberFormatter],\n            outputFormatter: formatter.outputProofFormatter\n        }),\n        new Method({\n            name: 'getPendingTransactions',\n            call: 'eth_pendingTransactions',\n            params: 0,\n            outputFormatter: formatter.outputTransactionFormatter\n        }),\n        // subscriptions\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    // TODO rename on RPC side?\n                    subscriptionName: 'newHeads',\n                    params: 0,\n                    outputFormatter: formatter.outputBlockFormatter\n                },\n                'pendingTransactions': {\n                    subscriptionName: 'newPendingTransactions',\n                    params: 0\n                },\n                'logs': {\n                    params: 1,\n                    inputFormatter: [formatter.inputLogFormatter],\n                    outputFormatter: formatter.outputLogFormatter,\n                    // DUBLICATE, also in web3-eth-contract\n                    subscriptionHandler: function (output) {\n                        if (output.removed) {\n                            this.emit('changed', output);\n                        }\n                        else {\n                            this.emit('data', output);\n                        }\n                        if (typeof this.callback === 'function') {\n                            this.callback(null, output, this);\n                        }\n                    }\n                },\n                'syncing': {\n                    params: 0,\n                    outputFormatter: formatter.outputSyncingFormatter,\n                    subscriptionHandler: function (output) {\n                        var _this = this;\n                        // fire TRUE at start\n                        if (this._isSyncing !== true) {\n                            this._isSyncing = true;\n                            this.emit('changed', _this._isSyncing);\n                            if (typeof this.callback === 'function') {\n                                this.callback(null, _this._isSyncing, this);\n                            }\n                            setTimeout(function () {\n                                _this.emit('data', output);\n                                if (typeof _this.callback === 'function') {\n                                    _this.callback(null, output, _this);\n                                }\n                            }, 0);\n                            // fire sync status\n                        }\n                        else {\n                            this.emit('data', output);\n                            if (typeof _this.callback === 'function') {\n                                this.callback(null, output, this);\n                            }\n                            // wait for some time before fireing the FALSE\n                            clearTimeout(this._isSyncingTimeout);\n                            this._isSyncingTimeout = setTimeout(function () {\n                                if (output.currentBlock > output.highestBlock - 200) {\n                                    _this._isSyncing = false;\n                                    _this.emit('changed', _this._isSyncing);\n                                    if (typeof _this.callback === 'function') {\n                                        _this.callback(null, _this._isSyncing, _this);\n                                    }\n                                }\n                            }, 500);\n                        }\n                    }\n                }\n            }\n        })\n    ];\n    methods.forEach(function (method) {\n        method.attachToObject(_this);\n        method.setRequestManager(_this._requestManager, _this.accounts); // second param is the eth.accounts module (necessary for signing transactions locally)\n        method.defaultBlock = _this.defaultBlock;\n        method.defaultAccount = _this.defaultAccount;\n        method.transactionBlockTimeout = _this.transactionBlockTimeout;\n        method.transactionConfirmationBlocks = _this.transactionConfirmationBlocks;\n        method.transactionPollingTimeout = _this.transactionPollingTimeout;\n        method.handleRevert = _this.handleRevert;\n    });\n};\n// Adds the static givenProvider and providers property to the Eth module\ncore.addProviders(Eth);\nmodule.exports = Eth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1ldGgvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixXQUFXLG1CQUFPLENBQUMsNEZBQVc7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLDRHQUFtQjtBQUN6QyxvQkFBb0IsNkpBQWdEO0FBQ3BFLGFBQWEsbUJBQU8sQ0FBQywwR0FBa0I7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLDhGQUFZO0FBQ2hDLFVBQVUsbUJBQU8sQ0FBQywwRkFBVTtBQUM1QixVQUFVLG1CQUFPLENBQUMsa0dBQWM7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLDRHQUFtQjtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyw0R0FBbUI7QUFDOUMsV0FBVyxtQkFBTyxDQUFDLG9HQUFlO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyw0R0FBbUI7QUFDMUMsVUFBVSxtQkFBTyxDQUFDLGtHQUFjO0FBQ2hDLHFCQUFxQixtQkFBTyxDQUFDLDhHQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixlQUFlO0FBQ2xHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoL2xpYi9pbmRleC5qcz9mZGI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViMy1jb3JlJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJyk7XG52YXIgU3Vic2NyaXB0aW9ucyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1zdWJzY3JpcHRpb25zJykuc3Vic2NyaXB0aW9ucztcbnZhciBNZXRob2QgPSByZXF1aXJlKCd3ZWIzLWNvcmUtbWV0aG9kJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgTmV0ID0gcmVxdWlyZSgnd2ViMy1uZXQnKTtcbnZhciBFTlMgPSByZXF1aXJlKCd3ZWIzLWV0aC1lbnMnKTtcbnZhciBQZXJzb25hbCA9IHJlcXVpcmUoJ3dlYjMtZXRoLXBlcnNvbmFsJyk7XG52YXIgQmFzZUNvbnRyYWN0ID0gcmVxdWlyZSgnd2ViMy1ldGgtY29udHJhY3QnKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnd2ViMy1ldGgtaWJhbicpO1xudmFyIEFjY291bnRzID0gcmVxdWlyZSgnd2ViMy1ldGgtYWNjb3VudHMnKTtcbnZhciBhYmkgPSByZXF1aXJlKCd3ZWIzLWV0aC1hYmknKTtcbnZhciBnZXROZXR3b3JrVHlwZSA9IHJlcXVpcmUoJy4vZ2V0TmV0d29ya1R5cGUuanMnKTtcbnZhciBmb3JtYXR0ZXIgPSBoZWxwZXJzLmZvcm1hdHRlcnM7XG52YXIgYmxvY2tDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiA6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIjtcbn07XG52YXIgdHJhbnNhY3Rpb25Gcm9tQmxvY2tDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgnIDogJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCc7XG59O1xudmFyIHVuY2xlQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JyA6ICdldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgnO1xufTtcbnZhciBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnIDogJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic7XG59O1xudmFyIHVuY2xlQ291bnRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2gnIDogJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja051bWJlcic7XG59O1xudmFyIEV0aCA9IGZ1bmN0aW9uIEV0aCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIHNldHMgX3JlcXVlc3RtYW5hZ2VyXG4gICAgY29yZS5wYWNrYWdlSW5pdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIG92ZXJ3cml0ZSBwYWNrYWdlIHNldFJlcXVlc3RNYW5hZ2VyXG4gICAgdmFyIHNldFJlcXVlc3RNYW5hZ2VyID0gdGhpcy5zZXRSZXF1ZXN0TWFuYWdlcjtcbiAgICB0aGlzLnNldFJlcXVlc3RNYW5hZ2VyID0gZnVuY3Rpb24gKG1hbmFnZXIpIHtcbiAgICAgICAgc2V0UmVxdWVzdE1hbmFnZXIobWFuYWdlcik7XG4gICAgICAgIF90aGlzLm5ldC5zZXRSZXF1ZXN0TWFuYWdlcihtYW5hZ2VyKTtcbiAgICAgICAgX3RoaXMucGVyc29uYWwuc2V0UmVxdWVzdE1hbmFnZXIobWFuYWdlcik7XG4gICAgICAgIF90aGlzLmFjY291bnRzLnNldFJlcXVlc3RNYW5hZ2VyKG1hbmFnZXIpO1xuICAgICAgICBfdGhpcy5Db250cmFjdC5fcmVxdWVzdE1hbmFnZXIgPSBfdGhpcy5fcmVxdWVzdE1hbmFnZXI7XG4gICAgICAgIF90aGlzLkNvbnRyYWN0LmN1cnJlbnRQcm92aWRlciA9IF90aGlzLl9wcm92aWRlcjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBvdmVyd3JpdGUgc2V0UHJvdmlkZXJcbiAgICB2YXIgc2V0UHJvdmlkZXIgPSB0aGlzLnNldFByb3ZpZGVyO1xuICAgIHRoaXMuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFByb3ZpZGVyLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBfdGhpcy5zZXRSZXF1ZXN0TWFuYWdlcihfdGhpcy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAvLyBTZXQgZGV0ZWN0ZWRBZGRyZXNzL2xhc3RTeW5jQ2hlY2sgYmFjayB0byBudWxsIGJlY2F1c2UgdGhlIHByb3ZpZGVyIGNvdWxkIGJlIGNvbm5lY3RlZCB0byBhIGRpZmZlcmVudCBjaGFpbiBub3dcbiAgICAgICAgX3RoaXMuZW5zLl9kZXRlY3RlZEFkZHJlc3MgPSBudWxsO1xuICAgICAgICBfdGhpcy5lbnMuX2xhc3RTeW5jQ2hlY2sgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGhhbmRsZVJldmVydCA9IGZhbHNlO1xuICAgIHZhciBkZWZhdWx0QWNjb3VudCA9IG51bGw7XG4gICAgdmFyIGRlZmF1bHRCbG9jayA9ICdsYXRlc3QnO1xuICAgIHZhciB0cmFuc2FjdGlvbkJsb2NrVGltZW91dCA9IDUwO1xuICAgIHZhciB0cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyA9IDI0O1xuICAgIHZhciB0cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ID0gNzUwO1xuICAgIHZhciBtYXhMaXN0ZW5lcnNXYXJuaW5nVGhyZXNob2xkID0gMTAwO1xuICAgIHZhciBkZWZhdWx0Q2hhaW4sIGRlZmF1bHRIYXJkZm9yaywgZGVmYXVsdENvbW1vbjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2hhbmRsZVJldmVydCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGhhbmRsZVJldmVydCA9IHZhbDtcbiAgICAgICAgICAgIC8vIGFsc28gc2V0IG9uIHRoZSBDb250cmFjdCBvYmplY3RcbiAgICAgICAgICAgIF90aGlzLkNvbnRyYWN0LmhhbmRsZVJldmVydCA9IGhhbmRsZVJldmVydDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBoYW5kbGVSZXZlcnRcbiAgICAgICAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmhhbmRsZVJldmVydCA9IGhhbmRsZVJldmVydDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWZhdWx0Q29tbW9uJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29tbW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDb21tb24gPSB2YWw7XG4gICAgICAgICAgICAvLyBhbHNvIHNldCBvbiB0aGUgQ29udHJhY3Qgb2JqZWN0XG4gICAgICAgICAgICBfdGhpcy5Db250cmFjdC5kZWZhdWx0Q29tbW9uID0gZGVmYXVsdENvbW1vbjtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBkZWZhdWx0QmxvY2tcbiAgICAgICAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmRlZmF1bHRDb21tb24gPSBkZWZhdWx0Q29tbW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRIYXJkZm9yaycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEhhcmRmb3JrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRIYXJkZm9yayA9IHZhbDtcbiAgICAgICAgICAgIC8vIGFsc28gc2V0IG9uIHRoZSBDb250cmFjdCBvYmplY3RcbiAgICAgICAgICAgIF90aGlzLkNvbnRyYWN0LmRlZmF1bHRIYXJkZm9yayA9IGRlZmF1bHRIYXJkZm9yaztcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBkZWZhdWx0QmxvY2tcbiAgICAgICAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmRlZmF1bHRIYXJkZm9yayA9IGRlZmF1bHRIYXJkZm9yaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWZhdWx0Q2hhaW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDaGFpbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2hhaW4gPSB2YWw7XG4gICAgICAgICAgICAvLyBhbHNvIHNldCBvbiB0aGUgQ29udHJhY3Qgb2JqZWN0XG4gICAgICAgICAgICBfdGhpcy5Db250cmFjdC5kZWZhdWx0Q2hhaW4gPSBkZWZhdWx0Q2hhaW47XG4gICAgICAgICAgICAvLyB1cGRhdGUgZGVmYXVsdEJsb2NrXG4gICAgICAgICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5kZWZhdWx0Q2hhaW4gPSBkZWZhdWx0Q2hhaW47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ID0gdmFsO1xuICAgICAgICAgICAgLy8gYWxzbyBzZXQgb24gdGhlIENvbnRyYWN0IG9iamVjdFxuICAgICAgICAgICAgX3RoaXMuQ29udHJhY3QudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCA9IHRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQ7XG4gICAgICAgICAgICAvLyB1cGRhdGUgZGVmYXVsdEJsb2NrXG4gICAgICAgICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIG1ldGhvZC50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ID0gdHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgPSB2YWw7XG4gICAgICAgICAgICAvLyBhbHNvIHNldCBvbiB0aGUgQ29udHJhY3Qgb2JqZWN0XG4gICAgICAgICAgICBfdGhpcy5Db250cmFjdC50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyA9IHRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGRlZmF1bHRCbG9ja1xuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgPSB0cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0cmFuc2FjdGlvbkJsb2NrVGltZW91dCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgPSB2YWw7XG4gICAgICAgICAgICAvLyBhbHNvIHNldCBvbiB0aGUgQ29udHJhY3Qgb2JqZWN0XG4gICAgICAgICAgICBfdGhpcy5Db250cmFjdC50cmFuc2FjdGlvbkJsb2NrVGltZW91dCA9IHRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0O1xuICAgICAgICAgICAgLy8gdXBkYXRlIGRlZmF1bHRCbG9ja1xuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgPSB0cmFuc2FjdGlvbkJsb2NrVGltZW91dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWZhdWx0QWNjb3VudCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEFjY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBY2NvdW50ID0gdXRpbHMudG9DaGVja3N1bUFkZHJlc3MoZm9ybWF0dGVyLmlucHV0QWRkcmVzc0Zvcm1hdHRlcih2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsc28gc2V0IG9uIHRoZSBDb250cmFjdCBvYmplY3RcbiAgICAgICAgICAgIF90aGlzLkNvbnRyYWN0LmRlZmF1bHRBY2NvdW50ID0gZGVmYXVsdEFjY291bnQ7XG4gICAgICAgICAgICBfdGhpcy5wZXJzb25hbC5kZWZhdWx0QWNjb3VudCA9IGRlZmF1bHRBY2NvdW50O1xuICAgICAgICAgICAgLy8gdXBkYXRlIGRlZmF1bHRCbG9ja1xuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuZGVmYXVsdEFjY291bnQgPSBkZWZhdWx0QWNjb3VudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdEJsb2NrJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QmxvY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZGVmYXVsdEJsb2NrID0gdmFsO1xuICAgICAgICAgICAgLy8gYWxzbyBzZXQgb24gdGhlIENvbnRyYWN0IG9iamVjdFxuICAgICAgICAgICAgX3RoaXMuQ29udHJhY3QuZGVmYXVsdEJsb2NrID0gZGVmYXVsdEJsb2NrO1xuICAgICAgICAgICAgX3RoaXMucGVyc29uYWwuZGVmYXVsdEJsb2NrID0gZGVmYXVsdEJsb2NrO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGRlZmF1bHRCbG9ja1xuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuZGVmYXVsdEJsb2NrID0gZGVmYXVsdEJsb2NrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtYXhMaXN0ZW5lcnNXYXJuaW5nVGhyZXNob2xkJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhMaXN0ZW5lcnNXYXJuaW5nVGhyZXNob2xkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50UHJvdmlkZXIgJiYgX3RoaXMuY3VycmVudFByb3ZpZGVyLnNldE1heExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIG1heExpc3RlbmVyc1dhcm5pbmdUaHJlc2hvbGQgPSB2YWw7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFByb3ZpZGVyLnNldE1heExpc3RlbmVycyh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbnMgPSBfdGhpcy5fcmVxdWVzdE1hbmFnZXIuY2xlYXJTdWJzY3JpcHRpb25zLmJpbmQoX3RoaXMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbkJ5SWQgPSBfdGhpcy5fcmVxdWVzdE1hbmFnZXIucmVtb3ZlU3Vic2NyaXB0aW9uLmJpbmQoX3RoaXMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICAvLyBhZGQgbmV0XG4gICAgdGhpcy5uZXQgPSBuZXcgTmV0KHRoaXMpO1xuICAgIC8vIGFkZCBjaGFpbiBkZXRlY3Rpb25cbiAgICB0aGlzLm5ldC5nZXROZXR3b3JrVHlwZSA9IGdldE5ldHdvcmtUeXBlLmJpbmQodGhpcyk7XG4gICAgLy8gYWRkIGFjY291bnRzXG4gICAgdGhpcy5hY2NvdW50cyA9IG5ldyBBY2NvdW50cyh0aGlzKTtcbiAgICAvLyBhZGQgcGVyc29uYWxcbiAgICB0aGlzLnBlcnNvbmFsID0gbmV3IFBlcnNvbmFsKHRoaXMpO1xuICAgIHRoaXMucGVyc29uYWwuZGVmYXVsdEFjY291bnQgPSB0aGlzLmRlZmF1bHRBY2NvdW50O1xuICAgIC8vIHNldCB3YXJuaW5ncyB0aHJlc2hvbGRcbiAgICB0aGlzLm1heExpc3RlbmVyc1dhcm5pbmdUaHJlc2hvbGQgPSBtYXhMaXN0ZW5lcnNXYXJuaW5nVGhyZXNob2xkO1xuICAgIC8vIGNyZWF0ZSBhIHByb3h5IENvbnRyYWN0IHR5cGUgZm9yIHRoaXMgaW5zdGFuY2UsIGFzIGEgQ29udHJhY3QncyBwcm92aWRlclxuICAgIC8vIGlzIHN0b3JlZCBhcyBhIGNsYXNzIG1lbWJlciByYXRoZXIgdGhhbiBhbiBpbnN0YW5jZSB2YXJpYWJsZS4gSWYgd2UgZG9cbiAgICAvLyBub3QgY3JlYXRlIHRoaXMgcHJveHkgdHlwZSwgY2hhbmdpbmcgdGhlIHByb3ZpZGVyIGluIG9uZSBpbnN0YW5jZSBvZlxuICAgIC8vIHdlYjMtZXRoIHdvdWxkIHN1YnNlcXVlbnRseSBjaGFuZ2UgdGhlIHByb3ZpZGVyIGZvciBfYWxsXyBjb250cmFjdFxuICAgIC8vIGluc3RhbmNlcyFcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIENvbnRyYWN0ID0gZnVuY3Rpb24gQ29udHJhY3QoKSB7XG4gICAgICAgIEJhc2VDb250cmFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyB3aGVuIEV0aC5zZXRQcm92aWRlciBpcyBjYWxsZWQsIGNhbGwgcGFja2FnZUluaXRcbiAgICAgICAgLy8gb24gYWxsIGNvbnRyYWN0IGluc3RhbmNlcyBpbnN0YW50aWF0ZWQgdmlhIHRoaXMgRXRoXG4gICAgICAgIC8vIGluc3RhbmNlcy4gVGhpcyB3aWxsIHVwZGF0ZSB0aGUgY3VycmVudFByb3ZpZGVyIGZvclxuICAgICAgICAvLyB0aGUgY29udHJhY3QgaW5zdGFuY2VzXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZXRQcm92aWRlciA9IHNlbGYuc2V0UHJvdmlkZXI7XG4gICAgICAgIHNlbGYuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRQcm92aWRlci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgY29yZS5wYWNrYWdlSW5pdChfdGhpcywgW3NlbGZdKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbnRyYWN0LnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCYXNlQ29udHJhY3Quc2V0UHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIG1ha2Ugb3VyIHByb3h5IENvbnRyYWN0IGluaGVyaXQgZnJvbSB3ZWIzLWV0aC1jb250cmFjdCBzbyB0aGF0IGl0IGhhcyBhbGxcbiAgICAvLyB0aGUgcmlnaHQgZnVuY3Rpb25hbGl0eSBhbmQgc28gdGhhdCBpbnN0YW5jZW9mIGFuZCBmcmllbmRzIHdvcmsgcHJvcGVybHlcbiAgICBDb250cmFjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VDb250cmFjdC5wcm90b3R5cGUpO1xuICAgIENvbnRyYWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRyYWN0O1xuICAgIC8vIGFkZCBjb250cmFjdFxuICAgIHRoaXMuQ29udHJhY3QgPSBDb250cmFjdDtcbiAgICB0aGlzLkNvbnRyYWN0LmRlZmF1bHRBY2NvdW50ID0gdGhpcy5kZWZhdWx0QWNjb3VudDtcbiAgICB0aGlzLkNvbnRyYWN0LmRlZmF1bHRCbG9jayA9IHRoaXMuZGVmYXVsdEJsb2NrO1xuICAgIHRoaXMuQ29udHJhY3QudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgPSB0aGlzLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0O1xuICAgIHRoaXMuQ29udHJhY3QudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgPSB0aGlzLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzO1xuICAgIHRoaXMuQ29udHJhY3QudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCA9IHRoaXMudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dDtcbiAgICB0aGlzLkNvbnRyYWN0LmhhbmRsZVJldmVydCA9IHRoaXMuaGFuZGxlUmV2ZXJ0O1xuICAgIHRoaXMuQ29udHJhY3QuX3JlcXVlc3RNYW5hZ2VyID0gdGhpcy5fcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5Db250cmFjdC5fZXRoQWNjb3VudHMgPSB0aGlzLmFjY291bnRzO1xuICAgIHRoaXMuQ29udHJhY3QuY3VycmVudFByb3ZpZGVyID0gdGhpcy5fcmVxdWVzdE1hbmFnZXIucHJvdmlkZXI7XG4gICAgLy8gYWRkIElCQU5cbiAgICB0aGlzLkliYW4gPSBJYmFuO1xuICAgIC8vIGFkZCBBQklcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgICAvLyBhZGQgRU5TXG4gICAgdGhpcy5lbnMgPSBuZXcgRU5TKHRoaXMpO1xuICAgIHZhciBtZXRob2RzID0gW1xuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXROb2RlSW5mbycsXG4gICAgICAgICAgICBjYWxsOiAnd2ViM19jbGllbnRWZXJzaW9uJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UHJvdG9jb2xWZXJzaW9uJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfcHJvdG9jb2xWZXJzaW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0Q29pbmJhc2UnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9jb2luYmFzZScsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2lzTWluaW5nJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfbWluaW5nJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0SGFzaHJhdGUnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9oYXNocmF0ZScsXG4gICAgICAgICAgICBwYXJhbXM6IDAsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLmhleFRvTnVtYmVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdpc1N5bmNpbmcnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9zeW5jaW5nJyxcbiAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVyLm91dHB1dFN5bmNpbmdGb3JtYXR0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEdhc1ByaWNlJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgcGFyYW1zOiAwLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXIub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRGZWVIaXN0b3J5JyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZmVlSGlzdG9yeScsXG4gICAgICAgICAgICBwYXJhbXM6IDMsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW3V0aWxzLnRvTnVtYmVyLCBmb3JtYXR0ZXIuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciwgbnVsbF1cbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEFjY291bnRzJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfYWNjb3VudHMnLFxuICAgICAgICAgICAgcGFyYW1zOiAwLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0NoZWNrc3VtQWRkcmVzc1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0QmxvY2tOdW1iZXInLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9ibG9ja051bWJlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDAsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLmhleFRvTnVtYmVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRCYWxhbmNlJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0QmFsYW5jZScsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIGZvcm1hdHRlci5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlci5vdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFN0b3JhZ2VBdCcsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAgICAgICAgICBwYXJhbXM6IDMsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIHV0aWxzLm51bWJlclRvSGV4LCBmb3JtYXR0ZXIuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRDb2RlJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0Q29kZScsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIGZvcm1hdHRlci5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl1cbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEJsb2NrJyxcbiAgICAgICAgICAgIGNhbGw6IGJsb2NrQ2FsbCxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVyLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsIGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICEhdmFsOyB9XSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVyLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRVbmNsZScsXG4gICAgICAgICAgICBjYWxsOiB1bmNsZUNhbGwsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCB1dGlscy5udW1iZXJUb0hleF0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlci5vdXRwdXRCbG9ja0Zvcm1hdHRlcixcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgICAgICBjYWxsOiBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRDYWxsLFxuICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXIuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLmhleFRvTnVtYmVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRCbG9ja1VuY2xlQ291bnQnLFxuICAgICAgICAgICAgY2FsbDogdW5jbGVDb3VudENhbGwsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMuaGV4VG9OdW1iZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVyLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkZyb21CbG9jaycsXG4gICAgICAgICAgICBjYWxsOiB0cmFuc2FjdGlvbkZyb21CbG9ja0NhbGwsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCB1dGlscy5udW1iZXJUb0hleF0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlci5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlci5vdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uQ291bnQnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVyLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgZm9ybWF0dGVyLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMuaGV4VG9OdW1iZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3NlbmRTaWduZWRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdLFxuICAgICAgICAgICAgYWJpQ29kZXI6IGFiaVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnc2lnblRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfc2lnblRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVyLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdzZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXIuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl0sXG4gICAgICAgICAgICBhYmlDb2RlcjogYWJpXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdzaWduJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfc2lnbicsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dFNpZ25Gb3JtYXR0ZXIsIGZvcm1hdHRlci5pbnB1dEFkZHJlc3NGb3JtYXR0ZXJdLFxuICAgICAgICAgICAgdHJhbnNmb3JtUGF5bG9hZDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnBhcmFtcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdjYWxsJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfY2FsbCcsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlci5pbnB1dENhbGxGb3JtYXR0ZXIsIGZvcm1hdHRlci5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgICAgICBhYmlDb2RlcjogYWJpXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdlc3RpbWF0ZUdhcycsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2VzdGltYXRlR2FzJyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVyLmlucHV0Q2FsbEZvcm1hdHRlcl0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLmhleFRvTnVtYmVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdzdWJtaXRXb3JrJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfc3VibWl0V29yaycsXG4gICAgICAgICAgICBwYXJhbXM6IDNcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFdvcmsnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRXb3JrJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UGFzdExvZ3MnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRMb2dzJyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVyLmlucHV0TG9nRm9ybWF0dGVyXSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVyLm91dHB1dExvZ0Zvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0Q2hhaW5JZCcsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgICAgcGFyYW1zOiAwLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy5oZXhUb051bWJlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAncmVxdWVzdEFjY291bnRzJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfcmVxdWVzdEFjY291bnRzJyxcbiAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9DaGVja3N1bUFkZHJlc3NcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFByb29mJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0UHJvb2YnLFxuICAgICAgICAgICAgcGFyYW1zOiAzLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXIuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXIuaW5wdXRTdG9yYWdlS2V5c0Zvcm1hdHRlciwgZm9ybWF0dGVyLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVyLm91dHB1dFByb29mRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRQZW5kaW5nVHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfcGVuZGluZ1RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICBwYXJhbXM6IDAsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlci5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uc1xuICAgICAgICBuZXcgU3Vic2NyaXB0aW9ucyh7XG4gICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlJyxcbiAgICAgICAgICAgIHR5cGU6ICdldGgnLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczoge1xuICAgICAgICAgICAgICAgICduZXdCbG9ja0hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIG9uIFJQQyBzaWRlP1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25OYW1lOiAnbmV3SGVhZHMnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVyLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncGVuZGluZ1RyYW5zYWN0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uTmFtZTogJ25ld1BlbmRpbmdUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdsb2dzJzoge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVyLmlucHV0TG9nRm9ybWF0dGVyXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXIub3V0cHV0TG9nRm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgICAgICAvLyBEVUJMSUNBVEUsIGFsc28gaW4gd2ViMy1ldGgtY29udHJhY3RcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uSGFuZGxlcjogZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2VkJywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG51bGwsIG91dHB1dCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzeW5jaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVyLm91dHB1dFN5bmNpbmdGb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIFRSVUUgYXQgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1N5bmNpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlZCcsIF90aGlzLl9pc1N5bmNpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG51bGwsIF90aGlzLl9pc1N5bmNpbmcsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZGF0YScsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrKG51bGwsIG91dHB1dCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBzeW5jIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgb3V0cHV0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3Igc29tZSB0aW1lIGJlZm9yZSBmaXJlaW5nIHRoZSBGQUxTRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9pc1N5bmNpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1N5bmNpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuY3VycmVudEJsb2NrID4gb3V0cHV0LmhpZ2hlc3RCbG9jayAtIDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU3luY2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY2hhbmdlZCcsIF90aGlzLl9pc1N5bmNpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrKG51bGwsIF90aGlzLl9pc1N5bmNpbmcsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgXTtcbiAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3QoX3RoaXMpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoX3RoaXMuX3JlcXVlc3RNYW5hZ2VyLCBfdGhpcy5hY2NvdW50cyk7IC8vIHNlY29uZCBwYXJhbSBpcyB0aGUgZXRoLmFjY291bnRzIG1vZHVsZSAobmVjZXNzYXJ5IGZvciBzaWduaW5nIHRyYW5zYWN0aW9ucyBsb2NhbGx5KVxuICAgICAgICBtZXRob2QuZGVmYXVsdEJsb2NrID0gX3RoaXMuZGVmYXVsdEJsb2NrO1xuICAgICAgICBtZXRob2QuZGVmYXVsdEFjY291bnQgPSBfdGhpcy5kZWZhdWx0QWNjb3VudDtcbiAgICAgICAgbWV0aG9kLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0ID0gX3RoaXMudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQ7XG4gICAgICAgIG1ldGhvZC50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyA9IF90aGlzLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzO1xuICAgICAgICBtZXRob2QudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCA9IF90aGlzLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQ7XG4gICAgICAgIG1ldGhvZC5oYW5kbGVSZXZlcnQgPSBfdGhpcy5oYW5kbGVSZXZlcnQ7XG4gICAgfSk7XG59O1xuLy8gQWRkcyB0aGUgc3RhdGljIGdpdmVuUHJvdmlkZXIgYW5kIHByb3ZpZGVycyBwcm9wZXJ0eSB0byB0aGUgRXRoIG1vZHVsZVxuY29yZS5hZGRQcm92aWRlcnMoRXRoKTtcbm1vZHVsZS5leHBvcnRzID0gRXRoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-net/lib/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-net/lib/index.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar core = __webpack_require__(/*! web3-core */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\");\nvar Method = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar Net = function () {\n    var _this = this;\n    // sets _requestmanager\n    core.packageInit(this, arguments);\n    [\n        new Method({\n            name: 'getId',\n            call: 'net_version',\n            params: 0,\n            outputFormatter: parseInt\n        }),\n        new Method({\n            name: 'isListening',\n            call: 'net_listening',\n            params: 0\n        }),\n        new Method({\n            name: 'getPeerCount',\n            call: 'net_peerCount',\n            params: 0,\n            outputFormatter: utils.hexToNumber\n        })\n    ].forEach(function (method) {\n        method.attachToObject(_this);\n        method.setRequestManager(_this._requestManager);\n    });\n};\ncore.addProviders(Net);\nmodule.exports = Net;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1uZXQvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixXQUFXLG1CQUFPLENBQUMsNEZBQVc7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDBHQUFrQjtBQUN2QyxZQUFZLG1CQUFPLENBQUMsOEZBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLW5ldC9saWIvaW5kZXguanM/MzAyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViMy1jb3JlJyk7XG52YXIgTWV0aG9kID0gcmVxdWlyZSgnd2ViMy1jb3JlLW1ldGhvZCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnd2ViMy11dGlscycpO1xudmFyIE5ldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIHNldHMgX3JlcXVlc3RtYW5hZ2VyXG4gICAgY29yZS5wYWNrYWdlSW5pdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFtcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0SWQnLFxuICAgICAgICAgICAgY2FsbDogJ25ldF92ZXJzaW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogcGFyc2VJbnRcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2lzTGlzdGVuaW5nJyxcbiAgICAgICAgICAgIGNhbGw6ICduZXRfbGlzdGVuaW5nJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UGVlckNvdW50JyxcbiAgICAgICAgICAgIGNhbGw6ICduZXRfcGVlckNvdW50JyxcbiAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMuaGV4VG9OdW1iZXJcbiAgICAgICAgfSlcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3QoX3RoaXMpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoX3RoaXMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn07XG5jb3JlLmFkZFByb3ZpZGVycyhOZXQpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-net/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-http/lib/index.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-http/lib/index.js ***!
  \*******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/** @file httpprovider.js\n * @authors:\n *   Marek Kotewicz <marek@parity.io>\n *   Marian Oancea\n *   Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2015\n */\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar XHR2 = (__webpack_require__(/*! xhr2-cookies */ \"../../node_modules/xhr2-cookies/dist/index.js\").XMLHttpRequest); // jshint ignore: line\nvar http = __webpack_require__(/*! http */ \"./node_modules/next/dist/compiled/stream-http/index.js\");\nvar https = __webpack_require__(/*! https */ \"./node_modules/next/dist/compiled/https-browserify/index.js\");\n/**\n * HttpProvider should be used to send rpc calls over http\n */\nvar HttpProvider = function HttpProvider(host, options) {\n    options = options || {};\n    this.withCredentials = options.withCredentials || false;\n    this.timeout = options.timeout || 0;\n    this.headers = options.headers;\n    this.agent = options.agent;\n    this.connected = false;\n    // keepAlive is true unless explicitly set to false\n    const keepAlive = options.keepAlive !== false;\n    this.host = host || 'http://localhost:8545';\n    if (!this.agent) {\n        if (this.host.substring(0, 5) === \"https\") {\n            this.httpsAgent = new https.Agent({ keepAlive });\n        }\n        else {\n            this.httpAgent = new http.Agent({ keepAlive });\n        }\n    }\n};\nHttpProvider.prototype._prepareRequest = function () {\n    var request;\n    // the current runtime is a browser\n    if (typeof XMLHttpRequest !== 'undefined') {\n        request = new XMLHttpRequest();\n    }\n    else {\n        request = new XHR2();\n        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };\n        if (this.agent) {\n            agents.httpsAgent = this.agent.https;\n            agents.httpAgent = this.agent.http;\n            agents.baseUrl = this.agent.baseUrl;\n        }\n        request.nodejsSet(agents);\n    }\n    request.open('POST', this.host, true);\n    request.setRequestHeader('Content-Type', 'application/json');\n    request.timeout = this.timeout;\n    request.withCredentials = this.withCredentials;\n    if (this.headers) {\n        this.headers.forEach(function (header) {\n            request.setRequestHeader(header.name, header.value);\n        });\n    }\n    return request;\n};\n/**\n * Should be used to make async request\n *\n * @method send\n * @param {Object} payload\n * @param {Function} callback triggered on end with (err, result)\n */\nHttpProvider.prototype.send = function (payload, callback) {\n    var _this = this;\n    var request = this._prepareRequest();\n    request.onreadystatechange = function () {\n        if (request.readyState === 4 && request.timeout !== 1) {\n            var result = request.responseText;\n            var error = null;\n            try {\n                result = JSON.parse(result);\n            }\n            catch (e) {\n                error = errors.InvalidResponse(request.responseText);\n            }\n            _this.connected = true;\n            callback(error, result);\n        }\n    };\n    request.ontimeout = function () {\n        _this.connected = false;\n        callback(errors.ConnectionTimeout(this.timeout));\n    };\n    try {\n        request.send(JSON.stringify(payload));\n    }\n    catch (error) {\n        this.connected = false;\n        callback(errors.InvalidConnection(this.host));\n    }\n};\nHttpProvider.prototype.disconnect = function () {\n    //NO OP\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n * @returns {boolean}\n */\nHttpProvider.prototype.supportsSubscriptions = function () {\n    return false;\n};\nmodule.exports = HttpProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtaHR0cC9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwSUFBbUM7QUFDaEQsV0FBVyx5R0FBc0MsRUFBRTtBQUNuRCxXQUFXLG1CQUFPLENBQUMsb0VBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLDBFQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXJzLWh0dHAvbGliL2luZGV4LmpzPzI4YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBodHRwcHJvdmlkZXIuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogICBNYXJpYW4gT2FuY2VhXG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cbnZhciBlcnJvcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmVycm9ycztcbnZhciBYSFIyID0gcmVxdWlyZSgneGhyMi1jb29raWVzJykuWE1MSHR0cFJlcXVlc3Q7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbi8qKlxuICogSHR0cFByb3ZpZGVyIHNob3VsZCBiZSB1c2VkIHRvIHNlbmQgcnBjIGNhbGxzIG92ZXIgaHR0cFxuICovXG52YXIgSHR0cFByb3ZpZGVyID0gZnVuY3Rpb24gSHR0cFByb3ZpZGVyKGhvc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCAwO1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgICB0aGlzLmFnZW50ID0gb3B0aW9ucy5hZ2VudDtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIC8vIGtlZXBBbGl2ZSBpcyB0cnVlIHVubGVzcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZVxuICAgIGNvbnN0IGtlZXBBbGl2ZSA9IG9wdGlvbnMua2VlcEFsaXZlICE9PSBmYWxzZTtcbiAgICB0aGlzLmhvc3QgPSBob3N0IHx8ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnO1xuICAgIGlmICghdGhpcy5hZ2VudCkge1xuICAgICAgICBpZiAodGhpcy5ob3N0LnN1YnN0cmluZygwLCA1KSA9PT0gXCJodHRwc1wiKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHBzQWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoeyBrZWVwQWxpdmUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmh0dHBBZ2VudCA9IG5ldyBodHRwLkFnZW50KHsga2VlcEFsaXZlIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbkh0dHBQcm92aWRlci5wcm90b3R5cGUuX3ByZXBhcmVSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXF1ZXN0O1xuICAgIC8vIHRoZSBjdXJyZW50IHJ1bnRpbWUgaXMgYSBicm93c2VyXG4gICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBYSFIyKCk7XG4gICAgICAgIHZhciBhZ2VudHMgPSB7IGh0dHBzQWdlbnQ6IHRoaXMuaHR0cHNBZ2VudCwgaHR0cEFnZW50OiB0aGlzLmh0dHBBZ2VudCwgYmFzZVVybDogdGhpcy5iYXNlVXJsIH07XG4gICAgICAgIGlmICh0aGlzLmFnZW50KSB7XG4gICAgICAgICAgICBhZ2VudHMuaHR0cHNBZ2VudCA9IHRoaXMuYWdlbnQuaHR0cHM7XG4gICAgICAgICAgICBhZ2VudHMuaHR0cEFnZW50ID0gdGhpcy5hZ2VudC5odHRwO1xuICAgICAgICAgICAgYWdlbnRzLmJhc2VVcmwgPSB0aGlzLmFnZW50LmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5ub2RlanNTZXQoYWdlbnRzKTtcbiAgICB9XG4gICAgcmVxdWVzdC5vcGVuKCdQT1NUJywgdGhpcy5ob3N0LCB0cnVlKTtcbiAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmVxdWVzdC50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgaWYgKHRoaXMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLm5hbWUsIGhlYWRlci52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBlbmQgd2l0aCAoZXJyLCByZXN1bHQpXG4gKi9cbkh0dHBQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLl9wcmVwYXJlUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICYmIHJlcXVlc3QudGltZW91dCAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uVGltZW91dCh0aGlzLnRpbWVvdXQpKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3Quc2VuZChKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KSk7XG4gICAgfVxufTtcbkh0dHBQcm92aWRlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL05PIE9QXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZXNpcmVkIGJvb2xlYW4uXG4gKlxuICogQG1ldGhvZCBzdXBwb3J0c1N1YnNjcmlwdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5IdHRwUHJvdmlkZXIucHJvdG90eXBlLnN1cHBvcnRzU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBIdHRwUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-http/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ipc/lib/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ipc/lib/index.js ***!
  \******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/** @file index.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar oboe = __webpack_require__(/*! oboe */ \"../../node_modules/oboe/dist/oboe-browser.js\");\nvar IpcProvider = function IpcProvider(path, net) {\n    var _this = this;\n    this.responseCallbacks = {};\n    this.notificationCallbacks = [];\n    this.path = path;\n    this.connected = false;\n    this.connection = net.connect({ path: this.path });\n    this.addDefaultEvents();\n    // LISTEN FOR CONNECTION RESPONSES\n    var callback = function (result) {\n        /*jshint maxcomplexity: 6 */\n        var id = null;\n        // get the id which matches the returned id\n        if (Array.isArray(result)) {\n            result.forEach(function (load) {\n                if (_this.responseCallbacks[load.id])\n                    id = load.id;\n            });\n        }\n        else {\n            id = result.id;\n        }\n        // notification\n        if (!id && result.method.indexOf('_subscription') !== -1) {\n            _this.notificationCallbacks.forEach(function (callback) {\n                if (typeof callback === 'function')\n                    callback(result);\n            });\n            // fire the callback\n        }\n        else if (_this.responseCallbacks[id]) {\n            _this.responseCallbacks[id](null, result);\n            delete _this.responseCallbacks[id];\n        }\n    };\n    // use oboe.js for Sockets\n    if (net.constructor.name === 'Socket') {\n        oboe(this.connection)\n            .done(callback);\n    }\n    else {\n        this.connection.on('data', function (data) {\n            _this._parseResponse(data.toString()).forEach(callback);\n        });\n    }\n};\n/**\nWill add the error and end event to timeout existing calls\n\n@method addDefaultEvents\n*/\nIpcProvider.prototype.addDefaultEvents = function () {\n    var _this = this;\n    this.connection.on('connect', function () {\n        _this.connected = true;\n    });\n    this.connection.on('close', function () {\n        _this.connected = false;\n    });\n    this.connection.on('error', function () {\n        _this._timeout();\n    });\n    this.connection.on('end', function () {\n        _this._timeout();\n    });\n    this.connection.on('timeout', function () {\n        _this._timeout();\n    });\n};\n/**\n Will parse the response and make an array out of it.\n\n NOTE, this exists for backwards compatibility reasons.\n\n @method _parseResponse\n @param {String} data\n */\nIpcProvider.prototype._parseResponse = function (data) {\n    var _this = this, returnValues = [];\n    // DE-CHUNKER\n    var dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|');\n    dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this.lastChunk)\n            data = _this.lastChunk + data;\n        var result = null;\n        try {\n            result = JSON.parse(data);\n        }\n        catch (e) {\n            _this.lastChunk = data;\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout);\n            _this.lastChunkTimeout = setTimeout(function () {\n                _this._timeout();\n                throw errors.InvalidResponse(data);\n            }, 1000 * 15);\n            return;\n        }\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout);\n        _this.lastChunk = null;\n        if (result)\n            returnValues.push(result);\n    });\n    return returnValues;\n};\n/**\nGet the adds a callback to the responseCallbacks object,\nwhich will be called if a response matching the response Id will arrive.\n\n@method _addResponseCallback\n*/\nIpcProvider.prototype._addResponseCallback = function (payload, callback) {\n    var id = payload.id || payload[0].id;\n    var method = payload.method || payload[0].method;\n    this.responseCallbacks[id] = callback;\n    this.responseCallbacks[id].method = method;\n};\n/**\nTimeout all requests when the end/error event is fired\n\n@method _timeout\n*/\nIpcProvider.prototype._timeout = function () {\n    for (var key in this.responseCallbacks) {\n        if (this.responseCallbacks.hasOwnProperty(key)) {\n            this.responseCallbacks[key](errors.InvalidConnection('on IPC'));\n            delete this.responseCallbacks[key];\n        }\n    }\n};\n/**\n Try to reconnect\n\n @method reconnect\n */\nIpcProvider.prototype.reconnect = function () {\n    this.connection.connect({ path: this.path });\n};\nIpcProvider.prototype.send = function (payload, callback) {\n    // try reconnect, when connection is gone\n    if (!this.connection.writable)\n        this.connection.connect({ path: this.path });\n    this.connection.write(JSON.stringify(payload));\n    this._addResponseCallback(payload, callback);\n};\n/**\nSubscribes to provider events.provider\n\n@method on\n@param {String} type    'notification', 'connect', 'error', 'end' or 'data'\n@param {Function} callback   the callback to call\n*/\nIpcProvider.prototype.on = function (type, callback) {\n    if (typeof callback !== 'function')\n        throw new Error('The second parameter callback must be a function.');\n    switch (type) {\n        case 'data':\n            this.notificationCallbacks.push(callback);\n            break;\n        // adds error, end, timeout, connect\n        default:\n            this.connection.on(type, callback);\n            break;\n    }\n};\n/**\n Subscribes to provider events.provider\n\n @method on\n @param {String} type    'connect', 'error', 'end' or 'data'\n @param {Function} callback   the callback to call\n */\nIpcProvider.prototype.once = function (type, callback) {\n    if (typeof callback !== 'function')\n        throw new Error('The second parameter callback must be a function.');\n    this.connection.once(type, callback);\n};\n/**\nRemoves event listener\n\n@method removeListener\n@param {String} type    'data', 'connect', 'error', 'end' or 'data'\n@param {Function} callback   the callback to call\n*/\nIpcProvider.prototype.removeListener = function (type, callback) {\n    var _this = this;\n    switch (type) {\n        case 'data':\n            this.notificationCallbacks.forEach(function (cb, index) {\n                if (cb === callback)\n                    _this.notificationCallbacks.splice(index, 1);\n            });\n            break;\n        default:\n            this.connection.removeListener(type, callback);\n            break;\n    }\n};\n/**\nRemoves all event listeners\n\n@method removeAllListeners\n@param {String} type    'data', 'connect', 'error', 'end' or 'data'\n*/\nIpcProvider.prototype.removeAllListeners = function (type) {\n    switch (type) {\n        case 'data':\n            this.notificationCallbacks = [];\n            break;\n        default:\n            this.connection.removeAllListeners(type);\n            break;\n    }\n};\n/**\nResets the providers, clears all callbacks\n\n@method reset\n*/\nIpcProvider.prototype.reset = function () {\n    this._timeout();\n    this.notificationCallbacks = [];\n    this.connection.removeAllListeners('error');\n    this.connection.removeAllListeners('end');\n    this.connection.removeAllListeners('timeout');\n    this.addDefaultEvents();\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n * @returns {boolean}\n */\nIpcProvider.prototype.supportsSubscriptions = function () {\n    return true;\n};\nmodule.exports = IpcProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtaXBjL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsYUFBYSwwSUFBbUM7QUFDaEQsV0FBVyxtQkFBTyxDQUFDLDBEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLE1BQU0sS0FBSztBQUN4QyxvQkFBb0IsYUFBYSxNQUFNLE9BQU8sT0FBTztBQUNyRCxvQkFBb0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUNsRCxvQkFBb0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsVUFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsUUFBUTtBQUNqQixTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtaXBjL2xpYi9pbmRleC5qcz8yNTY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgaW5kZXguanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmVycm9ycztcbnZhciBvYm9lID0gcmVxdWlyZSgnb2JvZScpO1xudmFyIElwY1Byb3ZpZGVyID0gZnVuY3Rpb24gSXBjUHJvdmlkZXIocGF0aCwgbmV0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5ub3RpZmljYXRpb25DYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV0LmNvbm5lY3QoeyBwYXRoOiB0aGlzLnBhdGggfSk7XG4gICAgdGhpcy5hZGREZWZhdWx0RXZlbnRzKCk7XG4gICAgLy8gTElTVEVOIEZPUiBDT05ORUNUSU9OIFJFU1BPTlNFU1xuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuICAgICAgICB2YXIgaWQgPSBudWxsO1xuICAgICAgICAvLyBnZXQgdGhlIGlkIHdoaWNoIG1hdGNoZXMgdGhlIHJldHVybmVkIGlkXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChsb2FkKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2xvYWQuaWRdKVxuICAgICAgICAgICAgICAgICAgICBpZCA9IGxvYWQuaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gcmVzdWx0LmlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGlmaWNhdGlvblxuICAgICAgICBpZiAoIWlkICYmIHJlc3VsdC5tZXRob2QuaW5kZXhPZignX3N1YnNjcmlwdGlvbicpICE9PSAtMSkge1xuICAgICAgICAgICAgX3RoaXMubm90aWZpY2F0aW9uQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0pIHtcbiAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXShudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gdXNlIG9ib2UuanMgZm9yIFNvY2tldHNcbiAgICBpZiAobmV0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTb2NrZXQnKSB7XG4gICAgICAgIG9ib2UodGhpcy5jb25uZWN0aW9uKVxuICAgICAgICAgICAgLmRvbmUoY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLl9wYXJzZVJlc3BvbnNlKGRhdGEudG9TdHJpbmcoKSkuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbldpbGwgYWRkIHRoZSBlcnJvciBhbmQgZW5kIGV2ZW50IHRvIHRpbWVvdXQgZXhpc3RpbmcgY2FsbHNcblxuQG1ldGhvZCBhZGREZWZhdWx0RXZlbnRzXG4qL1xuSXBjUHJvdmlkZXIucHJvdG90eXBlLmFkZERlZmF1bHRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl90aW1lb3V0KCk7XG4gICAgfSk7XG59O1xuLyoqXG4gV2lsbCBwYXJzZSB0aGUgcmVzcG9uc2UgYW5kIG1ha2UgYW4gYXJyYXkgb3V0IG9mIGl0LlxuXG4gTk9URSwgdGhpcyBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuXG5cbiBAbWV0aG9kIF9wYXJzZVJlc3BvbnNlXG4gQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqL1xuSXBjUHJvdmlkZXIucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCByZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICAvLyBERS1DSFVOS0VSXG4gICAgdmFyIGRlY2h1bmtlZERhdGEgPSBkYXRhXG4gICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXHsvZywgJ318LS18eycpIC8vIH17XG4gICAgICAgIC5yZXBsYWNlKC9cXH1cXF1bXFxuXFxyXT9cXFtcXHsvZywgJ31dfC0tfFt7JykgLy8gfV1be1xuICAgICAgICAucmVwbGFjZSgvXFx9W1xcblxccl0/XFxbXFx7L2csICd9fC0tfFt7JykgLy8gfVt7XG4gICAgICAgIC5yZXBsYWNlKC9cXH1cXF1bXFxuXFxyXT9cXHsvZywgJ31dfC0tfHsnKSAvLyB9XXtcbiAgICAgICAgLnNwbGl0KCd8LS18Jyk7XG4gICAgZGVjaHVua2VkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHByZXBlbmQgdGhlIGxhc3QgY2h1bmtcbiAgICAgICAgaWYgKF90aGlzLmxhc3RDaHVuaylcbiAgICAgICAgICAgIGRhdGEgPSBfdGhpcy5sYXN0Q2h1bmsgKyBkYXRhO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVuayA9IGRhdGE7XG4gICAgICAgICAgICAvLyBzdGFydCB0aW1lb3V0IHRvIGNhbmNlbCBhbGwgcmVxdWVzdHNcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVua1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGltZW91dCgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgICAgICB9LCAxMDAwICogMTUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbmNlbCB0aW1lb3V0IGFuZCBzZXQgY2h1bmsgdG8gbnVsbFxuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMubGFzdENodW5rVGltZW91dCk7XG4gICAgICAgIF90aGlzLmxhc3RDaHVuayA9IG51bGw7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm5WYWx1ZXMucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG59O1xuLyoqXG5HZXQgdGhlIGFkZHMgYSBjYWxsYmFjayB0byB0aGUgcmVzcG9uc2VDYWxsYmFja3Mgb2JqZWN0LFxud2hpY2ggd2lsbCBiZSBjYWxsZWQgaWYgYSByZXNwb25zZSBtYXRjaGluZyB0aGUgcmVzcG9uc2UgSWQgd2lsbCBhcnJpdmUuXG5cbkBtZXRob2QgX2FkZFJlc3BvbnNlQ2FsbGJhY2tcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuX2FkZFJlc3BvbnNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWQgPSBwYXlsb2FkLmlkIHx8IHBheWxvYWRbMF0uaWQ7XG4gICAgdmFyIG1ldGhvZCA9IHBheWxvYWQubWV0aG9kIHx8IHBheWxvYWRbMF0ubWV0aG9kO1xuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0ubWV0aG9kID0gbWV0aG9kO1xufTtcbi8qKlxuVGltZW91dCBhbGwgcmVxdWVzdHMgd2hlbiB0aGUgZW5kL2Vycm9yIGV2ZW50IGlzIGZpcmVkXG5cbkBtZXRob2QgX3RpbWVvdXRcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuX3RpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucmVzcG9uc2VDYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1trZXldKGVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbignb24gSVBDJykpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVzcG9uc2VDYWxsYmFja3Nba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiBUcnkgdG8gcmVjb25uZWN0XG5cbiBAbWV0aG9kIHJlY29ubmVjdFxuICovXG5JcGNQcm92aWRlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KHsgcGF0aDogdGhpcy5wYXRoIH0pO1xufTtcbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZSlcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoeyBwYXRoOiB0aGlzLnBhdGggfSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLndyaXRlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICB0aGlzLl9hZGRSZXNwb25zZUNhbGxiYWNrKHBheWxvYWQsIGNhbGxiYWNrKTtcbn07XG4vKipcblN1YnNjcmliZXMgdG8gcHJvdmlkZXIgZXZlbnRzLnByb3ZpZGVyXG5cbkBtZXRob2Qgb25cbkBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICdub3RpZmljYXRpb24nLCAnY29ubmVjdCcsICdlcnJvcicsICdlbmQnIG9yICdkYXRhJ1xuQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICB0aGUgY2FsbGJhY2sgdG8gY2FsbFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlY29uZCBwYXJhbWV0ZXIgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGFkZHMgZXJyb3IsIGVuZCwgdGltZW91dCwgY29ubmVjdFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG4vKipcbiBTdWJzY3JpYmVzIHRvIHByb3ZpZGVyIGV2ZW50cy5wcm92aWRlclxuXG4gQG1ldGhvZCBvblxuIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICdjb25uZWN0JywgJ2Vycm9yJywgJ2VuZCcgb3IgJ2RhdGEnXG4gQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICB0aGUgY2FsbGJhY2sgdG8gY2FsbFxuICovXG5JcGNQcm92aWRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlY29uZCBwYXJhbWV0ZXIgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5vbmNlKHR5cGUsIGNhbGxiYWNrKTtcbn07XG4vKipcblJlbW92ZXMgZXZlbnQgbGlzdGVuZXJcblxuQG1ldGhvZCByZW1vdmVMaXN0ZW5lclxuQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgJ2RhdGEnLCAnY29ubmVjdCcsICdlcnJvcicsICdlbmQnIG9yICdkYXRhJ1xuQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICB0aGUgY2FsbGJhY2sgdG8gY2FsbFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25DYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiID09PSBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm90aWZpY2F0aW9uQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG4vKipcblJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuXG5AbWV0aG9kIHJlbW92ZUFsbExpc3RlbmVyc1xuQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgJ2RhdGEnLCAnY29ubmVjdCcsICdlcnJvcicsICdlbmQnIG9yICdkYXRhJ1xuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uQ2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuLyoqXG5SZXNldHMgdGhlIHByb3ZpZGVycywgY2xlYXJzIGFsbCBjYWxsYmFja3NcblxuQG1ldGhvZCByZXNldFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90aW1lb3V0KCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25DYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmNvbm5lY3Rpb24ucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3RpbWVvdXQnKTtcbiAgICB0aGlzLmFkZERlZmF1bHRFdmVudHMoKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGRlc2lyZWQgYm9vbGVhbi5cbiAqXG4gKiBAbWV0aG9kIHN1cHBvcnRzU3Vic2NyaXB0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBJcGNQcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ipc/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/helpers.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/helpers.js ***!
  \*******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")[\"Buffer\"];\nvar isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar isRN = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\nvar _btoa = null;\nvar helpers = null;\nif (isNode || isRN) {\n    _btoa = function (str) {\n        return Buffer.from(str).toString('base64');\n    };\n    var url = __webpack_require__(/*! url */ \"./node_modules/next/dist/compiled/native-url/index.js\");\n    if (url.URL) {\n        // Use the new Node 6+ API for parsing URLs that supports username/password\n        var newURL = url.URL;\n        helpers = function (url) {\n            return new newURL(url);\n        };\n    }\n    else {\n        // Web3 supports Node.js 5, so fall back to the legacy URL API if necessary\n        helpers = (__webpack_require__(/*! url */ \"./node_modules/next/dist/compiled/native-url/index.js\").parse);\n    }\n}\nelse {\n    _btoa = btoa.bind(window);\n    helpers = function (url) {\n        return new URL(url);\n    };\n}\nmodule.exports = {\n    parseURL: helpers,\n    btoa: _btoa\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2hlbHBlcnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxtREFBbUQsT0FBTyxtQkFBbUIsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGtFQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrRkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVycy13cy9saWIvaGVscGVycy5qcz9kYzY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc05vZGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG52YXIgaXNSTiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnO1xudmFyIF9idG9hID0gbnVsbDtcbnZhciBoZWxwZXJzID0gbnVsbDtcbmlmIChpc05vZGUgfHwgaXNSTikge1xuICAgIF9idG9hID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfTtcbiAgICB2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG4gICAgaWYgKHVybC5VUkwpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuZXcgTm9kZSA2KyBBUEkgZm9yIHBhcnNpbmcgVVJMcyB0aGF0IHN1cHBvcnRzIHVzZXJuYW1lL3Bhc3N3b3JkXG4gICAgICAgIHZhciBuZXdVUkwgPSB1cmwuVVJMO1xuICAgICAgICBoZWxwZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBuZXdVUkwodXJsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFdlYjMgc3VwcG9ydHMgTm9kZS5qcyA1LCBzbyBmYWxsIGJhY2sgdG8gdGhlIGxlZ2FjeSBVUkwgQVBJIGlmIG5lY2Vzc2FyeVxuICAgICAgICBoZWxwZXJzID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG4gICAgfVxufVxuZWxzZSB7XG4gICAgX2J0b2EgPSBidG9hLmJpbmQod2luZG93KTtcbiAgICBoZWxwZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYXJzZVVSTDogaGVscGVycyxcbiAgICBidG9hOiBfYnRvYVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/helpers.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/index.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file WebsocketProvider.js\n * @authors: Samuel Furter <samuel@ethereum.org>, Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2019\n */\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/node_modules/eventemitter3/index.js\");\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/helpers.js\");\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar Ws = (__webpack_require__(/*! websocket */ \"../../node_modules/websocket/lib/browser.js\").w3cwebsocket);\n/**\n * @param {string} url\n * @param {Object} options\n *\n * @constructor\n */\nvar WebsocketProvider = function WebsocketProvider(url, options) {\n    EventEmitter.call(this);\n    options = options || {};\n    this.url = url;\n    this._customTimeout = options.timeout || 1000 * 15;\n    this.headers = options.headers || {};\n    this.protocol = options.protocol || undefined;\n    this.reconnectOptions = Object.assign({\n        auto: false,\n        delay: 5000,\n        maxAttempts: false,\n        onTimeout: false\n    }, options.reconnect);\n    this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration\n    this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n    this.DATA = 'data';\n    this.CLOSE = 'close';\n    this.ERROR = 'error';\n    this.CONNECT = 'connect';\n    this.RECONNECT = 'reconnect';\n    this.connection = null;\n    this.requestQueue = new Map();\n    this.responseQueue = new Map();\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    // The w3cwebsocket implementation does not support Basic Auth\n    // username/password in the URL. So generate the basic auth header, and\n    // pass through with any additional headers supplied in constructor\n    var parsedURL = helpers.parseURL(url);\n    if (parsedURL.username && parsedURL.password) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.username + ':' + parsedURL.password);\n    }\n    // When all node core implementations that do not have the\n    // WHATWG compatible URL parser go out of service this line can be removed.\n    if (parsedURL.auth) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.auth);\n    }\n    // make property `connected` which will return the current connection status\n    Object.defineProperty(this, 'connected', {\n        get: function () {\n            return this.connection && this.connection.readyState === this.connection.OPEN;\n        },\n        enumerable: true\n    });\n    this.connect();\n};\n// Inherit from EventEmitter\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype);\nWebsocketProvider.prototype.constructor = WebsocketProvider;\n/**\n * Connects to the configured node\n *\n * @method connect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.connect = function () {\n    this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);\n    this._addSocketListeners();\n};\n/**\n * Listener for the `data` event of the underlying WebSocket object\n *\n * @method _onMessage\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onMessage = function (e) {\n    var _this = this;\n    this._parseResponse((typeof e.data === 'string') ? e.data : '').forEach(function (result) {\n        if (result.method && result.method.indexOf('_subscription') !== -1) {\n            _this.emit(_this.DATA, result);\n            return;\n        }\n        var id = result.id;\n        // get the id which matches the returned id\n        if (Array.isArray(result)) {\n            id = result[0].id;\n        }\n        if (_this.responseQueue.has(id)) {\n            if (_this.responseQueue.get(id).callback !== undefined) {\n                _this.responseQueue.get(id).callback(false, result);\n            }\n            _this.responseQueue.delete(id);\n        }\n    });\n};\n/**\n * Listener for the `open` event of the underlying WebSocket object\n *\n * @method _onConnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onConnect = function () {\n    this.emit(this.CONNECT);\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        var _this = this;\n        this.requestQueue.forEach(function (request, key) {\n            _this.send(request.payload, request.callback);\n            _this.requestQueue.delete(key);\n        });\n    }\n};\n/**\n * Listener for the `close` event of the underlying WebSocket object\n *\n * @method _onClose\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onClose = function (event) {\n    var _this = this;\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.CLOSE, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    this._removeSocketListeners();\n    this.removeAllListeners();\n};\n/**\n * Will add the required socket listeners\n *\n * @method _addSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._addSocketListeners = function () {\n    this.connection.addEventListener('message', this._onMessage.bind(this));\n    this.connection.addEventListener('open', this._onConnect.bind(this));\n    this.connection.addEventListener('close', this._onClose.bind(this));\n};\n/**\n * Will remove all socket listeners\n *\n * @method _removeSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._removeSocketListeners = function () {\n    this.connection.removeEventListener('message', this._onMessage);\n    this.connection.removeEventListener('open', this._onConnect);\n    this.connection.removeEventListener('close', this._onClose);\n};\n/**\n * Will parse the response and make an array out of it.\n *\n * @method _parseResponse\n *\n * @param {String} data\n *\n * @returns {Array}\n */\nWebsocketProvider.prototype._parseResponse = function (data) {\n    var _this = this, returnValues = [];\n    // DE-CHUNKER\n    var dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|');\n    dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this.lastChunk)\n            data = _this.lastChunk + data;\n        var result = null;\n        try {\n            result = JSON.parse(data);\n        }\n        catch (e) {\n            _this.lastChunk = data;\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout);\n            _this.lastChunkTimeout = setTimeout(function () {\n                if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n                    _this.reconnect();\n                    return;\n                }\n                _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));\n                if (_this.requestQueue.size > 0) {\n                    _this.requestQueue.forEach(function (request, key) {\n                        request.callback(errors.ConnectionTimeout(_this._customTimeout));\n                        _this.requestQueue.delete(key);\n                    });\n                }\n            }, _this._customTimeout);\n            return;\n        }\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout);\n        _this.lastChunk = null;\n        if (result)\n            returnValues.push(result);\n    });\n    return returnValues;\n};\n/**\n * Does check if the provider is connecting and will add it to the queue or will send it directly\n *\n * @method send\n *\n * @param {Object} payload\n * @param {Function} callback\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.send = function (payload, callback) {\n    var _this = this;\n    var id = payload.id;\n    var request = { payload: payload, callback: callback };\n    if (Array.isArray(payload)) {\n        id = payload[0].id;\n    }\n    if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n        this.requestQueue.set(id, request);\n        return;\n    }\n    if (this.connection.readyState !== this.connection.OPEN) {\n        this.requestQueue.delete(id);\n        this.emit(this.ERROR, errors.ConnectionNotOpenError());\n        request.callback(errors.ConnectionNotOpenError());\n        return;\n    }\n    this.responseQueue.set(id, request);\n    this.requestQueue.delete(id);\n    try {\n        this.connection.send(JSON.stringify(request.payload));\n    }\n    catch (error) {\n        request.callback(error);\n        _this.responseQueue.delete(id);\n    }\n};\n/**\n * Resets the providers, clears all callbacks\n *\n * @method reset\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reset = function () {\n    this.responseQueue.clear();\n    this.requestQueue.clear();\n    this.removeAllListeners();\n    this._removeSocketListeners();\n    this._addSocketListeners();\n};\n/**\n * Closes the current connection with the given code and reason arguments\n *\n * @method disconnect\n *\n * @param {number} code\n * @param {string} reason\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.disconnect = function (code, reason) {\n    this._removeSocketListeners();\n    this.connection.close(code || 1000, reason);\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n *\n * @returns {boolean}\n */\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n};\n/**\n * Removes the listeners and reconnects to the socket.\n *\n * @method reconnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reconnect = function () {\n    var _this = this;\n    this.reconnecting = true;\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.PendingRequestsOnReconnectingError());\n            _this.responseQueue.delete(key);\n        });\n    }\n    if (!this.reconnectOptions.maxAttempts ||\n        this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n        setTimeout(function () {\n            _this.reconnectAttempts++;\n            _this._removeSocketListeners();\n            _this.emit(_this.RECONNECT, _this.reconnectAttempts);\n            _this.connect();\n        }, this.reconnectOptions.delay);\n        return;\n    }\n    this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.MaxAttemptsReachedOnReconnectingError());\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nmodule.exports = WebsocketProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQywrSEFBZTtBQUMxQyxjQUFjLG1CQUFPLENBQUMseUdBQWM7QUFDcEMsYUFBYSwwSUFBbUM7QUFDaEQsU0FBUyxrR0FBaUM7QUFDMUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQ7QUFDM0QsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLE1BQU0sS0FBSztBQUN4QyxvQkFBb0IsYUFBYSxNQUFNLE9BQU8sT0FBTztBQUNyRCxvQkFBb0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUNsRCxvQkFBb0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2luZGV4LmpzPzY1YTYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIFdlYnNvY2tldFByb3ZpZGVyLmpzXG4gKiBAYXV0aG9yczogU2FtdWVsIEZ1cnRlciA8c2FtdWVsQGV0aGVyZXVtLm9yZz4sIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE5XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy5qcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIFdzID0gcmVxdWlyZSgnd2Vic29ja2V0JykudzNjd2Vic29ja2V0O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgV2Vic29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiBXZWJzb2NrZXRQcm92aWRlcih1cmwsIG9wdGlvbnMpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLl9jdXN0b21UaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDEwMDAgKiAxNTtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgdGhpcy5wcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMucmVjb25uZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdXRvOiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDUwMDAsXG4gICAgICAgIG1heEF0dGVtcHRzOiBmYWxzZSxcbiAgICAgICAgb25UaW1lb3V0OiBmYWxzZVxuICAgIH0sIG9wdGlvbnMucmVjb25uZWN0KTtcbiAgICB0aGlzLmNsaWVudENvbmZpZyA9IG9wdGlvbnMuY2xpZW50Q29uZmlnIHx8IHVuZGVmaW5lZDsgLy8gQWxsb3cgYSBjdXN0b20gY2xpZW50IGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyB8fCB1bmRlZmluZWQ7IC8vIEFsbG93IGEgY3VzdG9tIHJlcXVlc3Qgb3B0aW9ucyAoaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlL2Jsb2IvbWFzdGVyL2RvY3MvV2ViU29ja2V0Q2xpZW50Lm1kI2Nvbm5lY3RyZXF1ZXN0dXJsLXJlcXVlc3RlZHByb3RvY29scy1vcmlnaW4taGVhZGVycy1yZXF1ZXN0b3B0aW9ucylcbiAgICB0aGlzLkRBVEEgPSAnZGF0YSc7XG4gICAgdGhpcy5DTE9TRSA9ICdjbG9zZSc7XG4gICAgdGhpcy5FUlJPUiA9ICdlcnJvcic7XG4gICAgdGhpcy5DT05ORUNUID0gJ2Nvbm5lY3QnO1xuICAgIHRoaXMuUkVDT05ORUNUID0gJ3JlY29ubmVjdCc7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlc3BvbnNlUXVldWUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAvLyBUaGUgdzNjd2Vic29ja2V0IGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHN1cHBvcnQgQmFzaWMgQXV0aFxuICAgIC8vIHVzZXJuYW1lL3Bhc3N3b3JkIGluIHRoZSBVUkwuIFNvIGdlbmVyYXRlIHRoZSBiYXNpYyBhdXRoIGhlYWRlciwgYW5kXG4gICAgLy8gcGFzcyB0aHJvdWdoIHdpdGggYW55IGFkZGl0aW9uYWwgaGVhZGVycyBzdXBwbGllZCBpbiBjb25zdHJ1Y3RvclxuICAgIHZhciBwYXJzZWRVUkwgPSBoZWxwZXJzLnBhcnNlVVJMKHVybCk7XG4gICAgaWYgKHBhcnNlZFVSTC51c2VybmFtZSAmJiBwYXJzZWRVUkwucGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGhlbHBlcnMuYnRvYShwYXJzZWRVUkwudXNlcm5hbWUgKyAnOicgKyBwYXJzZWRVUkwucGFzc3dvcmQpO1xuICAgIH1cbiAgICAvLyBXaGVuIGFsbCBub2RlIGNvcmUgaW1wbGVtZW50YXRpb25zIHRoYXQgZG8gbm90IGhhdmUgdGhlXG4gICAgLy8gV0hBVFdHIGNvbXBhdGlibGUgVVJMIHBhcnNlciBnbyBvdXQgb2Ygc2VydmljZSB0aGlzIGxpbmUgY2FuIGJlIHJlbW92ZWQuXG4gICAgaWYgKHBhcnNlZFVSTC5hdXRoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBoZWxwZXJzLmJ0b2EocGFyc2VkVVJMLmF1dGgpO1xuICAgIH1cbiAgICAvLyBtYWtlIHByb3BlcnR5IGBjb25uZWN0ZWRgIHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25uZWN0ZWQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gdGhpcy5jb25uZWN0aW9uLk9QRU47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbn07XG4vLyBJbmhlcml0IGZyb20gRXZlbnRFbWl0dGVyXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2Vic29ja2V0UHJvdmlkZXI7XG4vKipcbiAqIENvbm5lY3RzIHRvIHRoZSBjb25maWd1cmVkIG5vZGVcbiAqXG4gKiBAbWV0aG9kIGNvbm5lY3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IFdzKHRoaXMudXJsLCB0aGlzLnByb3RvY29sLCB1bmRlZmluZWQsIHRoaXMuaGVhZGVycywgdGhpcy5yZXF1ZXN0T3B0aW9ucywgdGhpcy5jbGllbnRDb25maWcpO1xuICAgIHRoaXMuX2FkZFNvY2tldExpc3RlbmVycygpO1xufTtcbi8qKlxuICogTGlzdGVuZXIgZm9yIHRoZSBgZGF0YWAgZXZlbnQgb2YgdGhlIHVuZGVybHlpbmcgV2ViU29ja2V0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgX29uTWVzc2FnZVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9wYXJzZVJlc3BvbnNlKCh0eXBlb2YgZS5kYXRhID09PSAnc3RyaW5nJykgPyBlLmRhdGEgOiAnJykuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQubWV0aG9kICYmIHJlc3VsdC5tZXRob2QuaW5kZXhPZignX3N1YnNjcmlwdGlvbicpICE9PSAtMSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChfdGhpcy5EQVRBLCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IHJlc3VsdC5pZDtcbiAgICAgICAgLy8gZ2V0IHRoZSBpZCB3aGljaCBtYXRjaGVzIHRoZSByZXR1cm5lZCBpZFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZCA9IHJlc3VsdFswXS5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMucmVzcG9uc2VRdWV1ZS5oYXMoaWQpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmVzcG9uc2VRdWV1ZS5nZXQoaWQpLmNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmdldChpZCkuY2FsbGJhY2soZmFsc2UsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYG9wZW5gIGV2ZW50IG9mIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIF9vbkNvbm5lY3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbkNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbWl0KHRoaXMuQ09OTkVDVCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICBfdGhpcy5zZW5kKHJlcXVlc3QucGF5bG9hZCwgcmVxdWVzdC5jYWxsYmFjayk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYGNsb3NlYCBldmVudCBvZiB0aGUgdW5kZXJseWluZyBXZWJTb2NrZXQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfb25DbG9zZVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX29uQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLnJlY29ubmVjdE9wdGlvbnMuYXV0byAmJiAoIVsxMDAwLCAxMDAxXS5pbmNsdWRlcyhldmVudC5jb2RlKSB8fCBldmVudC53YXNDbGVhbiA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KHRoaXMuQ0xPU0UsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNwb25zZVF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKCdvbiBXUycsIGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIFdpbGwgYWRkIHRoZSByZXF1aXJlZCBzb2NrZXQgbGlzdGVuZXJzXG4gKlxuICogQG1ldGhvZCBfYWRkU29ja2V0TGlzdGVuZXJzXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fYWRkU29ja2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5fb25Db25uZWN0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uQ2xvc2UuYmluZCh0aGlzKSk7XG59O1xuLyoqXG4gKiBXaWxsIHJlbW92ZSBhbGwgc29ja2V0IGxpc3RlbmVyc1xuICpcbiAqIEBtZXRob2QgX3JlbW92ZVNvY2tldExpc3RlbmVyc1xuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX3JlbW92ZVNvY2tldExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLl9vbkNvbm5lY3QpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uQ2xvc2UpO1xufTtcbi8qKlxuICogV2lsbCBwYXJzZSB0aGUgcmVzcG9uc2UgYW5kIG1ha2UgYW4gYXJyYXkgb3V0IG9mIGl0LlxuICpcbiAqIEBtZXRob2QgX3BhcnNlUmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCByZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICAvLyBERS1DSFVOS0VSXG4gICAgdmFyIGRlY2h1bmtlZERhdGEgPSBkYXRhXG4gICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXHsvZywgJ318LS18eycpIC8vIH17XG4gICAgICAgIC5yZXBsYWNlKC9cXH1cXF1bXFxuXFxyXT9cXFtcXHsvZywgJ31dfC0tfFt7JykgLy8gfV1be1xuICAgICAgICAucmVwbGFjZSgvXFx9W1xcblxccl0/XFxbXFx7L2csICd9fC0tfFt7JykgLy8gfVt7XG4gICAgICAgIC5yZXBsYWNlKC9cXH1cXF1bXFxuXFxyXT9cXHsvZywgJ31dfC0tfHsnKSAvLyB9XXtcbiAgICAgICAgLnNwbGl0KCd8LS18Jyk7XG4gICAgZGVjaHVua2VkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHByZXBlbmQgdGhlIGxhc3QgY2h1bmtcbiAgICAgICAgaWYgKF90aGlzLmxhc3RDaHVuaylcbiAgICAgICAgICAgIGRhdGEgPSBfdGhpcy5sYXN0Q2h1bmsgKyBkYXRhO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVuayA9IGRhdGE7XG4gICAgICAgICAgICAvLyBzdGFydCB0aW1lb3V0IHRvIGNhbmNlbCBhbGwgcmVxdWVzdHNcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVua1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVjb25uZWN0T3B0aW9ucy5hdXRvICYmIF90aGlzLnJlY29ubmVjdE9wdGlvbnMub25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoX3RoaXMuRVJST1IsIGVycm9ycy5Db25uZWN0aW9uVGltZW91dChfdGhpcy5fY3VzdG9tVGltZW91dCkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvcnMuQ29ubmVjdGlvblRpbWVvdXQoX3RoaXMuX2N1c3RvbVRpbWVvdXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX3RoaXMuX2N1c3RvbVRpbWVvdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbmNlbCB0aW1lb3V0IGFuZCBzZXQgY2h1bmsgdG8gbnVsbFxuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMubGFzdENodW5rVGltZW91dCk7XG4gICAgICAgIF90aGlzLmxhc3RDaHVuayA9IG51bGw7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm5WYWx1ZXMucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG59O1xuLyoqXG4gKiBEb2VzIGNoZWNrIGlmIHRoZSBwcm92aWRlciBpcyBjb25uZWN0aW5nIGFuZCB3aWxsIGFkZCBpdCB0byB0aGUgcXVldWUgb3Igd2lsbCBzZW5kIGl0IGRpcmVjdGx5XG4gKlxuICogQG1ldGhvZCBzZW5kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgaWQgPSBwYXlsb2FkLmlkO1xuICAgIHZhciByZXF1ZXN0ID0geyBwYXlsb2FkOiBwYXlsb2FkLCBjYWxsYmFjazogY2FsbGJhY2sgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBpZCA9IHBheWxvYWRbMF0uaWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gdGhpcy5jb25uZWN0aW9uLkNPTk5FQ1RJTkcgfHwgdGhpcy5yZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuc2V0KGlkLCByZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgIT09IHRoaXMuY29ubmVjdGlvbi5PUEVOKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShpZCk7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLkVSUk9SLCBlcnJvcnMuQ29ubmVjdGlvbk5vdE9wZW5FcnJvcigpKTtcbiAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvcnMuQ29ubmVjdGlvbk5vdE9wZW5FcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3BvbnNlUXVldWUuc2V0KGlkLCByZXF1ZXN0KTtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZS5kZWxldGUoaWQpO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcXVlc3QucGF5bG9hZCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvcik7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlUXVldWUuZGVsZXRlKGlkKTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXNldHMgdGhlIHByb3ZpZGVycywgY2xlYXJzIGFsbCBjYWxsYmFja3NcbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc3BvbnNlUXVldWUuY2xlYXIoKTtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZS5jbGVhcigpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYWRkU29ja2V0TGlzdGVuZXJzKCk7XG59O1xuLyoqXG4gKiBDbG9zZXMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBjb2RlIGFuZCByZWFzb24gYXJndW1lbnRzXG4gKlxuICogQG1ldGhvZCBkaXNjb25uZWN0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGRlc2lyZWQgYm9vbGVhbi5cbiAqXG4gKiBAbWV0aG9kIHN1cHBvcnRzU3Vic2NyaXB0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuc3VwcG9ydHNTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogUmVtb3ZlcyB0aGUgbGlzdGVuZXJzIGFuZCByZWNvbm5lY3RzIHRvIHRoZSBzb2NrZXQuXG4gKlxuICogQG1ldGhvZCByZWNvbm5lY3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZXNwb25zZVF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLlBlbmRpbmdSZXF1ZXN0c09uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlY29ubmVjdE9wdGlvbnMubWF4QXR0ZW1wdHMgfHxcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA8IHRoaXMucmVjb25uZWN0T3B0aW9ucy5tYXhBdHRlbXB0cykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KF90aGlzLlJFQ09OTkVDVCwgX3RoaXMucmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICB9LCB0aGlzLnJlY29ubmVjdE9wdGlvbnMuZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCh0aGlzLkVSUk9SLCBlcnJvcnMuTWF4QXR0ZW1wdHNSZWFjaGVkT25SZWNvbm5lY3RpbmdFcnJvcigpKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnJlcXVlc3RRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLk1heEF0dGVtcHRzUmVhY2hlZE9uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFdlYnNvY2tldFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/node_modules/eventemitter3/index.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/node_modules/eventemitter3/index.js ***!
  \****************************************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3Mvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXJzLXdzL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzPzBiOTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-providers-ws/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-shh/lib/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-shh/lib/index.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar core = __webpack_require__(/*! web3-core */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\");\nvar Subscriptions = (__webpack_require__(/*! web3-core-subscriptions */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-subscriptions/lib/index.js\").subscriptions);\nvar Method = __webpack_require__(/*! web3-core-method */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core-method/lib/index.js\");\n// var formatters = require('web3-core-helpers').formatters;\nvar Net = __webpack_require__(/*! web3-net */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-net/lib/index.js\");\nvar Shh = function Shh() {\n    var _this = this;\n    // sets _requestmanager\n    core.packageInit(this, arguments);\n    // overwrite package setRequestManager\n    var setRequestManager = this.setRequestManager;\n    this.setRequestManager = function (manager) {\n        setRequestManager(manager);\n        _this.net.setRequestManager(manager);\n        return true;\n    };\n    // overwrite setProvider\n    var setProvider = this.setProvider;\n    this.setProvider = function () {\n        setProvider.apply(_this, arguments);\n        _this.setRequestManager(_this._requestManager);\n    };\n    this.net = new Net(this);\n    [\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'shh',\n            subscriptions: {\n                'messages': {\n                    params: 1\n                    // inputFormatter: [formatters.inputPostFormatter],\n                    // outputFormatter: formatters.outputPostFormatter\n                }\n            }\n        }),\n        new Method({\n            name: 'getVersion',\n            call: 'shh_version',\n            params: 0\n        }),\n        new Method({\n            name: 'getInfo',\n            call: 'shh_info',\n            params: 0\n        }),\n        new Method({\n            name: 'setMaxMessageSize',\n            call: 'shh_setMaxMessageSize',\n            params: 1\n        }),\n        new Method({\n            name: 'setMinPoW',\n            call: 'shh_setMinPoW',\n            params: 1\n        }),\n        new Method({\n            name: 'markTrustedPeer',\n            call: 'shh_markTrustedPeer',\n            params: 1\n        }),\n        new Method({\n            name: 'newKeyPair',\n            call: 'shh_newKeyPair',\n            params: 0\n        }),\n        new Method({\n            name: 'addPrivateKey',\n            call: 'shh_addPrivateKey',\n            params: 1\n        }),\n        new Method({\n            name: 'deleteKeyPair',\n            call: 'shh_deleteKeyPair',\n            params: 1\n        }),\n        new Method({\n            name: 'hasKeyPair',\n            call: 'shh_hasKeyPair',\n            params: 1\n        }),\n        new Method({\n            name: 'getPublicKey',\n            call: 'shh_getPublicKey',\n            params: 1\n        }),\n        new Method({\n            name: 'getPrivateKey',\n            call: 'shh_getPrivateKey',\n            params: 1\n        }),\n        new Method({\n            name: 'newSymKey',\n            call: 'shh_newSymKey',\n            params: 0\n        }),\n        new Method({\n            name: 'addSymKey',\n            call: 'shh_addSymKey',\n            params: 1\n        }),\n        new Method({\n            name: 'generateSymKeyFromPassword',\n            call: 'shh_generateSymKeyFromPassword',\n            params: 1\n        }),\n        new Method({\n            name: 'hasSymKey',\n            call: 'shh_hasSymKey',\n            params: 1\n        }),\n        new Method({\n            name: 'getSymKey',\n            call: 'shh_getSymKey',\n            params: 1\n        }),\n        new Method({\n            name: 'deleteSymKey',\n            call: 'shh_deleteSymKey',\n            params: 1\n        }),\n        new Method({\n            name: 'newMessageFilter',\n            call: 'shh_newMessageFilter',\n            params: 1\n        }),\n        new Method({\n            name: 'getFilterMessages',\n            call: 'shh_getFilterMessages',\n            params: 1\n        }),\n        new Method({\n            name: 'deleteMessageFilter',\n            call: 'shh_deleteMessageFilter',\n            params: 1\n        }),\n        new Method({\n            name: 'post',\n            call: 'shh_post',\n            params: 1,\n            inputFormatter: [null]\n        }),\n        new Method({\n            name: 'unsubscribe',\n            call: 'shh_unsubscribe',\n            params: 1\n        })\n    ].forEach(function (method) {\n        method.attachToObject(_this);\n        method.setRequestManager(_this._requestManager);\n    });\n};\nShh.prototype.clearSubscriptions = function () {\n    this._requestManager.clearSubscriptions();\n};\ncore.addProviders(Shh);\nmodule.exports = Shh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy1zaGgvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixXQUFXLG1CQUFPLENBQUMsNEZBQVc7QUFDOUIsb0JBQW9CLDZKQUFnRDtBQUNwRSxhQUFhLG1CQUFPLENBQUMsMEdBQWtCO0FBQ3ZDO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLDBGQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLXNoaC9saWIvaW5kZXguanM/MzAxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViMy1jb3JlJyk7XG52YXIgU3Vic2NyaXB0aW9ucyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1zdWJzY3JpcHRpb25zJykuc3Vic2NyaXB0aW9ucztcbnZhciBNZXRob2QgPSByZXF1aXJlKCd3ZWIzLWNvcmUtbWV0aG9kJyk7XG4vLyB2YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZm9ybWF0dGVycztcbnZhciBOZXQgPSByZXF1aXJlKCd3ZWIzLW5ldCcpO1xudmFyIFNoaCA9IGZ1bmN0aW9uIFNoaCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIHNldHMgX3JlcXVlc3RtYW5hZ2VyXG4gICAgY29yZS5wYWNrYWdlSW5pdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIG92ZXJ3cml0ZSBwYWNrYWdlIHNldFJlcXVlc3RNYW5hZ2VyXG4gICAgdmFyIHNldFJlcXVlc3RNYW5hZ2VyID0gdGhpcy5zZXRSZXF1ZXN0TWFuYWdlcjtcbiAgICB0aGlzLnNldFJlcXVlc3RNYW5hZ2VyID0gZnVuY3Rpb24gKG1hbmFnZXIpIHtcbiAgICAgICAgc2V0UmVxdWVzdE1hbmFnZXIobWFuYWdlcik7XG4gICAgICAgIF90aGlzLm5ldC5zZXRSZXF1ZXN0TWFuYWdlcihtYW5hZ2VyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBvdmVyd3JpdGUgc2V0UHJvdmlkZXJcbiAgICB2YXIgc2V0UHJvdmlkZXIgPSB0aGlzLnNldFByb3ZpZGVyO1xuICAgIHRoaXMuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFByb3ZpZGVyLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBfdGhpcy5zZXRSZXF1ZXN0TWFuYWdlcihfdGhpcy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH07XG4gICAgdGhpcy5uZXQgPSBuZXcgTmV0KHRoaXMpO1xuICAgIFtcbiAgICAgICAgbmV3IFN1YnNjcmlwdGlvbnMoe1xuICAgICAgICAgICAgbmFtZTogJ3N1YnNjcmliZScsXG4gICAgICAgICAgICB0eXBlOiAnc2hoJyxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnbWVzc2FnZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRQb3N0Rm9ybWF0dGVyXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFBvc3RGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRWZXJzaW9uJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfdmVyc2lvbicsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEluZm8nLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9pbmZvJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnc2V0TWF4TWVzc2FnZVNpemUnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9zZXRNYXhNZXNzYWdlU2l6ZScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3NldE1pblBvVycsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3NldE1pblBvVycsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ21hcmtUcnVzdGVkUGVlcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX21hcmtUcnVzdGVkUGVlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ25ld0tleVBhaXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdLZXlQYWlyJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnYWRkUHJpdmF0ZUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2FkZFByaXZhdGVLZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdkZWxldGVLZXlQYWlyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlS2V5UGFpcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc0tleVBhaXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9oYXNLZXlQYWlyJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UHVibGljS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZ2V0UHVibGljS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UHJpdmF0ZUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldFByaXZhdGVLZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICduZXdTeW1LZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdTeW1LZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAwXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdhZGRTeW1LZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9hZGRTeW1LZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCcsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dlbmVyYXRlU3ltS2V5RnJvbVBhc3N3b3JkJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnaGFzU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfaGFzU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0U3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZ2V0U3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZGVsZXRlU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnbmV3TWVzc2FnZUZpbHRlcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX25ld01lc3NhZ2VGaWx0ZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRGaWx0ZXJNZXNzYWdlcycsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldEZpbHRlck1lc3NhZ2VzJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZGVsZXRlTWVzc2FnZUZpbHRlcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2RlbGV0ZU1lc3NhZ2VGaWx0ZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdwb3N0JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfcG9zdCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICd1bnN1YnNjcmliZScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3Vuc3Vic2NyaWJlJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KVxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChfdGhpcyk7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihfdGhpcy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufTtcblNoaC5wcm90b3R5cGUuY2xlYXJTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLmNsZWFyU3Vic2NyaXB0aW9ucygpO1xufTtcbmNvcmUuYWRkUHJvdmlkZXJzKFNoaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNoaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-shh/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file utils.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar ethjsUnit = __webpack_require__(/*! ethjs-unit */ \"../../node_modules/ethjs-unit/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/utils.js\");\nvar soliditySha3 = __webpack_require__(/*! ./soliditySha3.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/soliditySha3.js\");\nvar randombytes = __webpack_require__(/*! randombytes */ \"../../node_modules/randombytes/browser.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"../../node_modules/bn.js/lib/bn.js\");\n/**\n * Fires an error in an event emitter and callback and returns the eventemitter\n *\n * @method _fireError\n * @param {Object} error a string, a error, or an object with {message, data}\n * @param {Object} emitter\n * @param {Function} reject\n * @param {Function} callback\n * @param {any} optionalData\n * @return {Object} the emitter\n */\nvar _fireError = function (error, emitter, reject, callback, optionalData) {\n    /*jshint maxcomplexity: 10 */\n    // add data if given\n    if (!!error && typeof error === 'object' && !(error instanceof Error) && error.data) {\n        if (!!error.data && typeof error.data === 'object' || Array.isArray(error.data)) {\n            error.data = JSON.stringify(error.data, null, 2);\n        }\n        error = error.message + \"\\n\" + error.data;\n    }\n    if (typeof error === 'string') {\n        error = new Error(error);\n    }\n    if (typeof callback === 'function') {\n        callback(error, optionalData);\n    }\n    if (typeof reject === 'function') {\n        // suppress uncatched error if an error listener is present\n        // OR suppress uncatched error if an callback listener is present\n        if (emitter &&\n            (typeof emitter.listeners === 'function' &&\n                emitter.listeners('error').length) || typeof callback === 'function') {\n            emitter.catch(function () { });\n        }\n        // reject later, to be able to return emitter\n        setTimeout(function () {\n            reject(error);\n        }, 1);\n    }\n    if (emitter && typeof emitter.emit === 'function') {\n        // emit later, to be able to return emitter\n        setTimeout(function () {\n            emitter.emit('error', error, optionalData);\n            emitter.removeAllListeners();\n        }, 1);\n    }\n    return emitter;\n};\n/**\n * Should be used to create full function/event name from json abi\n *\n * @method _jsonInterfaceMethodToString\n * @param {Object} json\n * @return {String} full function/event name\n */\nvar _jsonInterfaceMethodToString = function (json) {\n    if (!!json && typeof json === 'object' && json.name && json.name.indexOf('(') !== -1) {\n        return json.name;\n    }\n    return json.name + '(' + _flattenTypes(false, json.inputs).join(',') + ')';\n};\n/**\n * Should be used to flatten json abi inputs/outputs into an array of type-representing-strings\n *\n * @method _flattenTypes\n * @param {bool} includeTuple\n * @param {Object} puts\n * @return {Array} parameters as strings\n */\nvar _flattenTypes = function (includeTuple, puts) {\n    // console.log(\"entered _flattenTypes. inputs/outputs: \" + puts)\n    var types = [];\n    puts.forEach(function (param) {\n        if (typeof param.components === 'object') {\n            if (param.type.substring(0, 5) !== 'tuple') {\n                throw new Error('components found but type is not tuple; report on GitHub');\n            }\n            var suffix = '';\n            var arrayBracket = param.type.indexOf('[');\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            var result = _flattenTypes(includeTuple, param.components);\n            // console.log(\"result should have things: \" + result)\n            if (Array.isArray(result) && includeTuple) {\n                // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n                types.push('tuple(' + result.join(',') + ')' + suffix);\n            }\n            else if (!includeTuple) {\n                // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n                types.push('(' + result.join(',') + ')' + suffix);\n            }\n            else {\n                // console.log(\"its a single type within a tuple: \" + result.types)\n                types.push('(' + result + ')');\n            }\n        }\n        else {\n            // console.log(\"its a type and not directly in a tuple: \" + param.type)\n            types.push(param.type);\n        }\n    });\n    return types;\n};\n/**\n * Returns a random hex string by the given bytes size\n *\n * @param {Number} size\n * @returns {string}\n */\nvar randomHex = function (size) {\n    return '0x' + randombytes(size).toString('hex');\n};\n/**\n * Should be called to get ascii from it's hex representation\n *\n * @method hexToAscii\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */\nvar hexToAscii = function (hex) {\n    if (!utils.isHexStrict(hex))\n        throw new Error('The parameter must be a valid HEX string.');\n    var str = \"\";\n    var i = 0, l = hex.length;\n    if (hex.substring(0, 2) === '0x') {\n        i = 2;\n    }\n    for (; i < l; i += 2) {\n        var code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @method asciiToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */\nvar asciiToHex = function (str) {\n    if (!str)\n        return \"0x00\";\n    var hex = \"\";\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        var n = code.toString(16);\n        hex += n.length < 2 ? '0' + n : n;\n    }\n    return \"0x\" + hex;\n};\n/**\n * Returns value of unit in Wei\n *\n * @method getUnitValue\n * @param {String} unit the unit to convert to, default ether\n * @returns {BN} value of the unit (in Wei)\n * @throws error if the unit is not correct:w\n */\nvar getUnitValue = function (unit) {\n    unit = unit ? unit.toLowerCase() : 'ether';\n    if (!ethjsUnit.unitMap[unit]) {\n        throw new Error('This unit \"' + unit + '\" doesn\\'t exist, please use the one of the following units' + JSON.stringify(ethjsUnit.unitMap, null, 2));\n    }\n    return unit;\n};\n/**\n * Takes a number of wei and converts it to any other ether unit.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method fromWei\n * @param {Number|String} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert to, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */\nvar fromWei = function (number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === 'string')) {\n        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n    return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);\n};\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method toWei\n * @param {Number|String|BN} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert from, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */\nvar toWei = function (number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === 'string')) {\n        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n    return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);\n};\n/**\n * Converts to a checksum address\n *\n * @method toChecksumAddress\n * @param {String} address the given HEX address\n * @return {String}\n */\nvar toChecksumAddress = function (address) {\n    if (typeof address === 'undefined')\n        return '';\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address))\n        throw new Error('Given address \"' + address + '\" is not a valid Ethereum address.');\n    address = address.toLowerCase().replace(/^0x/i, '');\n    var addressHash = utils.sha3(address).replace(/^0x/i, '');\n    var checksumAddress = '0x';\n    for (var i = 0; i < address.length; i++) {\n        // If ith character is 8 to f then make it uppercase\n        if (parseInt(addressHash[i], 16) > 7) {\n            checksumAddress += address[i].toUpperCase();\n        }\n        else {\n            checksumAddress += address[i];\n        }\n    }\n    return checksumAddress;\n};\n/**\n * Returns -1 if a<b, 1 if a>b; 0 if a == b.\n * For more details on this type of function, see\n * developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n *\n * @method compareBlockNumbers\n *\n * @param {String|Number|BN} a\n *\n * @param {String|Number|BN} b\n *\n * @returns {Number} -1, 0, or 1\n */\nvar compareBlockNumbers = function (a, b) {\n    if (a == b) {\n        return 0;\n    }\n    else if ((\"genesis\" == a || \"earliest\" == a || 0 == a) && (\"genesis\" == b || \"earliest\" == b || 0 == b)) {\n        return 0;\n    }\n    else if (\"genesis\" == a || \"earliest\" == a) {\n        // b !== a, thus a < b\n        return -1;\n    }\n    else if (\"genesis\" == b || \"earliest\" == b) {\n        // b !== a, thus a > b\n        return 1;\n    }\n    else if (a == \"latest\") {\n        if (b == \"pending\") {\n            return -1;\n        }\n        else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return 1;\n        }\n    }\n    else if (b === \"latest\") {\n        if (a == \"pending\") {\n            return 1;\n        }\n        else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return -1;\n        }\n    }\n    else if (a == \"pending\") {\n        // b (== OR <) \"latest\", thus a > b\n        return 1;\n    }\n    else if (b == \"pending\") {\n        return -1;\n    }\n    else {\n        let bnA = new BN(a);\n        let bnB = new BN(b);\n        if (bnA.lt(bnB)) {\n            return -1;\n        }\n        else if (bnA.eq(bnB)) {\n            return 0;\n        }\n        else {\n            return 1;\n        }\n    }\n};\nmodule.exports = {\n    _fireError: _fireError,\n    _jsonInterfaceMethodToString: _jsonInterfaceMethodToString,\n    _flattenTypes: _flattenTypes,\n    // extractDisplayName: extractDisplayName,\n    // extractTypeName: extractTypeName,\n    randomHex: randomHex,\n    BN: utils.BN,\n    isBN: utils.isBN,\n    isBigNumber: utils.isBigNumber,\n    isHex: utils.isHex,\n    isHexStrict: utils.isHexStrict,\n    sha3: utils.sha3,\n    sha3Raw: utils.sha3Raw,\n    keccak256: utils.sha3,\n    soliditySha3: soliditySha3.soliditySha3,\n    soliditySha3Raw: soliditySha3.soliditySha3Raw,\n    encodePacked: soliditySha3.encodePacked,\n    isAddress: utils.isAddress,\n    checkAddressChecksum: utils.checkAddressChecksum,\n    toChecksumAddress: toChecksumAddress,\n    toHex: utils.toHex,\n    toBN: utils.toBN,\n    bytesToHex: utils.bytesToHex,\n    hexToBytes: utils.hexToBytes,\n    hexToNumberString: utils.hexToNumberString,\n    hexToNumber: utils.hexToNumber,\n    toDecimal: utils.hexToNumber,\n    numberToHex: utils.numberToHex,\n    fromDecimal: utils.numberToHex,\n    hexToUtf8: utils.hexToUtf8,\n    hexToString: utils.hexToUtf8,\n    toUtf8: utils.hexToUtf8,\n    stripHexPrefix: utils.stripHexPrefix,\n    utf8ToHex: utils.utf8ToHex,\n    stringToHex: utils.utf8ToHex,\n    fromUtf8: utils.utf8ToHex,\n    hexToAscii: hexToAscii,\n    toAscii: hexToAscii,\n    asciiToHex: asciiToHex,\n    fromAscii: asciiToHex,\n    unitMap: ethjsUnit.unitMap,\n    toWei: toWei,\n    fromWei: fromWei,\n    padLeft: utils.leftPad,\n    leftPad: utils.leftPad,\n    padRight: utils.rightPad,\n    rightPad: utils.rightPad,\n    toTwosComplement: utils.toTwosComplement,\n    isBloom: utils.isBloom,\n    isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,\n    isContractAddressInBloom: utils.isContractAddressInBloom,\n    isTopic: utils.isTopic,\n    isTopicInBloom: utils.isTopicInBloom,\n    isInBloom: utils.isInBloom,\n    compareBlockNumbers: compareBlockNumbers,\n    toNumber: utils.toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQyw4RkFBWTtBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyw0R0FBbUI7QUFDOUMsa0JBQWtCLG1CQUFPLENBQUMsOERBQWE7QUFDdkMsU0FBUyxtQkFBTyxDQUFDLGlEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDRDQUE0QztBQUMvRCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEtBQUs7QUFDaEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AYWxjaC9hbGNoZW15LXdlYjMvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2luZGV4LmpzP2I3YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIHV0aWxzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BwYXJpdHkuaW8+XG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cbnZhciBldGhqc1VuaXQgPSByZXF1aXJlKCdldGhqcy11bml0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgc29saWRpdHlTaGEzID0gcmVxdWlyZSgnLi9zb2xpZGl0eVNoYTMuanMnKTtcbnZhciByYW5kb21ieXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xuLyoqXG4gKiBGaXJlcyBhbiBlcnJvciBpbiBhbiBldmVudCBlbWl0dGVyIGFuZCBjYWxsYmFjayBhbmQgcmV0dXJucyB0aGUgZXZlbnRlbWl0dGVyXG4gKlxuICogQG1ldGhvZCBfZmlyZUVycm9yXG4gKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgYSBzdHJpbmcsIGEgZXJyb3IsIG9yIGFuIG9iamVjdCB3aXRoIHttZXNzYWdlLCBkYXRhfVxuICogQHBhcmFtIHtPYmplY3R9IGVtaXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25hbERhdGFcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGVtaXR0ZXJcbiAqL1xudmFyIF9maXJlRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGVtaXR0ZXIsIHJlamVjdCwgY2FsbGJhY2ssIG9wdGlvbmFsRGF0YSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gICAgLy8gYWRkIGRhdGEgaWYgZ2l2ZW5cbiAgICBpZiAoISFlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICBpZiAoISFlcnJvci5kYXRhICYmIHR5cGVvZiBlcnJvci5kYXRhID09PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGVycm9yLmRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvci5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZXJyb3IuZGF0YSwgbnVsbCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgPSBlcnJvci5tZXNzYWdlICsgXCJcXG5cIiArIGVycm9yLmRhdGE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgb3B0aW9uYWxEYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gc3VwcHJlc3MgdW5jYXRjaGVkIGVycm9yIGlmIGFuIGVycm9yIGxpc3RlbmVyIGlzIHByZXNlbnRcbiAgICAgICAgLy8gT1Igc3VwcHJlc3MgdW5jYXRjaGVkIGVycm9yIGlmIGFuIGNhbGxiYWNrIGxpc3RlbmVyIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKGVtaXR0ZXIgJiZcbiAgICAgICAgICAgICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZW1pdHRlci5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlamVjdCBsYXRlciwgdG8gYmUgYWJsZSB0byByZXR1cm4gZW1pdHRlclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0sIDEpO1xuICAgIH1cbiAgICBpZiAoZW1pdHRlciAmJiB0eXBlb2YgZW1pdHRlci5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVtaXQgbGF0ZXIsIHRvIGJlIGFibGUgdG8gcmV0dXJuIGVtaXR0ZXJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyb3IsIG9wdGlvbmFsRGF0YSk7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGVtaXR0ZXI7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgZnVsbCBmdW5jdGlvbi9ldmVudCBuYW1lIGZyb20ganNvbiBhYmlcbiAqXG4gKiBAbWV0aG9kIF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZVxuICovXG52YXIgX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgaWYgKCEhanNvbiAmJiB0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYganNvbi5uYW1lICYmIGpzb24ubmFtZS5pbmRleE9mKCcoJykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBqc29uLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBqc29uLm5hbWUgKyAnKCcgKyBfZmxhdHRlblR5cGVzKGZhbHNlLCBqc29uLmlucHV0cykuam9pbignLCcpICsgJyknO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZmxhdHRlbiBqc29uIGFiaSBpbnB1dHMvb3V0cHV0cyBpbnRvIGFuIGFycmF5IG9mIHR5cGUtcmVwcmVzZW50aW5nLXN0cmluZ3NcbiAqXG4gKiBAbWV0aG9kIF9mbGF0dGVuVHlwZXNcbiAqIEBwYXJhbSB7Ym9vbH0gaW5jbHVkZVR1cGxlXG4gKiBAcGFyYW0ge09iamVjdH0gcHV0c1xuICogQHJldHVybiB7QXJyYXl9IHBhcmFtZXRlcnMgYXMgc3RyaW5nc1xuICovXG52YXIgX2ZsYXR0ZW5UeXBlcyA9IGZ1bmN0aW9uIChpbmNsdWRlVHVwbGUsIHB1dHMpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcImVudGVyZWQgX2ZsYXR0ZW5UeXBlcy4gaW5wdXRzL291dHB1dHM6IFwiICsgcHV0cylcbiAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICBwdXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW0uY29tcG9uZW50cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlLnN1YnN0cmluZygwLCA1KSAhPT0gJ3R1cGxlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcG9uZW50cyBmb3VuZCBidXQgdHlwZSBpcyBub3QgdHVwbGU7IHJlcG9ydCBvbiBHaXRIdWInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWZmaXggPSAnJztcbiAgICAgICAgICAgIHZhciBhcnJheUJyYWNrZXQgPSBwYXJhbS50eXBlLmluZGV4T2YoJ1snKTtcbiAgICAgICAgICAgIGlmIChhcnJheUJyYWNrZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHBhcmFtLnR5cGUuc3Vic3RyaW5nKGFycmF5QnJhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2ZsYXR0ZW5UeXBlcyhpbmNsdWRlVHVwbGUsIHBhcmFtLmNvbXBvbmVudHMpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJyZXN1bHQgc2hvdWxkIGhhdmUgdGhpbmdzOiBcIiArIHJlc3VsdClcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgaW5jbHVkZVR1cGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpbmNsdWRlIHR1cGxlIHdvcmQsIGFuZCBpdHMgYW4gYXJyYXkuIGpvaW5pbmcuLi46IFwiICsgcmVzdWx0LnR5cGVzKVxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goJ3R1cGxlKCcgKyByZXN1bHQuam9pbignLCcpICsgJyknICsgc3VmZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlVHVwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvbid0IGluY2x1ZGUgdHVwbGUsIGJ1dCBpdHMgYW4gYXJyYXkuIGpvaW5pbmcuLi46IFwiICsgcmVzdWx0KVxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goJygnICsgcmVzdWx0LmpvaW4oJywnKSArICcpJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIml0cyBhIHNpbmdsZSB0eXBlIHdpdGhpbiBhIHR1cGxlOiBcIiArIHJlc3VsdC50eXBlcylcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKCcoJyArIHJlc3VsdCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIml0cyBhIHR5cGUgYW5kIG5vdCBkaXJlY3RseSBpbiBhIHR1cGxlOiBcIiArIHBhcmFtLnR5cGUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKHBhcmFtLnR5cGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVzO1xufTtcbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBoZXggc3RyaW5nIGJ5IHRoZSBnaXZlbiBieXRlcyBzaXplXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciByYW5kb21IZXggPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiAnMHgnICsgcmFuZG9tYnl0ZXMoc2l6ZSkudG9TdHJpbmcoJ2hleCcpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgaGV4VG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgaGV4VG9Bc2NpaSA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBpZiAoIXV0aWxzLmlzSGV4U3RyaWN0KGhleCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhcmFtZXRlciBtdXN0IGJlIGEgdmFsaWQgSEVYIHN0cmluZy4nKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDAsIGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgIGkgPSAyO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGFzY2lpVG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xudmFyIGFzY2lpVG9IZXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIpXG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHZhbHVlIG9mIHVuaXQgaW4gV2VpXG4gKlxuICogQG1ldGhvZCBnZXRVbml0VmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm5zIHtCTn0gdmFsdWUgb2YgdGhlIHVuaXQgKGluIFdlaSlcbiAqIEB0aHJvd3MgZXJyb3IgaWYgdGhlIHVuaXQgaXMgbm90IGNvcnJlY3Q6d1xuICovXG52YXIgZ2V0VW5pdFZhbHVlID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB1bml0ID0gdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6ICdldGhlcic7XG4gICAgaWYgKCFldGhqc1VuaXQudW5pdE1hcFt1bml0XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBcIicgKyB1bml0ICsgJ1wiIGRvZXNuXFwndCBleGlzdCwgcGxlYXNlIHVzZSB0aGUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdW5pdHMnICsgSlNPTi5zdHJpbmdpZnkoZXRoanNVbml0LnVuaXRNYXAsIG51bGwsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXQ7XG59O1xuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBvZiB3ZWkgYW5kIGNvbnZlcnRzIGl0IHRvIGFueSBvdGhlciBldGhlciB1bml0LlxuICpcbiAqIFBvc3NpYmxlIHVuaXRzIGFyZTpcbiAqICAgU0kgU2hvcnQgICBTSSBGdWxsICAgICAgICBFZmZpZ3kgICAgICAgT3RoZXJcbiAqIC0ga3dlaSAgICAgICBmZW10b2V0aGVyICAgICBiYWJiYWdlXG4gKiAtIG13ZWkgICAgICAgcGljb2V0aGVyICAgICAgbG92ZWxhY2VcbiAqIC0gZ3dlaSAgICAgICBuYW5vZXRoZXIgICAgICBzaGFubm9uICAgICAgbmFub1xuICogLSAtLSAgICAgICAgIG1pY3JvZXRoZXIgICAgIHN6YWJvICAgICAgICBtaWNyb1xuICogLSAtLSAgICAgICAgIG1pbGxpZXRoZXIgICAgIGZpbm5leSAgICAgICBtaWxsaVxuICogLSBldGhlciAgICAgIC0tICAgICAgICAgICAgIC0tXG4gKiAtIGtldGhlciAgICAgICAgICAgICAgICAgICAgLS0gICAgICAgICAgIGdyYW5kXG4gKiAtIG1ldGhlclxuICogLSBnZXRoZXJcbiAqIC0gdGV0aGVyXG4gKlxuICogQG1ldGhvZCBmcm9tV2VpXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG51bWJlciBjYW4gYmUgYSBudW1iZXIsIG51bWJlciBzdHJpbmcgb3IgYSBIRVggb2YgYSBkZWNpbWFsXG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pdCB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSBXaGVuIGdpdmVuIGEgQk4gb2JqZWN0IGl0IHJldHVybnMgb25lIGFzIHdlbGwsIG90aGVyd2lzZSBhIG51bWJlclxuICovXG52YXIgZnJvbVdlaSA9IGZ1bmN0aW9uIChudW1iZXIsIHVuaXQpIHtcbiAgICB1bml0ID0gZ2V0VW5pdFZhbHVlKHVuaXQpO1xuICAgIGlmICghdXRpbHMuaXNCTihudW1iZXIpICYmICEodHlwZW9mIG51bWJlciA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgbnVtYmVycyBhcyBzdHJpbmdzIG9yIEJOIG9iamVjdHMgdG8gYXZvaWQgcHJlY2lzaW9uIGVycm9ycy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmlzQk4obnVtYmVyKSA/IGV0aGpzVW5pdC5mcm9tV2VpKG51bWJlciwgdW5pdCkgOiBldGhqc1VuaXQuZnJvbVdlaShudW1iZXIsIHVuaXQpLnRvU3RyaW5nKDEwKTtcbn07XG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIGEgdW5pdCBhbmQgY29udmVydHMgaXQgdG8gd2VpLlxuICpcbiAqIFBvc3NpYmxlIHVuaXRzIGFyZTpcbiAqICAgU0kgU2hvcnQgICBTSSBGdWxsICAgICAgICBFZmZpZ3kgICAgICAgT3RoZXJcbiAqIC0ga3dlaSAgICAgICBmZW10b2V0aGVyICAgICBiYWJiYWdlXG4gKiAtIG13ZWkgICAgICAgcGljb2V0aGVyICAgICAgbG92ZWxhY2VcbiAqIC0gZ3dlaSAgICAgICBuYW5vZXRoZXIgICAgICBzaGFubm9uICAgICAgbmFub1xuICogLSAtLSAgICAgICAgIG1pY3JvZXRoZXIgICAgIHN6YWJvICAgICAgICBtaWNyb1xuICogLSAtLSAgICAgICAgIG1pY3JvZXRoZXIgICAgIHN6YWJvICAgICAgICBtaWNyb1xuICogLSAtLSAgICAgICAgIG1pbGxpZXRoZXIgICAgIGZpbm5leSAgICAgICBtaWxsaVxuICogLSBldGhlciAgICAgIC0tICAgICAgICAgICAgIC0tXG4gKiAtIGtldGhlciAgICAgICAgICAgICAgICAgICAgLS0gICAgICAgICAgIGdyYW5kXG4gKiAtIG1ldGhlclxuICogLSBnZXRoZXJcbiAqIC0gdGV0aGVyXG4gKlxuICogQG1ldGhvZCB0b1dlaVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJOfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCBmcm9tLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSBXaGVuIGdpdmVuIGEgQk4gb2JqZWN0IGl0IHJldHVybnMgb25lIGFzIHdlbGwsIG90aGVyd2lzZSBhIG51bWJlclxuICovXG52YXIgdG9XZWkgPSBmdW5jdGlvbiAobnVtYmVyLCB1bml0KSB7XG4gICAgdW5pdCA9IGdldFVuaXRWYWx1ZSh1bml0KTtcbiAgICBpZiAoIXV0aWxzLmlzQk4obnVtYmVyKSAmJiAhKHR5cGVvZiBudW1iZXIgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIG51bWJlcnMgYXMgc3RyaW5ncyBvciBCTiBvYmplY3RzIHRvIGF2b2lkIHByZWNpc2lvbiBlcnJvcnMuJyk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5pc0JOKG51bWJlcikgPyBldGhqc1VuaXQudG9XZWkobnVtYmVyLCB1bml0KSA6IGV0aGpzVW5pdC50b1dlaShudW1iZXIsIHVuaXQpLnRvU3RyaW5nKDEwKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHRvIGEgY2hlY2tzdW0gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgdG9DaGVja3N1bUFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgdG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs0MH0kL2kudGVzdChhZGRyZXNzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiBhZGRyZXNzIFwiJyArIGFkZHJlc3MgKyAnXCIgaXMgbm90IGEgdmFsaWQgRXRoZXJldW0gYWRkcmVzcy4nKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gdXRpbHMuc2hhMyhhZGRyZXNzKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBjaGVja3N1bUFkZHJlc3MgPSAnMHgnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBJZiBpdGggY2hhcmFjdGVyIGlzIDggdG8gZiB0aGVuIG1ha2UgaXQgdXBwZXJjYXNlXG4gICAgICAgIGlmIChwYXJzZUludChhZGRyZXNzSGFzaFtpXSwgMTYpID4gNykge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3M7XG59O1xuLyoqXG4gKiBSZXR1cm5zIC0xIGlmIGE8YiwgMSBpZiBhPmI7IDAgaWYgYSA9PSBiLlxuICogRm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIHR5cGUgb2YgZnVuY3Rpb24sIHNlZVxuICogZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnRcbiAqXG4gKiBAbWV0aG9kIGNvbXBhcmVCbG9ja051bWJlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGJcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtMSwgMCwgb3IgMVxuICovXG52YXIgY29tcGFyZUJsb2NrTnVtYmVycyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEgPT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKFwiZ2VuZXNpc1wiID09IGEgfHwgXCJlYXJsaWVzdFwiID09IGEgfHwgMCA9PSBhKSAmJiAoXCJnZW5lc2lzXCIgPT0gYiB8fCBcImVhcmxpZXN0XCIgPT0gYiB8fCAwID09IGIpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImdlbmVzaXNcIiA9PSBhIHx8IFwiZWFybGllc3RcIiA9PSBhKSB7XG4gICAgICAgIC8vIGIgIT09IGEsIHRodXMgYSA8IGJcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImdlbmVzaXNcIiA9PSBiIHx8IFwiZWFybGllc3RcIiA9PSBiKSB7XG4gICAgICAgIC8vIGIgIT09IGEsIHRodXMgYSA+IGJcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT0gXCJsYXRlc3RcIikge1xuICAgICAgICBpZiAoYiA9PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYiAhPT0gKFwicGVuZGluZ1wiIE9SIFwibGF0ZXN0XCIpLCB0aHVzIGEgPiBiXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiID09PSBcImxhdGVzdFwiKSB7XG4gICAgICAgIGlmIChhID09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGIgIT09IChcInBlbmRpbmdcIiBPUiBcImxhdGVzdFwiKSwgdGh1cyBhID4gYlxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgLy8gYiAoPT0gT1IgPCkgXCJsYXRlc3RcIiwgdGh1cyBhID4gYlxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYiA9PSBcInBlbmRpbmdcIikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgYm5BID0gbmV3IEJOKGEpO1xuICAgICAgICBsZXQgYm5CID0gbmV3IEJOKGIpO1xuICAgICAgICBpZiAoYm5BLmx0KGJuQikpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibkEuZXEoYm5CKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBfZmlyZUVycm9yOiBfZmlyZUVycm9yLFxuICAgIF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmc6IF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmcsXG4gICAgX2ZsYXR0ZW5UeXBlczogX2ZsYXR0ZW5UeXBlcyxcbiAgICAvLyBleHRyYWN0RGlzcGxheU5hbWU6IGV4dHJhY3REaXNwbGF5TmFtZSxcbiAgICAvLyBleHRyYWN0VHlwZU5hbWU6IGV4dHJhY3RUeXBlTmFtZSxcbiAgICByYW5kb21IZXg6IHJhbmRvbUhleCxcbiAgICBCTjogdXRpbHMuQk4sXG4gICAgaXNCTjogdXRpbHMuaXNCTixcbiAgICBpc0JpZ051bWJlcjogdXRpbHMuaXNCaWdOdW1iZXIsXG4gICAgaXNIZXg6IHV0aWxzLmlzSGV4LFxuICAgIGlzSGV4U3RyaWN0OiB1dGlscy5pc0hleFN0cmljdCxcbiAgICBzaGEzOiB1dGlscy5zaGEzLFxuICAgIHNoYTNSYXc6IHV0aWxzLnNoYTNSYXcsXG4gICAga2VjY2FrMjU2OiB1dGlscy5zaGEzLFxuICAgIHNvbGlkaXR5U2hhMzogc29saWRpdHlTaGEzLnNvbGlkaXR5U2hhMyxcbiAgICBzb2xpZGl0eVNoYTNSYXc6IHNvbGlkaXR5U2hhMy5zb2xpZGl0eVNoYTNSYXcsXG4gICAgZW5jb2RlUGFja2VkOiBzb2xpZGl0eVNoYTMuZW5jb2RlUGFja2VkLFxuICAgIGlzQWRkcmVzczogdXRpbHMuaXNBZGRyZXNzLFxuICAgIGNoZWNrQWRkcmVzc0NoZWNrc3VtOiB1dGlscy5jaGVja0FkZHJlc3NDaGVja3N1bSxcbiAgICB0b0NoZWNrc3VtQWRkcmVzczogdG9DaGVja3N1bUFkZHJlc3MsXG4gICAgdG9IZXg6IHV0aWxzLnRvSGV4LFxuICAgIHRvQk46IHV0aWxzLnRvQk4sXG4gICAgYnl0ZXNUb0hleDogdXRpbHMuYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzOiB1dGlscy5oZXhUb0J5dGVzLFxuICAgIGhleFRvTnVtYmVyU3RyaW5nOiB1dGlscy5oZXhUb051bWJlclN0cmluZyxcbiAgICBoZXhUb051bWJlcjogdXRpbHMuaGV4VG9OdW1iZXIsXG4gICAgdG9EZWNpbWFsOiB1dGlscy5oZXhUb051bWJlcixcbiAgICBudW1iZXJUb0hleDogdXRpbHMubnVtYmVyVG9IZXgsXG4gICAgZnJvbURlY2ltYWw6IHV0aWxzLm51bWJlclRvSGV4LFxuICAgIGhleFRvVXRmODogdXRpbHMuaGV4VG9VdGY4LFxuICAgIGhleFRvU3RyaW5nOiB1dGlscy5oZXhUb1V0ZjgsXG4gICAgdG9VdGY4OiB1dGlscy5oZXhUb1V0ZjgsXG4gICAgc3RyaXBIZXhQcmVmaXg6IHV0aWxzLnN0cmlwSGV4UHJlZml4LFxuICAgIHV0ZjhUb0hleDogdXRpbHMudXRmOFRvSGV4LFxuICAgIHN0cmluZ1RvSGV4OiB1dGlscy51dGY4VG9IZXgsXG4gICAgZnJvbVV0Zjg6IHV0aWxzLnV0ZjhUb0hleCxcbiAgICBoZXhUb0FzY2lpOiBoZXhUb0FzY2lpLFxuICAgIHRvQXNjaWk6IGhleFRvQXNjaWksXG4gICAgYXNjaWlUb0hleDogYXNjaWlUb0hleCxcbiAgICBmcm9tQXNjaWk6IGFzY2lpVG9IZXgsXG4gICAgdW5pdE1hcDogZXRoanNVbml0LnVuaXRNYXAsXG4gICAgdG9XZWk6IHRvV2VpLFxuICAgIGZyb21XZWk6IGZyb21XZWksXG4gICAgcGFkTGVmdDogdXRpbHMubGVmdFBhZCxcbiAgICBsZWZ0UGFkOiB1dGlscy5sZWZ0UGFkLFxuICAgIHBhZFJpZ2h0OiB1dGlscy5yaWdodFBhZCxcbiAgICByaWdodFBhZDogdXRpbHMucmlnaHRQYWQsXG4gICAgdG9Ud29zQ29tcGxlbWVudDogdXRpbHMudG9Ud29zQ29tcGxlbWVudCxcbiAgICBpc0Jsb29tOiB1dGlscy5pc0Jsb29tLFxuICAgIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb206IHV0aWxzLmlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20sXG4gICAgaXNDb250cmFjdEFkZHJlc3NJbkJsb29tOiB1dGlscy5pc0NvbnRyYWN0QWRkcmVzc0luQmxvb20sXG4gICAgaXNUb3BpYzogdXRpbHMuaXNUb3BpYyxcbiAgICBpc1RvcGljSW5CbG9vbTogdXRpbHMuaXNUb3BpY0luQmxvb20sXG4gICAgaXNJbkJsb29tOiB1dGlscy5pc0luQmxvb20sXG4gICAgY29tcGFyZUJsb2NrTnVtYmVyczogY29tcGFyZUJsb2NrTnVtYmVycyxcbiAgICB0b051bWJlcjogdXRpbHMudG9OdW1iZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/soliditySha3.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/soliditySha3.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file soliditySha3.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar BN = __webpack_require__(/*! bn.js */ \"../../node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/utils.js\");\nvar _elementaryName = function (name) {\n    /*jshint maxcomplexity:false */\n    if (name.startsWith('int[')) {\n        return 'int256' + name.slice(3);\n    }\n    else if (name === 'int') {\n        return 'int256';\n    }\n    else if (name.startsWith('uint[')) {\n        return 'uint256' + name.slice(4);\n    }\n    else if (name === 'uint') {\n        return 'uint256';\n    }\n    else if (name.startsWith('fixed[')) {\n        return 'fixed128x128' + name.slice(5);\n    }\n    else if (name === 'fixed') {\n        return 'fixed128x128';\n    }\n    else if (name.startsWith('ufixed[')) {\n        return 'ufixed128x128' + name.slice(6);\n    }\n    else if (name === 'ufixed') {\n        return 'ufixed128x128';\n    }\n    return name;\n};\n// Parse N from type<N>\nvar _parseTypeN = function (type) {\n    var typesize = /^\\D+(\\d+).*$/.exec(type);\n    return typesize ? parseInt(typesize[1], 10) : null;\n};\n// Parse N from type[<N>]\nvar _parseTypeNArray = function (type) {\n    var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n    return arraySize ? parseInt(arraySize[1], 10) : null;\n};\nvar _parseNumber = function (arg) {\n    var type = typeof arg;\n    if (type === 'string') {\n        if (utils.isHexStrict(arg)) {\n            return new BN(arg.replace(/0x/i, ''), 16);\n        }\n        else {\n            return new BN(arg, 10);\n        }\n    }\n    else if (type === 'number') {\n        return new BN(arg);\n    }\n    else if (utils.isBigNumber(arg)) {\n        return new BN(arg.toString(10));\n    }\n    else if (utils.isBN(arg)) {\n        return arg;\n    }\n    else {\n        throw new Error(arg + ' is not a number');\n    }\n};\nvar _solidityPack = function (type, value, arraySize) {\n    /*jshint maxcomplexity:false */\n    var size, num;\n    type = _elementaryName(type);\n    if (type === 'bytes') {\n        if (value.replace(/^0x/i, '').length % 2 !== 0) {\n            throw new Error('Invalid bytes characters ' + value.length);\n        }\n        return value;\n    }\n    else if (type === 'string') {\n        return utils.utf8ToHex(value);\n    }\n    else if (type === 'bool') {\n        return value ? '01' : '00';\n    }\n    else if (type.startsWith('address')) {\n        if (arraySize) {\n            size = 64;\n        }\n        else {\n            size = 40;\n        }\n        if (!utils.isAddress(value)) {\n            throw new Error(value + ' is not a valid address, or the checksum is invalid.');\n        }\n        return utils.leftPad(value.toLowerCase(), size);\n    }\n    size = _parseTypeN(type);\n    if (type.startsWith('bytes')) {\n        if (!size) {\n            throw new Error('bytes[] not yet supported in solidity');\n        }\n        // must be 32 byte slices when in an array\n        if (arraySize) {\n            size = 32;\n        }\n        if (size < 1 || size > 32 || size < value.replace(/^0x/i, '').length / 2) {\n            throw new Error('Invalid bytes' + size + ' for ' + value);\n        }\n        return utils.rightPad(value, size * 2);\n    }\n    else if (type.startsWith('uint')) {\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid uint' + size + ' size');\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            throw new Error('Supplied uint ' + num.toString() + ' is negative');\n        }\n        return size ? utils.leftPad(num.toString('hex'), size / 8 * 2) : num;\n    }\n    else if (type.startsWith('int')) {\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid int' + size + ' size');\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            return num.toTwos(size).toString('hex');\n        }\n        else {\n            return size ? utils.leftPad(num.toString('hex'), size / 8 * 2) : num;\n        }\n    }\n    else {\n        // FIXME: support all other types\n        throw new Error('Unsupported or invalid type: ' + type);\n    }\n};\nvar _processSolidityEncodePackedArgs = function (arg) {\n    /*jshint maxcomplexity:false */\n    if (Array.isArray(arg)) {\n        throw new Error('Autodetection of array types is not supported.');\n    }\n    var type, value = '';\n    var hexArg, arraySize;\n    // if type is given\n    if (!!arg && typeof arg === 'object' && (arg.hasOwnProperty('v') || arg.hasOwnProperty('t') || arg.hasOwnProperty('value') || arg.hasOwnProperty('type'))) {\n        type = arg.hasOwnProperty('t') ? arg.t : arg.type;\n        value = arg.hasOwnProperty('v') ? arg.v : arg.value;\n        // otherwise try to guess the type\n    }\n    else {\n        type = utils.toHex(arg, true);\n        value = utils.toHex(arg);\n        if (!type.startsWith('int') && !type.startsWith('uint')) {\n            type = 'bytes';\n        }\n    }\n    if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {\n        value = new BN(value);\n    }\n    // get the array size\n    if (Array.isArray(value)) {\n        arraySize = _parseTypeNArray(type);\n        if (arraySize && value.length !== arraySize) {\n            throw new Error(type + ' is not matching the given array ' + JSON.stringify(value));\n        }\n        else {\n            arraySize = value.length;\n        }\n    }\n    if (Array.isArray(value)) {\n        hexArg = value.map(function (val) {\n            return _solidityPack(type, val, arraySize).toString('hex').replace('0x', '');\n        });\n        return hexArg.join('');\n    }\n    else {\n        hexArg = _solidityPack(type, value, arraySize);\n        return hexArg.toString('hex').replace('0x', '');\n    }\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256\n *\n * @method soliditySha3\n * @return {Object} the sha3\n */\nvar soliditySha3 = function () {\n    /*jshint maxcomplexity:false */\n    var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    // console.log(args, hexArgs);\n    // console.log('0x'+ hexArgs.join(''));\n    return utils.sha3('0x' + hexArgs.join(''));\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256 but does return the hash of value `null` instead of `null`\n *\n * @method soliditySha3Raw\n * @return {Object} the sha3\n */\nvar soliditySha3Raw = function () {\n    return utils.sha3Raw('0x' + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(''));\n};\n/**\n * Encode packed args to hex\n *\n * @method encodePacked\n * @return {String} the hex encoded arguments\n */\nvar encodePacked = function () {\n    /*jshint maxcomplexity:false */\n    var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    return '0x' + hexArgs.join('').toLowerCase();\n};\nmodule.exports = {\n    soliditySha3: soliditySha3,\n    soliditySha3Raw: soliditySha3Raw,\n    encodePacked: encodePacked\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvc29saWRpdHlTaGEzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLGlEQUFPO0FBQ3hCLFlBQVksbUJBQU8sQ0FBQyw4RkFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9zb2xpZGl0eVNoYTMuanM/ZTc2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbi8qKlxuICogQGZpbGUgc29saWRpdHlTaGEzLmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgX2VsZW1lbnRhcnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaW50WycpKSB7XG4gICAgICAgIHJldHVybiAnaW50MjU2JyArIG5hbWUuc2xpY2UoMyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpbnQnKSB7XG4gICAgICAgIHJldHVybiAnaW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1aW50WycpKSB7XG4gICAgICAgIHJldHVybiAndWludDI1NicgKyBuYW1lLnNsaWNlKDQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAndWludCcpIHtcbiAgICAgICAgcmV0dXJuICd1aW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaXhlZFsnKSkge1xuICAgICAgICByZXR1cm4gJ2ZpeGVkMTI4eDEyOCcgKyBuYW1lLnNsaWNlKDUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnZml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1Zml4ZWRbJykpIHtcbiAgICAgICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd1Zml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAndWZpeGVkMTI4eDEyOCc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcbi8vIFBhcnNlIE4gZnJvbSB0eXBlPE4+XG52YXIgX3BhcnNlVHlwZU4gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB0eXBlc2l6ZSA9IC9eXFxEKyhcXGQrKS4qJC8uZXhlYyh0eXBlKTtcbiAgICByZXR1cm4gdHlwZXNpemUgPyBwYXJzZUludCh0eXBlc2l6ZVsxXSwgMTApIDogbnVsbDtcbn07XG4vLyBQYXJzZSBOIGZyb20gdHlwZVs8Tj5dXG52YXIgX3BhcnNlVHlwZU5BcnJheSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGFycmF5U2l6ZSA9IC9eXFxEK1xcZCpcXFsoXFxkKylcXF0kLy5leGVjKHR5cGUpO1xuICAgIHJldHVybiBhcnJheVNpemUgPyBwYXJzZUludChhcnJheVNpemVbMV0sIDEwKSA6IG51bGw7XG59O1xudmFyIF9wYXJzZU51bWJlciA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh1dGlscy5pc0hleFN0cmljdChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJOKGFyZy5yZXBsYWNlKC8weC9pLCAnJyksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQk4oYXJnLCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCTihhcmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlscy5pc0JpZ051bWJlcihhcmcpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQk4oYXJnLnRvU3RyaW5nKDEwKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzLmlzQk4oYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZyArICcgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgfVxufTtcbnZhciBfc29saWRpdHlQYWNrID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBhcnJheVNpemUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgdmFyIHNpemUsIG51bTtcbiAgICB0eXBlID0gX2VsZW1lbnRhcnlOYW1lKHR5cGUpO1xuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5yZXBsYWNlKC9eMHgvaSwgJycpLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlcyBjaGFyYWN0ZXJzICcgKyB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnV0ZjhUb0hleCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyAnMDEnIDogJzAwJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdhZGRyZXNzJykpIHtcbiAgICAgICAgaWYgKGFycmF5U2l6ZSkge1xuICAgICAgICAgICAgc2l6ZSA9IDY0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IDQwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbHMuaXNBZGRyZXNzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlICsgJyBpcyBub3QgYSB2YWxpZCBhZGRyZXNzLCBvciB0aGUgY2hlY2tzdW0gaXMgaW52YWxpZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMubGVmdFBhZCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCBzaXplKTtcbiAgICB9XG4gICAgc2l6ZSA9IF9wYXJzZVR5cGVOKHR5cGUpO1xuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J5dGVzW10gbm90IHlldCBzdXBwb3J0ZWQgaW4gc29saWRpdHknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtdXN0IGJlIDMyIGJ5dGUgc2xpY2VzIHdoZW4gaW4gYW4gYXJyYXlcbiAgICAgICAgaWYgKGFycmF5U2l6ZSkge1xuICAgICAgICAgICAgc2l6ZSA9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIgfHwgc2l6ZSA8IHZhbHVlLnJlcGxhY2UoL14weC9pLCAnJykubGVuZ3RoIC8gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGVzJyArIHNpemUgKyAnIGZvciAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5yaWdodFBhZCh2YWx1ZSwgc2l6ZSAqIDIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVpbnQnICsgc2l6ZSArICcgc2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIG51bSA9IF9wYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW0ubHQobmV3IEJOKDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50ICcgKyBudW0udG9TdHJpbmcoKSArICcgaXMgbmVnYXRpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZSA/IHV0aWxzLmxlZnRQYWQobnVtLnRvU3RyaW5nKCdoZXgnKSwgc2l6ZSAvIDggKiAyKSA6IG51bTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludCcgKyBzaXplICsgJyBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtID0gX3BhcnNlTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgaW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtLmx0KG5ldyBCTigwKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudW0udG9Ud29zKHNpemUpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplID8gdXRpbHMubGVmdFBhZChudW0udG9TdHJpbmcoJ2hleCcpLCBzaXplIC8gOCAqIDIpIDogbnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBhbGwgb3RoZXIgdHlwZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG59O1xudmFyIF9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzID0gZnVuY3Rpb24gKGFyZykge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0b2RldGVjdGlvbiBvZiBhcnJheSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICB2YXIgdHlwZSwgdmFsdWUgPSAnJztcbiAgICB2YXIgaGV4QXJnLCBhcnJheVNpemU7XG4gICAgLy8gaWYgdHlwZSBpcyBnaXZlblxuICAgIGlmICghIWFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAoYXJnLmhhc093blByb3BlcnR5KCd2JykgfHwgYXJnLmhhc093blByb3BlcnR5KCd0JykgfHwgYXJnLmhhc093blByb3BlcnR5KCd2YWx1ZScpIHx8IGFyZy5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSkge1xuICAgICAgICB0eXBlID0gYXJnLmhhc093blByb3BlcnR5KCd0JykgPyBhcmcudCA6IGFyZy50eXBlO1xuICAgICAgICB2YWx1ZSA9IGFyZy5oYXNPd25Qcm9wZXJ0eSgndicpID8gYXJnLnYgOiBhcmcudmFsdWU7XG4gICAgICAgIC8vIG90aGVyd2lzZSB0cnkgdG8gZ3Vlc3MgdGhlIHR5cGVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSB1dGlscy50b0hleChhcmcsIHRydWUpO1xuICAgICAgICB2YWx1ZSA9IHV0aWxzLnRvSGV4KGFyZyk7XG4gICAgICAgIGlmICghdHlwZS5zdGFydHNXaXRoKCdpbnQnKSAmJiAhdHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYnl0ZXMnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgodHlwZS5zdGFydHNXaXRoKCdpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhL14oLSk/MHgvaS50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IG5ldyBCTih2YWx1ZSk7XG4gICAgfVxuICAgIC8vIGdldCB0aGUgYXJyYXkgc2l6ZVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcnJheVNpemUgPSBfcGFyc2VUeXBlTkFycmF5KHR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlTaXplICYmIHZhbHVlLmxlbmd0aCAhPT0gYXJyYXlTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArICcgaXMgbm90IG1hdGNoaW5nIHRoZSBnaXZlbiBhcnJheSAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5U2l6ZSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaGV4QXJnID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBfc29saWRpdHlQYWNrKHR5cGUsIHZhbCwgYXJyYXlTaXplKS50b1N0cmluZygnaGV4JykucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGV4QXJnLmpvaW4oJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGV4QXJnID0gX3NvbGlkaXR5UGFjayh0eXBlLCB2YWx1ZSwgYXJyYXlTaXplKTtcbiAgICAgICAgcmV0dXJuIGhleEFyZy50b1N0cmluZygnaGV4JykucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgfVxufTtcbi8qKlxuICogSGFzaGVzIHNvbGlkaXR5IHZhbHVlcyB0byBhIHNoYTMgaGFzaCB1c2luZyBrZWNjYWsgMjU2XG4gKlxuICogQG1ldGhvZCBzb2xpZGl0eVNoYTNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNoYTNcbiAqL1xudmFyIHNvbGlkaXR5U2hhMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBoZXhBcmdzID0gYXJncy5tYXAoX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MpO1xuICAgIC8vIGNvbnNvbGUubG9nKGFyZ3MsIGhleEFyZ3MpO1xuICAgIC8vIGNvbnNvbGUubG9nKCcweCcrIGhleEFyZ3Muam9pbignJykpO1xuICAgIHJldHVybiB1dGlscy5zaGEzKCcweCcgKyBoZXhBcmdzLmpvaW4oJycpKTtcbn07XG4vKipcbiAqIEhhc2hlcyBzb2xpZGl0eSB2YWx1ZXMgdG8gYSBzaGEzIGhhc2ggdXNpbmcga2VjY2FrIDI1NiBidXQgZG9lcyByZXR1cm4gdGhlIGhhc2ggb2YgdmFsdWUgYG51bGxgIGluc3RlYWQgb2YgYG51bGxgXG4gKlxuICogQG1ldGhvZCBzb2xpZGl0eVNoYTNSYXdcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNoYTNcbiAqL1xudmFyIHNvbGlkaXR5U2hhM1JhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuc2hhM1JhdygnMHgnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MpLmpvaW4oJycpKTtcbn07XG4vKipcbiAqIEVuY29kZSBwYWNrZWQgYXJncyB0byBoZXhcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVBhY2tlZFxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgaGV4IGVuY29kZWQgYXJndW1lbnRzXG4gKi9cbnZhciBlbmNvZGVQYWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgaGV4QXJncyA9IGFyZ3MubWFwKF9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzKTtcbiAgICByZXR1cm4gJzB4JyArIGhleEFyZ3Muam9pbignJykudG9Mb3dlckNhc2UoKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzb2xpZGl0eVNoYTM6IHNvbGlkaXR5U2hhMyxcbiAgICBzb2xpZGl0eVNoYTNSYXc6IHNvbGlkaXR5U2hhM1JhdyxcbiAgICBlbmNvZGVQYWNrZWQ6IGVuY29kZVBhY2tlZFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/soliditySha3.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/utils.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/utils.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")[\"Buffer\"];\n/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar BN = __webpack_require__(/*! bn.js */ \"../../node_modules/bn.js/lib/bn.js\");\nvar numberToBN = __webpack_require__(/*! number-to-bn */ \"../../node_modules/number-to-bn/src/index.js\");\nvar utf8 = __webpack_require__(/*! utf8 */ \"../../node_modules/utf8/utf8.js\");\nvar ethereumjsUtil = __webpack_require__(/*! ethereumjs-util */ \"../../node_modules/ethereumjs-util/dist.browser/index.js\");\nvar ethereumBloomFilters = __webpack_require__(/*! ethereum-bloom-filters */ \"../../node_modules/ethereum-bloom-filters/dist/index.js\");\n/**\n * Returns true if object is BN, otherwise false\n *\n * @method isBN\n * @param {Object} object\n * @return {Boolean}\n */\nvar isBN = function (object) {\n    return BN.isBN(object);\n};\n/**\n * Returns true if object is BigNumber, otherwise false\n *\n * @method isBigNumber\n * @param {Object} object\n * @return {Boolean}\n */\nvar isBigNumber = function (object) {\n    return object && object.constructor && object.constructor.name === 'BigNumber';\n};\n/**\n * Takes an input and transforms it into an BN\n *\n * @method toBN\n * @param {Number|String|BN} number, string, HEX string or BN\n * @return {BN} BN\n */\nvar toBN = function (number) {\n    try {\n        return numberToBN.apply(null, arguments);\n    }\n    catch (e) {\n        throw new Error(e + ' Given value: \"' + number + '\"');\n    }\n};\n/**\n * Takes and input transforms it into BN and if it is negative value, into two's complement\n *\n * @method toTwosComplement\n * @param {Number|String|BN} number\n * @return {String}\n */\nvar toTwosComplement = function (number) {\n    return '0x' + toBN(number).toTwos(256).toString(16, 64);\n};\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\nvar isAddress = function (address) {\n    // check if it has the basic requirements of an address\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n        // If it's ALL lowercase or ALL upppercase\n    }\n    else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n        // Otherwise check each case\n    }\n    else {\n        return checkAddressChecksum(address);\n    }\n};\n/**\n * Checks if the given string is a checksummed address\n *\n * @method checkAddressChecksum\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\nvar checkAddressChecksum = function (address) {\n    // Check each case\n    address = address.replace(/^0x/i, '');\n    var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '');\n    for (var i = 0; i < 40; i++) {\n        // the nth letter should be uppercase if the nth digit of casemap is 1\n        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method leftPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\nvar leftPad = function (string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n    string = string.toString(16).replace(/^0x/i, '');\n    var padding = (chars - string.length + 1 >= 0) ? chars - string.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + new Array(padding).join(sign ? sign : \"0\") + string;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method rightPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\nvar rightPad = function (string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n    string = string.toString(16).replace(/^0x/i, '');\n    var padding = (chars - string.length + 1 >= 0) ? chars - string.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + string + (new Array(padding).join(sign ? sign : \"0\"));\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @method utf8ToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */\nvar utf8ToHex = function (str) {\n    str = utf8.encode(str);\n    var hex = \"\";\n    // remove \\u0000 padding from either side\n    str = str.replace(/^(?:\\u0000)*/, '');\n    str = str.split(\"\").reverse().join(\"\");\n    str = str.replace(/^(?:\\u0000)*/, '');\n    str = str.split(\"\").reverse().join(\"\");\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        // if (code !== 0) {\n        var n = code.toString(16);\n        hex += n.length < 2 ? '0' + n : n;\n        // }\n    }\n    return \"0x\" + hex;\n};\n/**\n * Should be called to get utf8 from it's hex representation\n *\n * @method hexToUtf8\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */\nvar hexToUtf8 = function (hex) {\n    if (!isHexStrict(hex))\n        throw new Error('The parameter \"' + hex + '\" must be a valid HEX string.');\n    var str = \"\";\n    var code = 0;\n    hex = hex.replace(/^0x/i, '');\n    // remove 00 padding from either side\n    hex = hex.replace(/^(?:00)*/, '');\n    hex = hex.split(\"\").reverse().join(\"\");\n    hex = hex.replace(/^(?:00)*/, '');\n    hex = hex.split(\"\").reverse().join(\"\");\n    var l = hex.length;\n    for (var i = 0; i < l; i += 2) {\n        code = parseInt(hex.substr(i, 2), 16);\n        // if (code !== 0) {\n        str += String.fromCharCode(code);\n        // }\n    }\n    return utf8.decode(str);\n};\n/**\n * Converts value to it's number representation\n *\n * @method hexToNumber\n * @param {String|Number|BN} value\n * @return {String}\n */\nvar hexToNumber = function (value) {\n    if (!value) {\n        return value;\n    }\n    if (typeof value === 'string' && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    return toBN(value).toNumber();\n};\n/**\n * Converts value to it's decimal representation in string\n *\n * @method hexToNumberString\n * @param {String|Number|BN} value\n * @return {String}\n */\nvar hexToNumberString = function (value) {\n    if (!value)\n        return value;\n    if (typeof value === 'string' && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    return toBN(value).toString(10);\n};\n/**\n * Converts value to it's hex representation\n *\n * @method numberToHex\n * @param {String|Number|BN} value\n * @return {String}\n */\nvar numberToHex = function (value) {\n    if ((value === null || value === undefined)) {\n        return value;\n    }\n    if (!isFinite(value) && !isHexStrict(value)) {\n        throw new Error('Given input \"' + value + '\" is not a number.');\n    }\n    var number = toBN(value);\n    var result = number.toString(16);\n    return number.lt(new BN(0)) ? '-0x' + result.substr(1) : '0x' + result;\n};\n/**\n * Convert a byte array to a hex string\n *\n * Note: Implementation from crypto-js\n *\n * @method bytesToHex\n * @param {Array} bytes\n * @return {String} the hex string\n */\nvar bytesToHex = function (bytes) {\n    for (var hex = [], i = 0; i < bytes.length; i++) {\n        /* jshint ignore:start */\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n        /* jshint ignore:end */\n    }\n    return '0x' + hex.join(\"\");\n};\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n * @param {string} hex\n * @return {Array} the byte array\n */\nvar hexToBytes = function (hex) {\n    hex = hex.toString(16);\n    if (!isHexStrict(hex)) {\n        throw new Error('Given value \"' + hex + '\" is not a valid hex string.');\n    }\n    hex = hex.replace(/^0x/i, '');\n    for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n    return bytes;\n};\n/**\n * Auto converts any given value into it's hex representation.\n *\n * And even stringifys objects before.\n *\n * @method toHex\n * @param {String|Number|BN|Object|Buffer} value\n * @param {Boolean} returnType\n * @return {String}\n */\nvar toHex = function (value, returnType) {\n    /*jshint maxcomplexity: false */\n    if (isAddress(value)) {\n        return returnType ? 'address' : '0x' + value.toLowerCase().replace(/^0x/i, '');\n    }\n    if (typeof value === 'boolean') {\n        return returnType ? 'bool' : value ? '0x01' : '0x00';\n    }\n    if (Buffer.isBuffer(value)) {\n        return '0x' + value.toString('hex');\n    }\n    if (typeof value === 'object' && !!value && !isBigNumber(value) && !isBN(value)) {\n        return returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n    }\n    // if its a negative number, pass it through numberToHex\n    if (typeof value === 'string') {\n        if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\n            return returnType ? 'int256' : numberToHex(value);\n        }\n        else if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\n            return returnType ? 'bytes' : value;\n        }\n        else if (!isFinite(value)) {\n            return returnType ? 'string' : utf8ToHex(value);\n        }\n    }\n    return returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value);\n};\n/**\n * Check if string is HEX, requires a 0x in front\n *\n * @method isHexStrict\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\nvar isHexStrict = function (hex) {\n    return ((typeof hex === 'string' || typeof hex === 'number') && /^(-)?0x[0-9a-f]*$/i.test(hex));\n};\n/**\n * Check if string is HEX\n *\n * @method isHex\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\nvar isHex = function (hex) {\n    return ((typeof hex === 'string' || typeof hex === 'number') && /^(-0x|0x)?[0-9a-f]*$/i.test(hex));\n};\n/**\n * Remove 0x prefix from string\n *\n * @method stripHexPrefix\n * @param {String} str to be checked\n * @returns {String}\n */\nvar stripHexPrefix = function (str) {\n    if (str !== 0 && isHex(str))\n        return str.replace(/^(-)?0x/i, '$1');\n    return str;\n};\n/**\n * Returns true if given string is a valid Ethereum block header bloom.\n *\n * @method isBloom\n * @param {String} bloom encoded bloom filter\n * @return {Boolean}\n */\nvar isBloom = function (bloom) {\n    return ethereumBloomFilters.isBloom(bloom);\n};\n/**\n * Returns true if the ethereum users address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} ethereumAddress encoded bloom filter\n * @param {String} bloom ethereum addresss\n * @return {Boolean}\n */\nvar isUserEthereumAddressInBloom = function (bloom, ethereumAddress) {\n    return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);\n};\n/**\n * Returns true if the contract address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} contractAddress contract addresss\n * @return {Boolean}\n */\nvar isContractAddressInBloom = function (bloom, contractAddress) {\n    return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);\n};\n/**\n * Returns true if given string is a valid log topic.\n *\n * @method isTopic\n * @param {String} topic encoded topic\n * @return {Boolean}\n */\nvar isTopic = function (topic) {\n    return ethereumBloomFilters.isTopic(topic);\n};\n/**\n * Returns true if the topic is part of the given bloom\n * note: false positives are possible.\n *\n * @method isTopicInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} topic encoded topic\n * @return {Boolean}\n */\nvar isTopicInBloom = function (bloom, topic) {\n    return ethereumBloomFilters.isTopicInBloom(bloom, topic);\n};\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n *\n * @method isInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String | Uint8Array} topic encoded value\n * @return {Boolean}\n */\nvar isInBloom = function (bloom, topic) {\n    return ethereumBloomFilters.isInBloom(bloom, topic);\n};\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @method sha3\n * @return {String} the sha3 string\n */\nvar SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\nvar sha3 = function (value) {\n    if (isBN(value)) {\n        value = value.toString();\n    }\n    if (isHexStrict(value) && /^0x/i.test((value).toString())) {\n        value = ethereumjsUtil.toBuffer(value);\n    }\n    else if (typeof value === 'string') {\n        // Assume value is an arbitrary string\n        value = Buffer.from(value, 'utf-8');\n    }\n    var returnValue = ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(value));\n    if (returnValue === SHA3_NULL_S) {\n        return null;\n    }\n    else {\n        return returnValue;\n    }\n};\n// expose the under the hood keccak256\nsha3._Hash = ethereumjsUtil.keccak256;\n/**\n * @method sha3Raw\n *\n * @param value\n *\n * @returns {string}\n */\nvar sha3Raw = function (value) {\n    value = sha3(value);\n    if (value === null) {\n        return SHA3_NULL_S;\n    }\n    return value;\n};\n/**\n * Auto converts any given value into it's hex representation,\n * then converts hex to number.\n *\n * @method toNumber\n * @param {String|Number|BN} value\n * @return {Number}\n */\nvar toNumber = function (value) {\n    return typeof value === 'number' ? value : hexToNumber(toHex(value));\n};\nmodule.exports = {\n    BN: BN,\n    isBN: isBN,\n    isBigNumber: isBigNumber,\n    toBN: toBN,\n    isAddress: isAddress,\n    isBloom: isBloom,\n    isUserEthereumAddressInBloom: isUserEthereumAddressInBloom,\n    isContractAddressInBloom: isContractAddressInBloom,\n    isTopic: isTopic,\n    isTopicInBloom: isTopicInBloom,\n    isInBloom: isInBloom,\n    checkAddressChecksum: checkAddressChecksum,\n    utf8ToHex: utf8ToHex,\n    hexToUtf8: hexToUtf8,\n    hexToNumber: hexToNumber,\n    hexToNumberString: hexToNumberString,\n    numberToHex: numberToHex,\n    toHex: toHex,\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    isHex: isHex,\n    isHexStrict: isHexStrict,\n    stripHexPrefix: stripHexPrefix,\n    leftPad: leftPad,\n    rightPad: rightPad,\n    toTwosComplement: toTwosComplement,\n    sha3: sha3,\n    sha3Raw: sha3Raw,\n    toNumber: toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLGlEQUFPO0FBQ3hCLGlCQUFpQixtQkFBTyxDQUFDLGtFQUFjO0FBQ3ZDLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBTTtBQUN6QixxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBaUI7QUFDOUMsMkJBQTJCLG1CQUFPLENBQUMsdUZBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHLHVDQUF1QyxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsTUFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi91dGlscy5qcz82NDFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSB1dGlscy5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIG51bWJlclRvQk4gPSByZXF1aXJlKCdudW1iZXItdG8tYm4nKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xudmFyIGV0aGVyZXVtanNVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG52YXIgZXRoZXJldW1CbG9vbUZpbHRlcnMgPSByZXF1aXJlKCdldGhlcmV1bS1ibG9vbS1maWx0ZXJzJyk7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgQk4sIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCTlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQk4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIEJOLmlzQk4ob2JqZWN0KTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgQmlnTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzQmlnTnVtYmVyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCaWdOdW1iZXInO1xufTtcbi8qKlxuICogVGFrZXMgYW4gaW5wdXQgYW5kIHRyYW5zZm9ybXMgaXQgaW50byBhbiBCTlxuICpcbiAqIEBtZXRob2QgdG9CTlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJOfSBudW1iZXIsIHN0cmluZywgSEVYIHN0cmluZyBvciBCTlxuICogQHJldHVybiB7Qk59IEJOXG4gKi9cbnZhciB0b0JOID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0JOLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlICsgJyBHaXZlbiB2YWx1ZTogXCInICsgbnVtYmVyICsgJ1wiJyk7XG4gICAgfVxufTtcbi8qKlxuICogVGFrZXMgYW5kIGlucHV0IHRyYW5zZm9ybXMgaXQgaW50byBCTiBhbmQgaWYgaXQgaXMgbmVnYXRpdmUgdmFsdWUsIGludG8gdHdvJ3MgY29tcGxlbWVudFxuICpcbiAqIEBtZXRob2QgdG9Ud29zQ29tcGxlbWVudFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJOfSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvVHdvc0NvbXBsZW1lbnQgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgcmV0dXJuICcweCcgKyB0b0JOKG51bWJlcikudG9Ud29zKDI1NikudG9TdHJpbmcoMTYsIDY0KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAvLyBjaGVjayBpZiBpdCBoYXMgdGhlIGJhc2ljIHJlcXVpcmVtZW50cyBvZiBhbiBhZGRyZXNzXG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiBpdCdzIEFMTCBsb3dlcmNhc2Ugb3IgQUxMIHVwcHBlcmNhc2VcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oMHh8MFgpP1swLTlhLWZdezQwfSQvLnRlc3QoYWRkcmVzcykgfHwgL14oMHh8MFgpP1swLTlBLUZdezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjaGVjayBlYWNoIGNhc2VcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3NDaGVja3N1bShhZGRyZXNzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGNoZWNrQWRkcmVzc0NoZWNrc3VtXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBjaGVja0FkZHJlc3NDaGVja3N1bSA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgLy8gQ2hlY2sgZWFjaCBjYXNlXG4gICAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgYWRkcmVzc0hhc2ggPSBzaGEzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgLy8gdGhlIG50aCBsZXR0ZXIgc2hvdWxkIGJlIHVwcGVyY2FzZSBpZiB0aGUgbnRoIGRpZ2l0IG9mIGNhc2VtYXAgaXMgMVxuICAgICAgICBpZiAoKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPiA3ICYmIGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkgfHwgKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPD0gNyAmJiBhZGRyZXNzW2ldLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3NbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCBsZWZ0UGFkXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIGxlZnRQYWQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGFycywgc2lnbikge1xuICAgIHZhciBoYXNQcmVmaXggPSAvXjB4L2kudGVzdChzdHJpbmcpIHx8IHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInO1xuICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygxNikucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgcGFkZGluZyA9IChjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxID49IDApID8gY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSA6IDA7XG4gICAgcmV0dXJuIChoYXNQcmVmaXggPyAnMHgnIDogJycpICsgbmV3IEFycmF5KHBhZGRpbmcpLmpvaW4oc2lnbiA/IHNpZ24gOiBcIjBcIikgKyBzdHJpbmc7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCByaWdodFBhZFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFycyB0aGF0IHJlc3VsdCBzdHJpbmcgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduLCBieSBkZWZhdWx0IDBcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJpZ2h0IGFsaWduZWQgc3RyaW5nXG4gKi9cbnZhciByaWdodFBhZCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgdmFyIGhhc1ByZWZpeCA9IC9eMHgvaS50ZXN0KHN0cmluZykgfHwgdHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcic7XG4gICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKDE2KS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBwYWRkaW5nID0gKGNoYXJzIC0gc3RyaW5nLmxlbmd0aCArIDEgPj0gMCkgPyBjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxIDogMDtcbiAgICByZXR1cm4gKGhhc1ByZWZpeCA/ICcweCcgOiAnJykgKyBzdHJpbmcgKyAobmV3IEFycmF5KHBhZGRpbmcpLmpvaW4oc2lnbiA/IHNpZ24gOiBcIjBcIikpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIHV0ZjhUb0hleFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgdXRmOFRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHN0ciA9IHV0ZjguZW5jb2RlKHN0cik7XG4gICAgdmFyIGhleCA9IFwiXCI7XG4gICAgLy8gcmVtb3ZlIFxcdTAwMDAgcGFkZGluZyBmcm9tIGVpdGhlciBzaWRlXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL14oPzpcXHUwMDAwKSovLCAnJyk7XG4gICAgc3RyID0gc3RyLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKD86XFx1MDAwMCkqLywgJycpO1xuICAgIHN0ciA9IHN0ci5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgaGV4VG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbnZhciBoZXhUb1V0ZjggPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgaWYgKCFpc0hleFN0cmljdChoZXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXJhbWV0ZXIgXCInICsgaGV4ICsgJ1wiIG11c3QgYmUgYSB2YWxpZCBIRVggc3RyaW5nLicpO1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBjb2RlID0gMDtcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICAvLyByZW1vdmUgMDAgcGFkZGluZyBmcm9tIGVpdGhlciBzaWRlXG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14oPzowMCkqLywgJycpO1xuICAgIGhleCA9IGhleC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXig/OjAwKSovLCAnJyk7XG4gICAgaGV4ID0gaGV4LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIHZhciBsID0gaGV4Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICAvLyBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICByZXR1cm4gdXRmOC5kZWNvZGUoc3RyKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgbnVtYmVyIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCBoZXhUb051bWJlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgaGV4VG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzSGV4U3RyaWN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b0JOKHZhbHVlKS50b051bWJlcigpO1xufTtcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIGluIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgaGV4VG9OdW1iZXJTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGhleFRvTnVtYmVyU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICFpc0hleFN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9CTih2YWx1ZSkudG9TdHJpbmcoMTApO1xufTtcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIG51bWJlclRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBudW1iZXJUb0hleCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSAmJiAhaXNIZXhTdHJpY3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gaW5wdXQgXCInICsgdmFsdWUgKyAnXCIgaXMgbm90IGEgbnVtYmVyLicpO1xuICAgIH1cbiAgICB2YXIgbnVtYmVyID0gdG9CTih2YWx1ZSk7XG4gICAgdmFyIHJlc3VsdCA9IG51bWJlci50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIG51bWJlci5sdChuZXcgQk4oMCkpID8gJy0weCcgKyByZXN1bHQuc3Vic3RyKDEpIDogJzB4JyArIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgaGV4IHN0cmluZ1xuICpcbiAqIE5vdGU6IEltcGxlbWVudGF0aW9uIGZyb20gY3J5cHRvLWpzXG4gKlxuICogQG1ldGhvZCBieXRlc1RvSGV4XG4gKiBAcGFyYW0ge0FycmF5fSBieXRlc1xuICogQHJldHVybiB7U3RyaW5nfSB0aGUgaGV4IHN0cmluZ1xuICovXG52YXIgYnl0ZXNUb0hleCA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIGZvciAodmFyIGhleCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gICAgfVxuICAgIHJldHVybiAnMHgnICsgaGV4LmpvaW4oXCJcIik7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAqXG4gKiBOb3RlOiBJbXBsZW1lbnRhdGlvbiBmcm9tIGNyeXB0by1qc1xuICpcbiAqIEBtZXRob2QgaGV4VG9CeXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGhleFxuICogQHJldHVybiB7QXJyYXl9IHRoZSBieXRlIGFycmF5XG4gKi9cbnZhciBoZXhUb0J5dGVzID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGhleCA9IGhleC50b1N0cmluZygxNik7XG4gICAgaWYgKCFpc0hleFN0cmljdChoZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gdmFsdWUgXCInICsgaGV4ICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcbi8qKlxuICogQXV0byBjb252ZXJ0cyBhbnkgZ2l2ZW4gdmFsdWUgaW50byBpdCdzIGhleCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBBbmQgZXZlbiBzdHJpbmdpZnlzIG9iamVjdHMgYmVmb3JlLlxuICpcbiAqIEBtZXRob2QgdG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTnxPYmplY3R8QnVmZmVyfSB2YWx1ZVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5UeXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b0hleCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmV0dXJuVHlwZSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IGZhbHNlICovXG4gICAgaWYgKGlzQWRkcmVzcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnYWRkcmVzcycgOiAnMHgnICsgdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnYm9vbCcgOiB2YWx1ZSA/ICcweDAxJyA6ICcweDAwJztcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyB2YWx1ZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICEhdmFsdWUgJiYgIWlzQmlnTnVtYmVyKHZhbHVlKSAmJiAhaXNCTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnc3RyaW5nJyA6IHV0ZjhUb0hleChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBpZiBpdHMgYSBuZWdhdGl2ZSBudW1iZXIsIHBhc3MgaXQgdGhyb3VnaCBudW1iZXJUb0hleFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCctMHgnKSA9PT0gMCB8fCB2YWx1ZS5pbmRleE9mKCctMFgnKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnaW50MjU2JyA6IG51bWJlclRvSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCcweCcpID09PSAwIHx8IHZhbHVlLmluZGV4T2YoJzBYJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2J5dGVzJyA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ3N0cmluZycgOiB1dGY4VG9IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5UeXBlID8gKHZhbHVlIDwgMCA/ICdpbnQyNTYnIDogJ3VpbnQyNTYnKSA6IG51bWJlclRvSGV4KHZhbHVlKTtcbn07XG4vKipcbiAqIENoZWNrIGlmIHN0cmluZyBpcyBIRVgsIHJlcXVpcmVzIGEgMHggaW4gZnJvbnRcbiAqXG4gKiBAbWV0aG9kIGlzSGV4U3RyaWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG52YXIgaXNIZXhTdHJpY3QgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgcmV0dXJuICgodHlwZW9mIGhleCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGhleCA9PT0gJ251bWJlcicpICYmIC9eKC0pPzB4WzAtOWEtZl0qJC9pLnRlc3QoaGV4KSk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBzdHJpbmcgaXMgSEVYXG4gKlxuICogQG1ldGhvZCBpc0hleFxuICogQHBhcmFtIHtTdHJpbmd9IGhleCB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIHJldHVybiAoKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZXggPT09ICdudW1iZXInKSAmJiAvXigtMHh8MHgpP1swLTlhLWZdKiQvaS50ZXN0KGhleCkpO1xufTtcbi8qKlxuICogUmVtb3ZlIDB4IHByZWZpeCBmcm9tIHN0cmluZ1xuICpcbiAqIEBtZXRob2Qgc3RyaXBIZXhQcmVmaXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xudmFyIHN0cmlwSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgIT09IDAgJiYgaXNIZXgoc3RyKSlcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eKC0pPzB4L2ksICckMScpO1xuICAgIHJldHVybiBzdHI7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgRXRoZXJldW0gYmxvY2sgaGVhZGVyIGJsb29tLlxuICpcbiAqIEBtZXRob2QgaXNCbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNCbG9vbSA9IGZ1bmN0aW9uIChibG9vbSkge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc0Jsb29tKGJsb29tKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXRoZXJldW0gdXNlcnMgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBldGhlcmV1bUFkZHJlc3MgZW5jb2RlZCBibG9vbSBmaWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBldGhlcmV1bSBhZGRyZXNzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20gPSBmdW5jdGlvbiAoYmxvb20sIGV0aGVyZXVtQWRkcmVzcykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tKGJsb29tLCBldGhlcmV1bUFkZHJlc3MpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cmFjdCBhZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udHJhY3RBZGRyZXNzIGNvbnRyYWN0IGFkZHJlc3NzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNDb250cmFjdEFkZHJlc3NJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCBjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNDb250cmFjdEFkZHJlc3NJbkJsb29tKGJsb29tLCBjb250cmFjdEFkZHJlc3MpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIGxvZyB0b3BpYy5cbiAqXG4gKiBAbWV0aG9kIGlzVG9waWNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyBlbmNvZGVkIHRvcGljXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUb3BpYyA9IGZ1bmN0aW9uICh0b3BpYykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc1RvcGljKHRvcGljKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9waWMgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCBpc1RvcGljSW5CbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgZW5jb2RlZCB0b3BpY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzVG9waWNJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCB0b3BpYykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc1RvcGljSW5CbG9vbShibG9vbSwgdG9waWMpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGlzSW5CbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZyB8IFVpbnQ4QXJyYXl9IHRvcGljIGVuY29kZWQgdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0luQmxvb20gPSBmdW5jdGlvbiAoYmxvb20sIHRvcGljKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzSW5CbG9vbShibG9vbSwgdG9waWMpO1xufTtcbi8qKlxuICogSGFzaGVzIHZhbHVlcyB0byBhIHNoYTMgaGFzaCB1c2luZyBrZWNjYWsgMjU2XG4gKlxuICogVG8gaGFzaCBhIEhFWCBzdHJpbmcgdGhlIGhleCBtdXN0IGhhdmUgMHggaW4gZnJvbnQuXG4gKlxuICogQG1ldGhvZCBzaGEzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzaGEzIHN0cmluZ1xuICovXG52YXIgU0hBM19OVUxMX1MgPSAnMHhjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbnZhciBzaGEzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGlzQk4odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaWN0KHZhbHVlKSAmJiAvXjB4L2kudGVzdCgodmFsdWUpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgIHZhbHVlID0gZXRoZXJldW1qc1V0aWwudG9CdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFzc3VtZSB2YWx1ZSBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nXG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsICd1dGYtOCcpO1xuICAgIH1cbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBldGhlcmV1bWpzVXRpbC5idWZmZXJUb0hleChldGhlcmV1bWpzVXRpbC5rZWNjYWsyNTYodmFsdWUpKTtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IFNIQTNfTlVMTF9TKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbn07XG4vLyBleHBvc2UgdGhlIHVuZGVyIHRoZSBob29kIGtlY2NhazI1Nlxuc2hhMy5fSGFzaCA9IGV0aGVyZXVtanNVdGlsLmtlY2NhazI1Njtcbi8qKlxuICogQG1ldGhvZCBzaGEzUmF3XG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xudmFyIHNoYTNSYXcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNoYTModmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU0hBM19OVUxMX1M7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEF1dG8gY29udmVydHMgYW55IGdpdmVuIHZhbHVlIGludG8gaXQncyBoZXggcmVwcmVzZW50YXRpb24sXG4gKiB0aGVuIGNvbnZlcnRzIGhleCB0byBudW1iZXIuXG4gKlxuICogQG1ldGhvZCB0b051bWJlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogaGV4VG9OdW1iZXIodG9IZXgodmFsdWUpKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCTjogQk4sXG4gICAgaXNCTjogaXNCTixcbiAgICBpc0JpZ051bWJlcjogaXNCaWdOdW1iZXIsXG4gICAgdG9CTjogdG9CTixcbiAgICBpc0FkZHJlc3M6IGlzQWRkcmVzcyxcbiAgICBpc0Jsb29tOiBpc0Jsb29tLFxuICAgIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb206IGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20sXG4gICAgaXNDb250cmFjdEFkZHJlc3NJbkJsb29tOiBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb20sXG4gICAgaXNUb3BpYzogaXNUb3BpYyxcbiAgICBpc1RvcGljSW5CbG9vbTogaXNUb3BpY0luQmxvb20sXG4gICAgaXNJbkJsb29tOiBpc0luQmxvb20sXG4gICAgY2hlY2tBZGRyZXNzQ2hlY2tzdW06IGNoZWNrQWRkcmVzc0NoZWNrc3VtLFxuICAgIHV0ZjhUb0hleDogdXRmOFRvSGV4LFxuICAgIGhleFRvVXRmODogaGV4VG9VdGY4LFxuICAgIGhleFRvTnVtYmVyOiBoZXhUb051bWJlcixcbiAgICBoZXhUb051bWJlclN0cmluZzogaGV4VG9OdW1iZXJTdHJpbmcsXG4gICAgbnVtYmVyVG9IZXg6IG51bWJlclRvSGV4LFxuICAgIHRvSGV4OiB0b0hleCxcbiAgICBoZXhUb0J5dGVzOiBoZXhUb0J5dGVzLFxuICAgIGJ5dGVzVG9IZXg6IGJ5dGVzVG9IZXgsXG4gICAgaXNIZXg6IGlzSGV4LFxuICAgIGlzSGV4U3RyaWN0OiBpc0hleFN0cmljdCxcbiAgICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gICAgbGVmdFBhZDogbGVmdFBhZCxcbiAgICByaWdodFBhZDogcmlnaHRQYWQsXG4gICAgdG9Ud29zQ29tcGxlbWVudDogdG9Ud29zQ29tcGxlbWVudCxcbiAgICBzaGEzOiBzaGEzLFxuICAgIHNoYTNSYXc6IHNoYTNSYXcsXG4gICAgdG9OdW1iZXI6IHRvTnVtYmVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/utils.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3/lib/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3/lib/index.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n *   Gav Wood <gav@parity.io>\n *   Jeffrey Wilcke <jeffrey.wilcke@ethereum.org>\n *   Marek Kotewicz <marek@parity.io>\n *   Marian Oancea <marian@ethereum.org>\n * @date 2017\n */\n\nvar version = (__webpack_require__(/*! ../package.json */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3/package.json\").version);\nvar core = __webpack_require__(/*! web3-core */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-core/lib/index.js\");\nvar Eth = __webpack_require__(/*! web3-eth */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth/lib/index.js\");\nvar Net = __webpack_require__(/*! web3-net */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-net/lib/index.js\");\nvar Personal = __webpack_require__(/*! web3-eth-personal */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-eth-personal/lib/index.js\");\nvar Shh = __webpack_require__(/*! web3-shh */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-shh/lib/index.js\");\nvar Bzz = __webpack_require__(/*! web3-bzz */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-bzz/lib/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"../../node_modules/@alch/alchemy-web3/node_modules/web3-utils/lib/index.js\");\nvar Web3 = function Web3() {\n    var _this = this;\n    // sets _requestmanager etc\n    core.packageInit(this, arguments);\n    this.version = version;\n    this.utils = utils;\n    this.eth = new Eth(this);\n    this.shh = new Shh(this);\n    this.bzz = new Bzz(this);\n    // overwrite package setProvider\n    var setProvider = this.setProvider;\n    this.setProvider = function (provider, net) {\n        /*jshint unused: false */\n        setProvider.apply(_this, arguments);\n        _this.eth.setRequestManager(_this._requestManager);\n        _this.shh.setRequestManager(_this._requestManager);\n        _this.bzz.setProvider(provider);\n        return true;\n    };\n};\nWeb3.version = version;\nWeb3.utils = utils;\nWeb3.modules = {\n    Eth: Eth,\n    Net: Net,\n    Personal: Personal,\n    Shh: Shh,\n    Bzz: Bzz\n};\ncore.addProviders(Web3);\nmodule.exports = Web3;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhbGNoL2FsY2hlbXktd2ViMy9ub2RlX21vZHVsZXMvd2ViMy9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixjQUFjLDRIQUFrQztBQUNoRCxXQUFXLG1CQUFPLENBQUMsNEZBQVc7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLDBGQUFVO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQywwRkFBVTtBQUM1QixlQUFlLG1CQUFPLENBQUMsNEdBQW1CO0FBQzFDLFVBQVUsbUJBQU8sQ0FBQywwRkFBVTtBQUM1QixVQUFVLG1CQUFPLENBQUMsMEZBQVU7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLDhGQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFsY2gvYWxjaGVteS13ZWIzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9pbmRleC5qcz9lNDk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGluZGV4LmpzXG4gKiBAYXV0aG9yczpcbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqICAgR2F2IFdvb2QgPGdhdkBwYXJpdHkuaW8+XG4gKiAgIEplZmZyZXkgV2lsY2tlIDxqZWZmcmV5LndpbGNrZUBldGhlcmV1bS5vcmc+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BwYXJpdHkuaW8+XG4gKiAgIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIHZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xudmFyIGNvcmUgPSByZXF1aXJlKCd3ZWIzLWNvcmUnKTtcbnZhciBFdGggPSByZXF1aXJlKCd3ZWIzLWV0aCcpO1xudmFyIE5ldCA9IHJlcXVpcmUoJ3dlYjMtbmV0Jyk7XG52YXIgUGVyc29uYWwgPSByZXF1aXJlKCd3ZWIzLWV0aC1wZXJzb25hbCcpO1xudmFyIFNoaCA9IHJlcXVpcmUoJ3dlYjMtc2hoJyk7XG52YXIgQnp6ID0gcmVxdWlyZSgnd2ViMy1ienonKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBXZWIzID0gZnVuY3Rpb24gV2ViMygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIHNldHMgX3JlcXVlc3RtYW5hZ2VyIGV0Y1xuICAgIGNvcmUucGFja2FnZUluaXQodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMudXRpbHMgPSB1dGlscztcbiAgICB0aGlzLmV0aCA9IG5ldyBFdGgodGhpcyk7XG4gICAgdGhpcy5zaGggPSBuZXcgU2hoKHRoaXMpO1xuICAgIHRoaXMuYnp6ID0gbmV3IEJ6eih0aGlzKTtcbiAgICAvLyBvdmVyd3JpdGUgcGFja2FnZSBzZXRQcm92aWRlclxuICAgIHZhciBzZXRQcm92aWRlciA9IHRoaXMuc2V0UHJvdmlkZXI7XG4gICAgdGhpcy5zZXRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgbmV0KSB7XG4gICAgICAgIC8qanNoaW50IHVudXNlZDogZmFsc2UgKi9cbiAgICAgICAgc2V0UHJvdmlkZXIuYXBwbHkoX3RoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIF90aGlzLmV0aC5zZXRSZXF1ZXN0TWFuYWdlcihfdGhpcy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICBfdGhpcy5zaGguc2V0UmVxdWVzdE1hbmFnZXIoX3RoaXMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgX3RoaXMuYnp6LnNldFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn07XG5XZWIzLnZlcnNpb24gPSB2ZXJzaW9uO1xuV2ViMy51dGlscyA9IHV0aWxzO1xuV2ViMy5tb2R1bGVzID0ge1xuICAgIEV0aDogRXRoLFxuICAgIE5ldDogTmV0LFxuICAgIFBlcnNvbmFsOiBQZXJzb25hbCxcbiAgICBTaGg6IFNoaCxcbiAgICBCeno6IEJ6elxufTtcbmNvcmUuYWRkUHJvdmlkZXJzKFdlYjMpO1xubW9kdWxlLmV4cG9ydHMgPSBXZWIzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@alch/alchemy-web3/node_modules/web3/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/assert-never/index.js":
/*!************************************************!*\
  !*** ../../node_modules/assert-never/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Helper function for exhaustive checks of discriminated unions.\n * https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html\n *\n * @example\n *\n *    type A = {type: 'a'};\n *    type B = {type: 'b'};\n *    type Union = A | B;\n *\n *    function doSomething(arg: Union) {\n *      if (arg.type === 'a') {\n *        return something;\n *      }\n *\n *      if (arg.type === 'b') {\n *        return somethingElse;\n *      }\n *\n *      // TS will error if there are other types in the union\n *      // Will throw an Error when called at runtime.\n *      // Use `assertNever(arg, true)` instead to fail silently.\n *      return assertNever(arg);\n *    }\n */\nfunction assertNever(value, noThrow) {\n    if (noThrow) {\n        return value;\n    }\n    throw new Error(\"Unhandled discriminated union member: \" + JSON.stringify(value));\n}\nexports.assertNever = assertNever;\nexports[\"default\"] = assertNever;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Fzc2VydC1uZXZlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9hc3NlcnQtbmV2ZXIvaW5kZXguanM/MDE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBleGhhdXN0aXZlIGNoZWNrcyBvZiBkaXNjcmltaW5hdGVkIHVuaW9ucy5cbiAqIGh0dHBzOi8vYmFzYXJhdC5naXRib29rcy5pby90eXBlc2NyaXB0L2RvY3MvdHlwZXMvZGlzY3JpbWluYXRlZC11bmlvbnMuaHRtbFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgdHlwZSBBID0ge3R5cGU6ICdhJ307XG4gKiAgICB0eXBlIEIgPSB7dHlwZTogJ2InfTtcbiAqICAgIHR5cGUgVW5pb24gPSBBIHwgQjtcbiAqXG4gKiAgICBmdW5jdGlvbiBkb1NvbWV0aGluZyhhcmc6IFVuaW9uKSB7XG4gKiAgICAgIGlmIChhcmcudHlwZSA9PT0gJ2EnKSB7XG4gKiAgICAgICAgcmV0dXJuIHNvbWV0aGluZztcbiAqICAgICAgfVxuICpcbiAqICAgICAgaWYgKGFyZy50eXBlID09PSAnYicpIHtcbiAqICAgICAgICByZXR1cm4gc29tZXRoaW5nRWxzZTtcbiAqICAgICAgfVxuICpcbiAqICAgICAgLy8gVFMgd2lsbCBlcnJvciBpZiB0aGVyZSBhcmUgb3RoZXIgdHlwZXMgaW4gdGhlIHVuaW9uXG4gKiAgICAgIC8vIFdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBjYWxsZWQgYXQgcnVudGltZS5cbiAqICAgICAgLy8gVXNlIGBhc3NlcnROZXZlcihhcmcsIHRydWUpYCBpbnN0ZWFkIHRvIGZhaWwgc2lsZW50bHkuXG4gKiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhcmcpO1xuICogICAgfVxuICovXG5mdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZSwgbm9UaHJvdykge1xuICAgIGlmIChub1Rocm93KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5oYW5kbGVkIGRpc2NyaW1pbmF0ZWQgdW5pb24gbWVtYmVyOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5leHBvcnRzLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnROZXZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/assert-never/index.js\n");

/***/ }),

/***/ "../../node_modules/eventemitter3/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/eventemitter3/index.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzPzI0YjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "../../node_modules/fetch-ponyfill/build/fetch-browser.js":
/*!****************************************************************!*\
  !*** ../../node_modules/fetch-ponyfill/build/fetch-browser.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;(function (self) {\n  'use strict';\n\n  function fetchPonyfill(options) {\n    var Promise = options && options.Promise || self.Promise;\n    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;\n    var global = self;\n\n    return (function () {\n      var self = Object.create(global, {\n        fetch: {\n          value: undefined,\n          writable: true\n        }\n      });\n\n      (function(self) {\n        'use strict';\n\n        if (self.fetch) {\n          return\n        }\n\n        var support = {\n          searchParams: 'URLSearchParams' in self,\n          iterable: 'Symbol' in self && 'iterator' in Symbol,\n          blob: 'FileReader' in self && 'Blob' in self && (function() {\n            try {\n              new Blob()\n              return true\n            } catch(e) {\n              return false\n            }\n          })(),\n          formData: 'FormData' in self,\n          arrayBuffer: 'ArrayBuffer' in self\n        }\n\n        if (support.arrayBuffer) {\n          var viewClasses = [\n            '[object Int8Array]',\n            '[object Uint8Array]',\n            '[object Uint8ClampedArray]',\n            '[object Int16Array]',\n            '[object Uint16Array]',\n            '[object Int32Array]',\n            '[object Uint32Array]',\n            '[object Float32Array]',\n            '[object Float64Array]'\n          ]\n\n          var isDataView = function(obj) {\n            return obj && DataView.prototype.isPrototypeOf(obj)\n          }\n\n          var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n          }\n        }\n\n        function normalizeName(name) {\n          if (typeof name !== 'string') {\n            name = String(name)\n          }\n          if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n            throw new TypeError('Invalid character in header field name')\n          }\n          return name.toLowerCase()\n        }\n\n        function normalizeValue(value) {\n          if (typeof value !== 'string') {\n            value = String(value)\n          }\n          return value\n        }\n\n        // Build a destructive iterator for the value list\n        function iteratorFor(items) {\n          var iterator = {\n            next: function() {\n              var value = items.shift()\n              return {done: value === undefined, value: value}\n            }\n          }\n\n          if (support.iterable) {\n            iterator[Symbol.iterator] = function() {\n              return iterator\n            }\n          }\n\n          return iterator\n        }\n\n        function Headers(headers) {\n          this.map = {}\n\n          if (headers instanceof Headers) {\n            headers.forEach(function(value, name) {\n              this.append(name, value)\n            }, this)\n          } else if (Array.isArray(headers)) {\n            headers.forEach(function(header) {\n              this.append(header[0], header[1])\n            }, this)\n          } else if (headers) {\n            Object.getOwnPropertyNames(headers).forEach(function(name) {\n              this.append(name, headers[name])\n            }, this)\n          }\n        }\n\n        Headers.prototype.append = function(name, value) {\n          name = normalizeName(name)\n          value = normalizeValue(value)\n          var oldValue = this.map[name]\n          this.map[name] = oldValue ? oldValue+','+value : value\n        }\n\n        Headers.prototype['delete'] = function(name) {\n          delete this.map[normalizeName(name)]\n        }\n\n        Headers.prototype.get = function(name) {\n          name = normalizeName(name)\n          return this.has(name) ? this.map[name] : null\n        }\n\n        Headers.prototype.has = function(name) {\n          return this.map.hasOwnProperty(normalizeName(name))\n        }\n\n        Headers.prototype.set = function(name, value) {\n          this.map[normalizeName(name)] = normalizeValue(value)\n        }\n\n        Headers.prototype.forEach = function(callback, thisArg) {\n          for (var name in this.map) {\n            if (this.map.hasOwnProperty(name)) {\n              callback.call(thisArg, this.map[name], name, this)\n            }\n          }\n        }\n\n        Headers.prototype.keys = function() {\n          var items = []\n          this.forEach(function(value, name) { items.push(name) })\n          return iteratorFor(items)\n        }\n\n        Headers.prototype.values = function() {\n          var items = []\n          this.forEach(function(value) { items.push(value) })\n          return iteratorFor(items)\n        }\n\n        Headers.prototype.entries = function() {\n          var items = []\n          this.forEach(function(value, name) { items.push([name, value]) })\n          return iteratorFor(items)\n        }\n\n        if (support.iterable) {\n          Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n        }\n\n        function consumed(body) {\n          if (body.bodyUsed) {\n            return Promise.reject(new TypeError('Already read'))\n          }\n          body.bodyUsed = true\n        }\n\n        function fileReaderReady(reader) {\n          return new Promise(function(resolve, reject) {\n            reader.onload = function() {\n              resolve(reader.result)\n            }\n            reader.onerror = function() {\n              reject(reader.error)\n            }\n          })\n        }\n\n        function readBlobAsArrayBuffer(blob) {\n          var reader = new FileReader()\n          var promise = fileReaderReady(reader)\n          reader.readAsArrayBuffer(blob)\n          return promise\n        }\n\n        function readBlobAsText(blob) {\n          var reader = new FileReader()\n          var promise = fileReaderReady(reader)\n          reader.readAsText(blob)\n          return promise\n        }\n\n        function readArrayBufferAsText(buf) {\n          var view = new Uint8Array(buf)\n          var chars = new Array(view.length)\n\n          for (var i = 0; i < view.length; i++) {\n            chars[i] = String.fromCharCode(view[i])\n          }\n          return chars.join('')\n        }\n\n        function bufferClone(buf) {\n          if (buf.slice) {\n            return buf.slice(0)\n          } else {\n            var view = new Uint8Array(buf.byteLength)\n            view.set(new Uint8Array(buf))\n            return view.buffer\n          }\n        }\n\n        function Body() {\n          this.bodyUsed = false\n\n          this._initBody = function(body) {\n            this._bodyInit = body\n            if (!body) {\n              this._bodyText = ''\n            } else if (typeof body === 'string') {\n              this._bodyText = body\n            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n              this._bodyBlob = body\n            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n              this._bodyFormData = body\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n              this._bodyText = body.toString()\n            } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n              this._bodyArrayBuffer = bufferClone(body.buffer)\n              // IE 10-11 can't handle a DataView body.\n              this._bodyInit = new Blob([this._bodyArrayBuffer])\n            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n              this._bodyArrayBuffer = bufferClone(body)\n            } else {\n              throw new Error('unsupported BodyInit type')\n            }\n\n            if (!this.headers.get('content-type')) {\n              if (typeof body === 'string') {\n                this.headers.set('content-type', 'text/plain;charset=UTF-8')\n              } else if (this._bodyBlob && this._bodyBlob.type) {\n                this.headers.set('content-type', this._bodyBlob.type)\n              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n              }\n            }\n          }\n\n          if (support.blob) {\n            this.blob = function() {\n              var rejected = consumed(this)\n              if (rejected) {\n                return rejected\n              }\n\n              if (this._bodyBlob) {\n                return Promise.resolve(this._bodyBlob)\n              } else if (this._bodyArrayBuffer) {\n                return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n              } else if (this._bodyFormData) {\n                throw new Error('could not read FormData body as blob')\n              } else {\n                return Promise.resolve(new Blob([this._bodyText]))\n              }\n            }\n\n            this.arrayBuffer = function() {\n              if (this._bodyArrayBuffer) {\n                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n              } else {\n                return this.blob().then(readBlobAsArrayBuffer)\n              }\n            }\n          }\n\n          this.text = function() {\n            var rejected = consumed(this)\n            if (rejected) {\n              return rejected\n            }\n\n            if (this._bodyBlob) {\n              return readBlobAsText(this._bodyBlob)\n            } else if (this._bodyArrayBuffer) {\n              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n            } else if (this._bodyFormData) {\n              throw new Error('could not read FormData body as text')\n            } else {\n              return Promise.resolve(this._bodyText)\n            }\n          }\n\n          if (support.formData) {\n            this.formData = function() {\n              return this.text().then(decode)\n            }\n          }\n\n          this.json = function() {\n            return this.text().then(JSON.parse)\n          }\n\n          return this\n        }\n\n        // HTTP methods whose capitalization should be normalized\n        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n        function normalizeMethod(method) {\n          var upcased = method.toUpperCase()\n          return (methods.indexOf(upcased) > -1) ? upcased : method\n        }\n\n        function Request(input, options) {\n          options = options || {}\n          var body = options.body\n\n          if (input instanceof Request) {\n            if (input.bodyUsed) {\n              throw new TypeError('Already read')\n            }\n            this.url = input.url\n            this.credentials = input.credentials\n            if (!options.headers) {\n              this.headers = new Headers(input.headers)\n            }\n            this.method = input.method\n            this.mode = input.mode\n            if (!body && input._bodyInit != null) {\n              body = input._bodyInit\n              input.bodyUsed = true\n            }\n          } else {\n            this.url = String(input)\n          }\n\n          this.credentials = options.credentials || this.credentials || 'omit'\n          if (options.headers || !this.headers) {\n            this.headers = new Headers(options.headers)\n          }\n          this.method = normalizeMethod(options.method || this.method || 'GET')\n          this.mode = options.mode || this.mode || null\n          this.referrer = null\n\n          if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n            throw new TypeError('Body not allowed for GET or HEAD requests')\n          }\n          this._initBody(body)\n        }\n\n        Request.prototype.clone = function() {\n          return new Request(this, { body: this._bodyInit })\n        }\n\n        function decode(body) {\n          var form = new FormData()\n          body.trim().split('&').forEach(function(bytes) {\n            if (bytes) {\n              var split = bytes.split('=')\n              var name = split.shift().replace(/\\+/g, ' ')\n              var value = split.join('=').replace(/\\+/g, ' ')\n              form.append(decodeURIComponent(name), decodeURIComponent(value))\n            }\n          })\n          return form\n        }\n\n        function parseHeaders(rawHeaders) {\n          var headers = new Headers()\n          // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n          // https://tools.ietf.org/html/rfc7230#section-3.2\n          var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n          preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n            var parts = line.split(':')\n            var key = parts.shift().trim()\n            if (key) {\n              var value = parts.join(':').trim()\n              headers.append(key, value)\n            }\n          })\n          return headers\n        }\n\n        Body.call(Request.prototype)\n\n        function Response(bodyInit, options) {\n          if (!options) {\n            options = {}\n          }\n\n          this.type = 'default'\n          this.status = options.status === undefined ? 200 : options.status\n          this.ok = this.status >= 200 && this.status < 300\n          this.statusText = 'statusText' in options ? options.statusText : 'OK'\n          this.headers = new Headers(options.headers)\n          this.url = options.url || ''\n          this._initBody(bodyInit)\n        }\n\n        Body.call(Response.prototype)\n\n        Response.prototype.clone = function() {\n          return new Response(this._bodyInit, {\n            status: this.status,\n            statusText: this.statusText,\n            headers: new Headers(this.headers),\n            url: this.url\n          })\n        }\n\n        Response.error = function() {\n          var response = new Response(null, {status: 0, statusText: ''})\n          response.type = 'error'\n          return response\n        }\n\n        var redirectStatuses = [301, 302, 303, 307, 308]\n\n        Response.redirect = function(url, status) {\n          if (redirectStatuses.indexOf(status) === -1) {\n            throw new RangeError('Invalid status code')\n          }\n\n          return new Response(null, {status: status, headers: {location: url}})\n        }\n\n        self.Headers = Headers\n        self.Request = Request\n        self.Response = Response\n\n        self.fetch = function(input, init) {\n          return new Promise(function(resolve, reject) {\n            var request = new Request(input, init)\n            var xhr = new XMLHttpRequest()\n\n            xhr.onload = function() {\n              var options = {\n                status: xhr.status,\n                statusText: xhr.statusText,\n                headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n              }\n              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n              var body = 'response' in xhr ? xhr.response : xhr.responseText\n              resolve(new Response(body, options))\n            }\n\n            xhr.onerror = function() {\n              reject(new TypeError('Network request failed'))\n            }\n\n            xhr.ontimeout = function() {\n              reject(new TypeError('Network request failed'))\n            }\n\n            xhr.open(request.method, request.url, true)\n\n            if (request.credentials === 'include') {\n              xhr.withCredentials = true\n            } else if (request.credentials === 'omit') {\n              xhr.withCredentials = false\n            }\n\n            if ('responseType' in xhr && support.blob) {\n              xhr.responseType = 'blob'\n            }\n\n            request.headers.forEach(function(value, name) {\n              xhr.setRequestHeader(name, value)\n            })\n\n            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n          })\n        }\n        self.fetch.polyfill = true\n      })(typeof self !== 'undefined' ? self : this);\n\n\n      return {\n        fetch: self.fetch,\n        Headers: self.Headers,\n        Request: self.Request,\n        Response: self.Response\n      };\n    }());\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return fetchPonyfill;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(typeof self !== 'undefined' ? self : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : this));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZldGNoLXBvbnlmaWxsL2J1aWxkL2ZldGNoLWJyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEIsb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLDZDQUE2QywwQkFBMEI7QUFDdkU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQywwQkFBMEIsZUFBZTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsTUFBTSxJQUEwQztBQUNoRCxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsa0dBQUM7QUFDTixJQUFJLEtBQUssRUFJTjtBQUNILENBQUMsNkNBQTZDLHFCQUFNLG1CQUFtQixxQkFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2ZldGNoLXBvbnlmaWxsL2J1aWxkL2ZldGNoLWJyb3dzZXIuanM/M2YxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGZldGNoUG9ueWZpbGwob3B0aW9ucykge1xuICAgIHZhciBQcm9taXNlID0gb3B0aW9ucyAmJiBvcHRpb25zLlByb21pc2UgfHwgc2VsZi5Qcm9taXNlO1xuICAgIHZhciBYTUxIdHRwUmVxdWVzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5YTUxIdHRwUmVxdWVzdCB8fCBzZWxmLlhNTEh0dHBSZXF1ZXN0O1xuICAgIHZhciBnbG9iYWwgPSBzZWxmO1xuXG4gICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsLCB7XG4gICAgICAgIGZldGNoOiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGlmIChzZWxmLmZldGNoKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VwcG9ydCA9IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgICAgICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgICAgICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCksXG4gICAgICAgICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICAgICAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgICAgICAgIF1cblxuICAgICAgICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICAgICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgICAgICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgICAgICAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gICAgICAgIH1cblxuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgICAgICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgICAgICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgICAgICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgICAgICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgICAgICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICAgICAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICAgICAgICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgICAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICAgICAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICAgICAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgICAgICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICAgICAgICB9XG5cbiAgICAgICAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICAgICAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBmb3JtXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgICAgICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgICAgICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgICAgICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gICAgICAgICAgcHJlUHJvY2Vzc2VkSGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICAgICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIGhlYWRlcnNcbiAgICAgICAgfVxuXG4gICAgICAgIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICAgICAgICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXNcbiAgICAgICAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICAgICAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgICAgICAgfVxuXG4gICAgICAgIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgICAgICAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICAgICAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgICAgICAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgICAgICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgICAgICAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICAgICAgICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICAgICAgICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG4gICAgICB9KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmV0Y2g6IHNlbGYuZmV0Y2gsXG4gICAgICAgIEhlYWRlcnM6IHNlbGYuSGVhZGVycyxcbiAgICAgICAgUmVxdWVzdDogc2VsZi5SZXF1ZXN0LFxuICAgICAgICBSZXNwb25zZTogc2VsZi5SZXNwb25zZVxuICAgICAgfTtcbiAgICB9KCkpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmV0Y2hQb255ZmlsbDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZldGNoUG9ueWZpbGw7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5mZXRjaFBvbnlmaWxsID0gZmV0Y2hQb255ZmlsbDtcbiAgfVxufSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0aGlzKSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fetch-ponyfill/build/fetch-browser.js\n");

/***/ }),

/***/ "../../node_modules/sturdy-websocket/dist/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/sturdy-websocket/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports[\"default\"] = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3N0dXJkeS13ZWJzb2NrZXQvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsd0JBQXdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDZCQUE2QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQ0FBa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBNkM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9zdHVyZHktd2Vic29ja2V0L2Rpc3QvaW5kZXguanM/MzU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTSE9VTERfUkVDT05ORUNUX0ZBTFNFX01FU1NBR0UgPSBcIlByb3ZpZGVkIHNob3VsZFJlY29ubmVjdCgpIHJldHVybmVkIGZhbHNlLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xudmFyIFNIT1VMRF9SRUNPTk5FQ1RfUFJPTUlTRV9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXNvbHZlZCB0byBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTdHVyZHlXZWJTb2NrZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R1cmR5V2ViU29ja2V0KHVybCwgcHJvdG9jb2xzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25vcGVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmRvd24gPSBudWxsO1xuICAgICAgICB0aGlzLm9ucmVvcGVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5DT05ORUNUSU5HID0gU3R1cmR5V2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgICAgIHRoaXMuT1BFTiA9IFN0dXJkeVdlYlNvY2tldC5PUEVOO1xuICAgICAgICB0aGlzLkNMT1NJTkcgPSBTdHVyZHlXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgICAgdGhpcy5DTE9TRUQgPSBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucyA9IFwiXCI7XG4gICAgICAgIHRoaXMubGFzdEtub3duUHJvdG9jb2wgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICBpZiAocHJvdG9jb2xzT3JPcHRpb25zID09IG51bGwgfHxcbiAgICAgICAgICAgIHR5cGVvZiBwcm90b2NvbHNPck9wdGlvbnMgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJvdG9jb2xzT3JPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbHMgPSBwcm90b2NvbHNPck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFwcGx5RGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgbm90IHByZXNlbnQgaW4gZ2xvYmFsIHNjb3BlIGFuZCBubyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwid3NDb25zdHJ1Y3RvciBvcHRpb24gd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiYmluYXJ5VHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5VHlwZUludGVybmFsIHx8IFwiYmxvYlwiO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiaW5hcnlUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJ1ZmZlcmVkQW1vdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gdGhpcy53cyA/IHRoaXMud3MuYnVmZmVyZWRBbW91bnQgOiAwO1xuICAgICAgICAgICAgdmFyIGhhc1Vua25vd25BbW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5rbm93bkFtb3VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzVW5rbm93bkFtb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coXCJTb21lIGJ1ZmZlcmVkIGRhdGEgaGFkIHVua25vd24gbGVuZ3RoLiBidWZmZXJlZEFtb3VudCgpXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiByZXR1cm4gdmFsdWUgbWF5IGJlIGJlbG93IHRoZSBjb3JyZWN0IGFtb3VudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJleHRlbnNpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MuZXh0ZW5zaW9ucyA6IHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndzID8gdGhpcy53cy5wcm90b2NvbCA6IHRoaXMubGFzdEtub3duUHJvdG9jb2w7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInJlYWR5U3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQ2xvc2VkID8gU3R1cmR5V2ViU29ja2V0LkNMT1NFRCA6IFN0dXJkeVdlYlNvY2tldC5PUEVOO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoY29kZSwgcmVhc29uKTtcbiAgICAgICAgdGhpcy5zaHV0ZG93bigpO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHBlcm1hbmVudGx5IGNsb3NlZCBieSBjbGllbnQuXCIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldCBpcyBhbHJlYWR5IGluIENMT1NJTkcgb3IgQ0xPU0VEIHN0YXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCByZWNvbm5lY3QoKSBvbiBzb2NrZXQgd2hpY2ggaXMgcGVybWFuZW50bHkgY2xvc2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoMTAwMCwgXCJDbGllbnQgcmVxdWVzdGVkIHJlY29ubmVjdC5cIik7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xvc2UodW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSB0aGlzLmxpc3RlbmVyc1t0eXBlXS5maWx0ZXIoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgIT09IGxpc3RlbmVyOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5vcGVuTmV3V2ViU29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgY29ubmVjdFRpbWVvdXQgPSBfYS5jb25uZWN0VGltZW91dCwgd3NDb25zdHJ1Y3RvciA9IF9hLndzQ29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJPcGVuaW5nIG5ldyBXZWJTb2NrZXQgdG8gXCIgKyB0aGlzLnVybCArIFwiLlwiKTtcbiAgICAgICAgdmFyIHdzID0gbmV3IHdzQ29uc3RydWN0b3IodGhpcy51cmwsIHRoaXMucHJvdG9jb2xzKTtcbiAgICAgICAgd3Mub25jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlQ2xvc2UoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVFcnJvcihldmVudCk7IH07XG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlTWVzc2FnZShldmVudCk7IH07XG4gICAgICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlT3BlbihldmVudCk7IH07XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBydW5uaW5nLCB3ZSBzdGlsbCBoYXZlbid0IG9wZW5lZCB0aGUgd2Vic29ja2V0LlxuICAgICAgICAgICAgLy8gS2lsbCBpdCBzbyB3ZSBjYW4gdHJ5IGFnYWluLlxuICAgICAgICAgICAgX3RoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICAgICAgX3RoaXMuZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2UodW5kZWZpbmVkKTtcbiAgICAgICAgfSwgY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLndzID0gd3M7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZU9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLndzIHx8IHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsQ2xlYXJSZXNldFRpbWUgPSB0aGlzLm9wdGlvbnMuYWxsQ2xlYXJSZXNldFRpbWU7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgb3BlbmVkLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5VHlwZUludGVybmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZUludGVybmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgPSB0aGlzLndzLmJpbmFyeVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0JlZW5PcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcInJlb3BlblwiLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJvcGVuXCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaGFzQmVlbk9wZW5lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLnNlbmQobWVzc2FnZSk7IH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxDbGVhclRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIF90aGlzLm5leHRSZXRyeVRpbWUgPSAwO1xuICAgICAgICAgICAgX3RoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIG9wZW5UaW1lID0gKGFsbENsZWFyUmVzZXRUaW1lIC8gMTAwMCkgfCAwO1xuICAgICAgICAgICAgX3RoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgcmVtYWluZWQgb3BlbiBmb3IgXCIgKyBvcGVuVGltZSArIFwiIHNlY29uZHMuIFJlc2V0dGluZ1wiICtcbiAgICAgICAgICAgICAgICBcIiByZXRyeSB0aW1lIGFuZCBjb3VudC5cIik7XG4gICAgICAgIH0sIGFsbENsZWFyUmVzZXRUaW1lKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcIm1lc3NhZ2VcIiwgZXZlbnQpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVDbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSBfYS5tYXhSZWNvbm5lY3RBdHRlbXB0cywgc2hvdWxkUmVjb25uZWN0ID0gX2Euc2hvdWxkUmVjb25uZWN0O1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy5sYXN0S25vd25FeHRlbnNpb25zID0gdGhpcy53cy5leHRlbnNpb25zO1xuICAgICAgICAgICAgdGhpcy5sYXN0S25vd25Qcm90b2NvbCA9IHRoaXMud3MucHJvdG9jb2w7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJkb3duXCIsIGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0Q291bnQgPj0gbWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29ubmVjdGluZyhldmVudCwgdGhpcy5nZXRUb29NYW55RmFpbGVkUmVjb25uZWN0c01lc3NhZ2UoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbGxSZWNvbm5lY3QgPSAhZXZlbnQgfHwgc2hvdWxkUmVjb25uZWN0KGV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWxsUmVjb25uZWN0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX0ZBTFNFX01FU1NBR0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbFJlY29ubmVjdC50aGVuKGZ1bmN0aW9uICh3aWxsUmVjb25uZWN0UmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3RSZXNvbHZlZCwgZXZlbnQsIFNIT1VMRF9SRUNPTk5FQ1RfUFJPTUlTRV9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcImVycm9yXCIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBlbmNvdW50ZXJlZCBhbiBlcnJvci5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZVdpbGxSZWNvbm5lY3QgPSBmdW5jdGlvbiAod2lsbFJlY29ubmVjdCwgZXZlbnQsIGRlbmlhbFJlYXNvbikge1xuICAgICAgICBpZiAod2lsbFJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZWVzdGFibGlzaENvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29ubmVjdGluZyhldmVudCwgZGVuaWFsUmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZWVzdGFibGlzaENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgbWluUmVjb25uZWN0RGVsYXkgPSBfYS5taW5SZWNvbm5lY3REZWxheSwgbWF4UmVjb25uZWN0RGVsYXkgPSBfYS5tYXhSZWNvbm5lY3REZWxheSwgcmVjb25uZWN0QmFja29mZkZhY3RvciA9IF9hLnJlY29ubmVjdEJhY2tvZmZGYWN0b3I7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQrKztcbiAgICAgICAgdmFyIHJldHJ5VGltZSA9IHRoaXMubmV4dFJldHJ5VGltZTtcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlUaW1lID0gTWF0aC5tYXgobWluUmVjb25uZWN0RGVsYXksIE1hdGgubWluKHRoaXMubmV4dFJldHJ5VGltZSAqIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IsIG1heFJlY29ubmVjdERlbGF5KSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub3Blbk5ld1dlYlNvY2tldCgpOyB9LCByZXRyeVRpbWUpO1xuICAgICAgICB2YXIgcmV0cnlUaW1lU2Vjb25kcyA9IChyZXRyeVRpbWUgLyAxMDAwKSB8IDA7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgd2FzIGNsb3NlZC4gUmUtb3BlbmluZyBpbiBcIiArIHJldHJ5VGltZVNlY29uZHMgKyBcIiBzZWNvbmRzLlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc3RvcFJlY29ubmVjdGluZyA9IGZ1bmN0aW9uIChldmVudCwgZGVidWdSZWFzb24pIHtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhkZWJ1Z1JlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJjbG9zZVwiLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyQWxsVGltZW91dHMoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuZGlzcG9zZVNvY2tldCgpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwb3NlU29ja2V0ID0gZnVuY3Rpb24gKGNsb3NlQ29kZSwgcmVhc29uKSB7XG4gICAgICAgIGlmICghdGhpcy53cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBub29wIGhhbmRsZXJzIGluc3RlYWQgb2YgbnVsbCBiZWNhdXNlIHNvbWUgV2ViU29ja2V0XG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9ucywgc3VjaCBhcyB0aGUgb25lIGZyb20gaXNvbW9ycGhpYy13cywgcmFpc2UgYSBzdGluayBvblxuICAgICAgICAvLyB1bmhhbmRsZWQgZXZlbnRzLlxuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IG5vb3A7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5jbG9zZShjbG9zZUNvZGUsIHJlYXNvbik7XG4gICAgICAgIHRoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQWxsVGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQ29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJBbGxDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbENsZWFyVGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFsbENsZWFyVGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudE9mVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uY2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNsb3NlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbm1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25vcGVuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uZG93bikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZG93bihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlb3BlblwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ucmVvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25yZW9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV1cbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gX3RoaXMuY2FsbExpc3RlbmVyKGxpc3RlbmVyLCBldmVudCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhZXZlbnQgfHwgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNhbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRlYnVnTG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmdldFRvb01hbnlGYWlsZWRSZWNvbm5lY3RzTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1heFJlY29ubmVjdEF0dGVtcHRzID0gdGhpcy5vcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzO1xuICAgICAgICByZXR1cm4gXCJGYWlsZWQgdG8gcmVjb25uZWN0IGFmdGVyIFwiICsgbWF4UmVjb25uZWN0QXR0ZW1wdHMgKyBcIiBcIiArIHBsdXJhbGl6ZShcImF0dGVtcHRcIiwgbWF4UmVjb25uZWN0QXR0ZW1wdHMpICsgXCIuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgICBhbGxDbGVhclJlc2V0VGltZTogNTAwMCxcbiAgICAgICAgY29ubmVjdFRpbWVvdXQ6IDUwMDAsXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgbWluUmVjb25uZWN0RGVsYXk6IDEwMDAsXG4gICAgICAgIG1heFJlY29ubmVjdERlbGF5OiAzMDAwMCxcbiAgICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgcmVjb25uZWN0QmFja29mZkZhY3RvcjogMS41LFxuICAgICAgICBzaG91bGRSZWNvbm5lY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgIHdzQ29uc3RydWN0b3I6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HID0gMDtcbiAgICBTdHVyZHlXZWJTb2NrZXQuT1BFTiA9IDE7XG4gICAgU3R1cmR5V2ViU29ja2V0LkNMT1NJTkcgPSAyO1xuICAgIFN0dXJkeVdlYlNvY2tldC5DTE9TRUQgPSAzO1xuICAgIHJldHVybiBTdHVyZHlXZWJTb2NrZXQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3R1cmR5V2ViU29ja2V0O1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKFN0dXJkeVdlYlNvY2tldC5ERUZBVUxUX09QVElPTlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgIHJlc3VsdFtrZXldID1cbiAgICAgICAgICAgIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFN0dXJkeVdlYlNvY2tldC5ERUZBVUxUX09QVElPTlNba2V5XVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldERhdGFCeXRlTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gVVRGLTE2IHN0cmluZ3MgdXNlIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLlxuICAgICAgICByZXR1cm4gMiAqIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcGx1cmFsaXplKHMsIG4pIHtcbiAgICByZXR1cm4gbiA9PT0gMSA/IHMgOiBzICsgXCJzXCI7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIE5vdGhpbmcuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/sturdy-websocket/dist/index.js\n");

/***/ }),

/***/ "../../node_modules/tslib/tslib.es6.js":
/*!*********************************************!*\
  !*** ../../node_modules/tslib/tslib.es6.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": function() { return /* binding */ __extends; },\n/* harmony export */   \"__assign\": function() { return /* binding */ __assign; },\n/* harmony export */   \"__rest\": function() { return /* binding */ __rest; },\n/* harmony export */   \"__decorate\": function() { return /* binding */ __decorate; },\n/* harmony export */   \"__param\": function() { return /* binding */ __param; },\n/* harmony export */   \"__metadata\": function() { return /* binding */ __metadata; },\n/* harmony export */   \"__awaiter\": function() { return /* binding */ __awaiter; },\n/* harmony export */   \"__generator\": function() { return /* binding */ __generator; },\n/* harmony export */   \"__createBinding\": function() { return /* binding */ __createBinding; },\n/* harmony export */   \"__exportStar\": function() { return /* binding */ __exportStar; },\n/* harmony export */   \"__values\": function() { return /* binding */ __values; },\n/* harmony export */   \"__read\": function() { return /* binding */ __read; },\n/* harmony export */   \"__spread\": function() { return /* binding */ __spread; },\n/* harmony export */   \"__spreadArrays\": function() { return /* binding */ __spreadArrays; },\n/* harmony export */   \"__spreadArray\": function() { return /* binding */ __spreadArray; },\n/* harmony export */   \"__await\": function() { return /* binding */ __await; },\n/* harmony export */   \"__asyncGenerator\": function() { return /* binding */ __asyncGenerator; },\n/* harmony export */   \"__asyncDelegator\": function() { return /* binding */ __asyncDelegator; },\n/* harmony export */   \"__asyncValues\": function() { return /* binding */ __asyncValues; },\n/* harmony export */   \"__makeTemplateObject\": function() { return /* binding */ __makeTemplateObject; },\n/* harmony export */   \"__importStar\": function() { return /* binding */ __importStar; },\n/* harmony export */   \"__importDefault\": function() { return /* binding */ __importDefault; },\n/* harmony export */   \"__classPrivateFieldGet\": function() { return /* binding */ __classPrivateFieldGet; },\n/* harmony export */   \"__classPrivateFieldSet\": function() { return /* binding */ __classPrivateFieldSet; }\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDTztBQUNQLG9DQUFvQztBQUNwQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0RBQWtELFFBQVE7QUFDMUQseUNBQXlDLFFBQVE7QUFDakQseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQix1RkFBdUYsY0FBYztBQUN0SCx1QkFBdUIsZ0NBQWdDLHFDQUFxQywyQ0FBMkM7QUFDdkksNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLDZDQUE2QyxVQUFVLHNEQUFzRCxjQUFjO0FBQzVJLDBCQUEwQiw2QkFBNkIsb0JBQW9CLGdEQUFnRCxrQkFBa0I7QUFDN0k7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDTztBQUNQLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz9mN2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "../../node_modules/@alch/alchemy-web3/node_modules/web3/package.json":
/*!****************************************************************************!*\
  !*** ../../node_modules/@alch/alchemy-web3/node_modules/web3/package.json ***!
  \****************************************************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"name":"web3","version":"1.6.0","description":"Ethereum JavaScript API","repository":"https://github.com/ethereum/web3.js","license":"LGPL-3.0","engines":{"node":">=8.0.0"},"main":"lib/index.js","bugs":{"url":"https://github.com/ethereum/web3.js/issues"},"keywords":["Ethereum","JavaScript","API"],"author":"ethereum.org","types":"types/index.d.ts","scripts":{"compile":"tsc -b tsconfig.json","dtslint":"dtslint --localTs ../../node_modules/typescript/lib types","postinstall":"echo \\"WARNING: the web3-shh and web3-bzz api will be deprecated in the next version\\""},"authors":[{"name":"Fabian Vogelsteller","email":"fabian@ethereum.org","homepage":"http://frozeman.de"},{"name":"Marek Kotewicz","email":"marek@parity.io","url":"https://github.com/debris"},{"name":"Marian Oancea","url":"https://github.com/cubedro"},{"name":"Gav Wood","email":"g@parity.io","homepage":"http://gavwood.com"},{"name":"Jeffery Wilcke","email":"jeffrey.wilcke@ethereum.org","url":"https://github.com/obscuren"}],"dependencies":{"web3-bzz":"1.6.0","web3-core":"1.6.0","web3-eth":"1.6.0","web3-eth-personal":"1.6.0","web3-net":"1.6.0","web3-shh":"1.6.0","web3-utils":"1.6.0"},"devDependencies":{"@types/node":"^12.12.6","dtslint":"^3.4.1","typescript":"^3.9.5","web3-core-helpers":"1.6.0"},"gitHead":"a34afae56647615d7cbdfa227af8a1389476e2d6"}');

/***/ })

});